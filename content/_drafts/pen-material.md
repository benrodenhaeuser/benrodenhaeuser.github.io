---
title: Pen Material
type: major
---

## Introduction
{: .no-toc }

Pen is a vector design application that combines the drawing canvas for visual editing typical for tools of this kind with a markup editor that represents the vector art as SVG markup. 

> - The major challenges I faced were …
> - Mention working from scratch here? The project also has an educational dimension. 
> - I did not want to adopt the high-level solutions that other people have developed, even though I was very much willing to be inspired by their ideas.
{: .notes }

## Motivation

### Use cases
Nowadays, many websites and web applications rely on SVG, due to its pretty unique blend of attractive features – SVGs tends to be small in terms of file size, they provide a crisp look at all screen resolutsion, they are easy to edit, and provide a good target format for animation code. 
When I started developing Pen, I had two primary use cases in mind:

- *Aid the Learning Process.* Designers that want to make the most out of SVG need to acquire a working knowledge of its markup language. While using markup as a tool for creating vector images from scratch is tedious, to say the least, having a good grasp of the way SVG works is indispensable if you want to do put it on the web as is, or even animate it. This can be a challenge, as parts of SVG markup may appear [„pretty indecipherable … a ton of numbers and letters smashed together into a long string.“][1] Pen aims to be a learning aid in this context.
- *Enhance SVG Workflows.* SVGs are typically created in a graphics editor, and prepared for use on the web in a code editor. This can create a gap between the designer’s task of creating visuals, and the developer’s task of site integration (even if designer and developer happen to be the same person). Pen aims to help bridge that gap.

So Pen aims to be both a learning tool, and help with workflows for putting SVG on the web. 

### Main idea
As mentioned above, people work with SVG from two angles, using design tools (like Sketch or Illustrator), and developer tools (like a code editor, or a build tool). In a design tool, the SVG language takes the back-seat and is hidden from the user’s view. A code editor, on the other hand, typically offers no dedicated tools for working with graphics-oriented markup. To inspect the result of styles being applied to an SVG, e.g., we need yet another tool, typically, a web browser. For this reason, I felt that a tool was needed that speaks both languages, graphics and markup. 

The idea, then, is to treat markup as a first-class citizen, on a par with graphical output. Pen allows users to directly manipulate their artwork using markup, and conversely, makes the markup representation of drawing actions immediately visible. Here is how this looks in action:

![][image-1]
Pen interface featuring drawing canvas and markup editor.
{: .image .border }

As the screen capture shows, the distinguishing feature of Pen is that the shapes on the drawing canvas and the elements in the markup editor *live-sync*. The user may thus, e.g., edit the stroke or fill of a shape in markup, and have the change immediately reflected on the drawing canvas.

### Inspirations
A major inspiration for the approach taken by Pen was Framer, a design tool that in its [„Classic“][2] incarnation, made some waves in the design community a couple of years ago, boasting a side-by-side representation of JavaScript code (CoffeeScript, to be precise) and an interactive prototype generated by that code:  

![][image-2]
Framer Classic interface with layer pane (to the left), code pane (in the middle), and prototype pane.
{: .image }

Another inspiration were the developer tools offered by modern browsers, that have come a long way since „View Source“. Modern DevTools offer a myriad ways of interacting with your website or web application. One possible – and, in my opinion, desirable – future path for them would be to grow into [web-based, standalone products][3] that target the needs of those who need to see the code generating the product alongside with the product itself, on an on-going basis, be it designers or developers. On a more modest scale, Pen aims for something similar. 

> - The solution Pen offers by these use cases is to treat drawing and markup editing as two sides of the same coin. 
> - To this end, the live-sync between drawing canvas and markup editor provided by Pen is helpful, as it makes …
> - Pen aims to facilitate this process by allowing direct manipulation of the markup underlying the artwork with immediate visual feedback. This allows to create artwork that can be more easily made production-ready …
{: .notes }

## Features

> *There’s a truly enormous depth of features that people expect in a design tool. Until you get down to that level, nobody will even consider using your app.* [Pieter Omvlee][4]
{: .quote }

With the help of some initial research and prototyping, it quickly became clear to me that developing a production-ready application was wildly out of scope for the phase of this project documented here. This is nicely summarized by the above quote by Pieter Omvlee, the creator of [Sketch][5]. The first task was thus to settle on an ambitious, yet manageable feature set for an initial, proof-of-concept type release.  Here is what I decided Pen should be able to do out of the gate:

### Drawing tools
From a user perspective, a design tool like Pen at the very least should provide:
- *drawing mode* (create and edit shapes on the canvas)
- *select mode* (select and transform shapes)
- *group/ungroup* (hierarchically organize shapes)

> Give a visual idea
{: .notes}

### Markup editing
As per what was said above, we also need to offer: 
- a *markup editor* with at least minimal amenities
- *two-way live-sync* between drawing canvas and markup editor

> Give a visual idea
{: .notes}

### Document management
In addition, users will expect to find a number of document management features in a modern in-browser application:
- *CRUD:* commit documents to storage, retrieve, update and delete them
- *auto-save:* persist changes to storage without user intervention
- *undo:* revert to previous states of the current editing session

These features lie at the intersection of what I felt was feasible and what I deemed desirable for a product that I would feel comfortable sharing with the world. A mature application will, of course, have to support both a broader feature set, and additional depth to the features mentioned.

## Design Problems

This section aims to get the main problems an application like Pen has to solve in perspective. 

{::comment }
> The above feature list talks about shapes and their hierarchical relations, about a canvas and a markup editor, about documents and the way they are managed. We need to find a technical language that makes these concepts amenable for computational processing. 
{:/comment }

### Drawing API
Let’s start on the fairly concrete level of the application domain: how to put a vector-based drawing on the screen? For this purpose, we need a drawing API that enables us to

1. represent visual shapes in a mathematical fashion,
2. express ways of manipulating such shapes (scale, rotate or move them), and
3. organize them in some kind of hierarchical data structure.

For the three above-mentioned tasks, established solutions are available: 

> #### Scene graphs
> The most fundamental data structure used in vector-based graphics applications is the scene graph. These are tree(-like) data structures that model relations between domain objects, based on the fundamental intuition of a world consisting of things arranged in part-whole relations. Legs are body parts, the house is a part of the neighborhood, and so on. Similarly, graphical shapes are naturally seen by the user as composed of smaller parts, and we should be able to treat such complex entities as a whole. (In applications like Illustrator, layers are wholes, and the children of a layer are the parts of which the whole is composed. In SVG, layers are called groups. SVG can thus be seen as a language for describing scene graphs.)
> #### Matrix transformations
> As pointed out above, a main point of the scene graph data structure is to make it easy to manipulate parts that belong together as a whole. In mathematical terms, such transformations can be implemented by means of matrix multiplication. To transform a shape or group in two-dimensional space by means of a rotation, e.g., we can multiply the current transformation matrix of the shape or group with another matrix representing the rotation angle, and the center of rotation.
> #### Bezier curves
> The leaf nodes in a scene graph consist of shapes that are defined mathematically. Bezier curves are a dominant paradigm in 2D vector applications like Illustrator, Sketch and the like. Bezier curves are specified by a number of anchor points and handle that determine parametrized curves. They may be composed to splines consisting of several such curves. The SVG path syntax relies on such curves.

### Document structure

Basics
- Represent shapes
- Allow to manipulate shapes and groups of shapes
- Easy to render
- Take into account hierarchical relations between shapes: compose shapes into groups and be able to treat the group as a single whole
- Not tied up to a particular rendering engine
- Extensible: besides grouping as an operation for composing shapes, there are more advanced operations like intersecting shapes or taking their union (*Boolean operations*), or using one shape as a clipping mask for another
- While Pen does not implement these features, we require extensibility in the sense that implementing some of these advanced features should not force us to start from scratch

*Solution:* scene graph that uses Bezier curves to represent primitive shapes, groups to represent wholes composed of smaller parts, and matrix transformations as a means of expressing manipulations to those shapes. 

In Gang of Four terminology, this is an instance of the „Composite Pattern“ 

Need a diagram here showing a simple document, or perhaps an object representation alongside with a visual representation.

Document representations:
- Above is very high-level. 
- Given a document, we want to be able to generate various representations of it. 
- In particular, we need to be able to generate a canvas representation and a markup representation, and a serialized representation that can be persisted to a data store of some kind.
- Need to ensure canvas and markup representation are in sync.

- To actually render the current state of a document to the screen, we need to convert it to something the rendering engine understands.

*Solution:* Our rendering engine is the browser. Since the browser natively supports SVG, all we really need to do is to convert our internal data structure to SVG DOM nodes, and the browser will take care of the rest.  

- Suggests to *untie the document from the format used by the rendering engine*, because that format turns out to be just one among a multitude of representations.

### User interface
- We don’t want to be forced to fix the interface upfront. 
- Particular choices in this area tend to be ephemeral
- We don’t want to have to change internals as we change the application.

### Persistence layer („document management“)
- Global persistence
	- Should we go with a relational database or a document-oriented one? 
	- Auto-Save
- Session persistence
	- Needs to be fast (without network requests)
- Our notion of Undo is state-oriented rather than command-oriented.

*Solution:* Use MongoDB, since its document-oriented. Our data is strongly document-oriented, and not very relational. 

> If the data in your application has a document-like structure (i.e., a tree of one-to-many relationships, where typically the entire tree is loaded at once), then it’s probably a good idea to use a document model. [Martin Kleppmann]()

### User Events
As it turns out, the main challenges of developing Pen are *app-centric* rather than *domain-centric*. 

> Our application is strongly interactive
> Given that we have an internal representation of visual content using the above ingredients, the real work just begins. Remember that we are not …
> Still, the concepts mentioned are so clear that I was able to more or less take them off the shelf and express them in code.
> While understanding the details of these concepts takes a bit of time, there is no rocket science involved. The real challenges for an application like Pen lie in crafting the editor.
> - Event Handling
> 	- Accept a variety of inputs that change the internal state, both via mouse input on the canvas, and via keyboard input in the markup editor
> 	- Diversity of inputs
> 	- What do they mean? 
> - State Management
> 	- Complex application state
> 	- Variety of data representations: 
> 		- persistence layer
> 		- history
> 		- view
> 		- markup representation
> 		- canvas representation
> 	- Maintain the application state in some sort of useful data structure
> 	- Generate, and display a markup representation of the current scenegraph
> - Challenges: 
> 	- Complexity explosion
> 	- Have many „data formats“ representing roughly the same thing:
> 		- markup editor
> 		- drawing canvas
> 		- database storage
> 		- *keep all this stuff in sync!*
> 	- Challenges of making a vector editor in the first place
> 	- Develop a sensible data model that allows us to represent nested shapes of Bezier splines and (possibly nested) transformations applied to them. 
> 	- Manage complexity  — state management
> 	- Organize data flow to support live-sync
> 	- Optimize code so as to support short response times.
> - This is also due to the fact that I decided early on to develop Pen from scratch, rather than relying on a framework such as React or Vue. 
> - After doing a ton of research, and developing a number of small prototypes, I had developed a number of ideas for how I wanted to tackle the complexity explosion alluded to above. 
> - Should we talk about the choices we faced? Which libraries to use, which development style to pursue 
> - jQuery style/React style: the jQuery style just won’t cut it. I was afraid of being boxed in by a framework. I wanted to explore the organizational challenges that come with a project like Pen to depth.
> - jQuery has an „imperative style“, React aims at a more „declarative“, pure/functional style
> - Paper.js, Codemirror
> - Making an in-browser code editor is hard, and has little to do with our application’s core domain
> - Making an in-browser graphics editor is also kind of hard (as I found out), but more manageable, and more deeply tied to our application’s core domain
{: .notes }

*Rules of thumb:*
- Modularize the application as much as possible. 
- Keep DOM manipulation separate from core domain/application logic.

> Decision: Use an internal scene graph, and convert it into an SVG DOM as needed. Why?
> Our scene graph depicts not simply an SVG, but an editor! That is an important distinction.
{: .notes }

### Event management
- The whole point of an editing-oriented application is to make documents dynamic at run-time: users should be able to not just view documents, but change them.
- Need to support a multitude of events (keyboard, pointer device)
- Need a mechanism to individuate user actions as discrete *editing steps* and classify these steps by their type. This is necessary for both undo/redo and auto-save. 

## Blueprint

> Software architecture consists of the decisions that are hard to change. [Martin Fowler][7]
{: .quote }

### The onion model

> - Time to draw the results of the preceding analysis together in a blueprint for the application.
> - The high-level design I settled on is represented in the diagram below.
> - Heavily inspired by hexagonal architecture, about which you can read more [here]().

- *Domain*
	- contains all the business logic		
		- is not tied to a particular host environment (such as the browser)
- *Application*
	- applies the inputs that originate at the periphery to the domain
		- is not the actual app, despite the name
- *Periphery*
	- hooks up the (environment-independent) core with a specific environment
	- applies internal changes to the environment (e.g., by updating the DOM), and converts external events (e.g., user events) to inputs that are sent to the core
- *Environment*
	- consists of the technologies that the periphery is hooked up with (e.g., the browser environment)
	- is visible only to the periphery, not to the core

> - Pen isolates domain logic and application framework from what I call „peripheral devices“ or „peripherals“. Peripherals include the view layer (i.e., the UI), but also database access, and the app history (a device that keeps track of past application states, and enables undo/redo functionality). 
> - Peripherals are not allowed to directly talk to the domain. They interact solely with the app framework wrapped around the domain logic.  
> - Just as real life peripherals do, our peripherals play a double role: they are input and output devices. A user may use the mouse to provide an input. A screen displays the output of a program. If the screen happens to be a touch-screen, we can think of it as both an input and an output device. 
> - The two roles naturally translate to a more technical perspective:
> 	- *Peripherals observe the application core:* The application core maintains a list of periphal devices that are attached to it and should be notified of changes. Every state transition is taken to correspond to a „tick of the clock“, and will result in observers being notified. This may result, e.g., in a visual update of the app viewport, or a network request being sent. 
> 	- *Peripherals initiate state transitions:* Events occuring at the periphery trigger inputs that are sent to the core. The finite state machine that sits at the core processes the input, mutates the scenegraph, and notifies the observers.
> - The picture below illustrates the cyclic nature of this process. 
{: .notes }

### Environment
- browser interfaces
	- `Document` and `Window` interfaces
	- `Event` interface
	- `Fetch` API
	- `History` interface
- server
	- Sinata/MongoDB

### Periphery

- `ui`
- `db`
- `hist`

### Application

Finite state machines

As another measure to cope with the potential for complexity explosion alluded to above, Pen imposes further structure on the application using *finite state machines* (FSMs). The basic flow is as follows:

- The finite state machine is always in a particular internal *state*, characterized by a label, which is simply a string.
- The machine accepts *inputs* that may change its internal state. Inputs are plain JS objects.
- An input that is acceptable in a given state results in a state *transition*, i.e., the internal state of the FSM changes to a new label. 
- As the machine transitions to a new state, an *update* is issued that mutates the scenegraph.

The update is simply a callback attached to the transition. It should be pointed out that the only way of changing the scenegraph is through an update, that is, a callback triggered by a state transition. The machine thus acts as a strict gatekeeper for our application. Since core and periphery are effectively decoupled (see above), the only way for a peripheral device to initiate a change in the application core is to send an input that results in a transition, which triggers an update as its associated callback function.

> - The callback is the *output* of the machine.
> - The machine *controls* the application flow.
> - Our machine is a *Mealy machine*, a particular type of *finite state transducer*.
> - [The Rise of the State Machines][9]
> - [How I Learned to Stop Worrying and Love the State Machine][10]
{: .notes }

	{
	  from: { 
	    mode: 'select', 
	    label: 'idle' 
	  },
	  input: {
	    type: 'mousedown',  
	    target: [types.CURVE, types.SHAPE, types.GROUP, types.CANVAS]
	  },
	  output: 'select',
	  to: { 
	    mode: 'select', 
	    label: 'shifting'
	  },
	}

- Splits the app into a series of discrete commands (inputs).

### Domain

- editor tree (scenegraph is part of it)

As in Redux, data flow in Pen is *unidirectional*, and respects the *single source of truth* principle. Unlike Redux, however, Pen documents are *mutable data structures*. 

- Lose the tight bundling of objects and their behaviour typical for the object-oriented style of programming

- The primary reason Redux employs a functional approach is to enable shallow comparisons. 
- However, we can still make use of them in an indirect manner.

Why not use the Redux pattern? 
- Are there disadvantages? 
- Does it flow out of the idea of a finite state machine with callbacks?
- In a sense. 

> Immutability in the context of a Web app enables sophisticated change detection techniques to be implemented simply and cheaply, ensuring the computationally expensive process of updating the DOM occurs only when it absolutely has to. [Redux Docs][11]
{: .quote }

## Event Loop

Here is a slightly simplified description of the event loop implemented in the Pen application.

- An event occurs in the environment and is dispatched to our app. 
- This results in a previously registered callback being invoked. 
- The callback processes the event into a command that is passed to the application layer. 
- If the command is executable in the current state, the application finds a state transition corresponding to the command using the transition table.
- The machine transitions to a new state, and another callback is triggered that mutates the editor tree.
- Once that callback has run, all peripherals are notified of a recent state change by receiving a description of the state change. 
- The peripheral devices inspect the notification and decide if the state change merits their attention.
- If so, the peripheral ensures that appropriate changes are made to the environment, using one of the DOM APIs.

The description closely corresponds to a series of nested function calls (hyperlinks point to the source code):

- event handler (peripheral layer)
- `execute(command)` (application layer)
- `invoke(update, state, command)` (domain layer)
- `publish(description)` (application layer)
- `react(description)` (periphery layer)

Notice how the current task originates in the environment, and moves inwards, traversing application layers all the way through the domain, and moves back outwards, to the periphery, which triggers appropriate changes in the environment.

## Optimization

### The RAIL model

- response (discrete tasks)
- animate (continuous tasks)

> People can only tolerate a lack of visual feedback to their actions for a limited time. For continuous actions like gestures and scroll, this limit is low. (Even skipping a single 16ms frame feels “janky”.) For discrete actions like clicks, there is research saying users perceive any \< 100ms delays as equally fast. If an action takes longer, we need to show a visual indicator. But there are some counter-intuitive challenges. Indicators that cause the page layout to “jump” or that go through several loading “stages” can make the action feel longer than it was. Similarly, handling an interaction within 20ms at the cost of dropping an animation frame can feel slower than handling it within 30ms and no dropped frames. Brains aren’t benchmarks. How do we keep our apps responsive to different kinds of inputs? [Dan Abramov]()
{: .quote }

### Synchronizing with the rendering engine

- `requestAnimationFrame`

### Optimizing the app cycle

- Use structural sharing
	- Swap components only when their props are changed
- Postpone workloads
	- If you are aiming for a frame budget of around 16ms, every little bit helps.
- Minimize painting
	- split SVG paths into Bezier curves

## Material
{: .no-toc } 

- [Dan Abramov: React as a UI Runtime][13]
- [Dan Abramov: The Elements of UI Engineering][14]
- [Reginald Braithwaite: How I learned to stop worrying and love the state machine][15]
- [SVG For Developers: Why You Should Be Using Them If You’re Not Ready][16]
- [CSS Tricks: The SVG path syntax: an illustrated guide][17]
- [A practical guide to SVG and Design Tools][18]
- [The Past, Present and Future of Sketch (Pieter Omvlee)][19]
- [An Interview with Pieter Omvlee, the Founder of Bohemian Coding][20]
- [An Ode to the Bezier curve][21]
- [Understanding and Implementing Scene Graphs][22]
- [Open Scene Graph: The Basics][23]
- [Jake Giltsoff: SVG on the web][24]
- [Avi Bar-Zeev: Scenegraphs: Past, Present and Future][25]
- [ShapeShifter][26]


## Terminologial changes in Pen

- `description` should be called `notification`
- `input` should be called `command`

[1]:	https://css-tricks.com/svg-path-syntax-illustrated-guide/
[2]:	https://classic.framer.com
[3]:	http://patrickbrosset.com/articles/2017-02-01-where-is-devtools-headed.html
[4]:	https://layervault.tumblr.com/post/100588054474/an-interview-with-pieter-omvlee-the-founder-of
[5]:	https://www.sketch.com
[7]:	https://www.youtube.com/watch?time_continue=345&v=DngAZyWMGR0
[9]:	https://www.smashingmagazine.com/2018/01/rise-state-machines/
[10]:	http://raganwald.com/2018/02/23/forde.html
[11]:	https://redux.js.org/faq/immutable-data#what-are-the-benefits-of-immutability
[13]:	https://overreacted.io/react-as-a-ui-runtime/
[14]:	https://overreacted.io/the-elements-of-ui-engineering/
[15]:	https://raganwald.com/2018/02/23/forde.html
[16]:	https://deliciousbrains.com/svg-advantages-developers/
[17]:	https://css-tricks.com/svg-path-syntax-illustrated-guide/
[18]:	https://www.smashingmagazine.com/2019/05/svg-design-tools-practical-guide/
[19]:	https://medium.com/habit-of-introspection/the-past-present-and-future-of-sketch-d5237879b7af
[20]:	https://layervault.tumblr.com/post/100588054474/an-interview-with-pieter-omvlee-the-founder-of
[21]:	https://blog.prototypr.io/an-ode-to-the-bezier-curve-3eb9eca038ff
[22]:	http://archive.gamedev.net/archive/reference/programming/features/scenegraph/index.html
[23]:	https://stackedboxes.org/2010/05/05/osg-part-1-the-basics/
[24]:	https://svgontheweb.com
[25]:	https://web.archive.org/web/20190207215718/http://www.realityprime.com/blog/2007/06/scenegraphs-past-present-and-future/
[26]:	https://beta.shapeshifter.design

[image-1]:	/assets/images/pen/out.gif
[image-2]:	/assets/images/pen/framer.png