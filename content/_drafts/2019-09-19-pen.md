---
title: Pen
type: major
description: A vector design tool that live-syncs a drawing canvas with an SVG markup editor.
abstract: Pen is a vector design tool that live-syncs a drawing canvas with an SVG markup editor. I built it from scratch in JavaScript, developing a custom application framework based on finite state machines and the „hexagonal architecture“ pattern, with a simple Sinatra/MongoDB backend for storage.
header-image: /assets/images/pen/warnock.png
image-caption: John Warnock drawing a cubic Bezier curve.
external-links:
  github: https://github.com/benrodenhaeuser/pen 
  demo: https://pen.benrodenhaeuser.io
---

## Introduction
{: .no-toc }

Pen is a vector design application that combines the drawing canvas for visual editing typical for tools of this kind with a markup editor that represents the vector art as SVG markup. 

> - The major challenges I faced were …
> - Working from scratch (?)
> - I did not want to adopt the high-level solutions that other people have developed, even though I was very much willing to be inspired by their ideas.
{: .notes}

## Motivation

### Use cases
Nowadays, many websites and web applications rely on SVG, due to its pretty unique blend of attractive features – SVGs tends to be small in terms of file size, they provide a crisp look at all screen resolutsion, they are easy to edit, and provide a good target format for animation code. 
When I started developing Pen, I had two primary use cases in mind:

- *Aid the Learning Process.* Designers that want to make the most out of SVG need to acquire a working knowledge of its markup language. While using markup as a tool for creating vector images from scratch is tedious, to say the least, having a good grasp of the way SVG works is indispensable if you want to do put it on the web as is, or even animate it. This can be a challenge, as parts of SVG markup may appear [„pretty indecipherable … a ton of numbers and letters smashed together into a long string.“][1] Pen aims to be a learning aid in this context.
- *Enhance SVG Workflows.* SVGs are typically created in a graphics editor, and prepared for use on the web in a code editor. This can create a gap between the designer’s task of creating visuals, and the developer’s task of site integration (even if designer and developer happen to be the same person). Pen aims to help bridge that gap.

So Pen aims to be both a learning tool, and help with workflows for putting SVG on the web. 

### Main idea
As mentioned above, people work with SVG from two angles, using design tools (like Sketch or Illustrator), and developer tools (like a code editor, or a build tool). In a design tool, the SVG language takes the back-seat and is hidden from the user’s view. A code editor, on the other hand, typically offers no dedicated tools for working with graphics-oriented markup. To inspect the result of styles being applied to an SVG, e.g., we need yet another tool, typically, a web browser. For this reason, I felt that a tool was needed that speaks both languages, graphics and markup. 

The idea, then, is to treat markup as a first-class citizen, on a par with graphical output. Pen allows users to directly manipulate their artwork using markup, and conversely, makes the markup representation of drawing actions immediately visible. Here is how this looks in action:

![][image-1]
Pen interface featuring drawing canvas and markup editor.
{: .image .border}

As the screen capture shows, the distinguishing feature of Pen is that the shapes on the drawing canvas and the elements in the markup editor *live-sync*. The user may thus, e.g., edit the stroke or fill of a shape in markup, and have the change immediately reflected on the drawing canvas.

### Inspirations
A major inspiration for the approach taken by Pen was Framer, a design tool that in its [„Classic“][2] incarnation, made some waves in the design community a couple of years ago, boasting a side-by-side representation of JavaScript code (CoffeeScript, to be precise) and an interactive prototype generated by that code:  

![][image-2]
Framer Classic interface with layer pane (to the left), code pane (in the middle), and prototype pane.
{: .image}

Another inspiration were the developer tools offered by modern browsers, that have come a long way since „View Source“. Modern DevTools offer a myriad ways of interacting with your website or web application. One possible – and, in my opinion, desirable – future path for them would be to grow into [web-based, standalone products][3] that target the needs of those who need to see the code generating the product alongside with the product itself, on an on-going basis, be it designers or developers. On a more modest scale, Pen aims for something similar. 

> - The solution Pen offers by these use cases is to treat drawing and markup editing as two sides of the same coin. 
> - To this end, the live-sync between drawing canvas and markup editor provided by Pen is helpful, as it makes …
> - Pen aims to facilitate this process by allowing direct manipulation of the markup underlying the artwork with immediate visual feedback. This allows to create artwork that can be more easily made production-ready …
{: .notes }

## Feature Set

> *There’s a truly enormous depth of features that people expect in a design tool. Until you get down to that level, nobody will even consider using your app.* [Pieter Omvlee][4]
{: .quote }

With the help of some initial research and prototyping, it quickly became clear to me that developing a production-ready application was wildly out of scope for the phase of this project documented here. This is nicely summarized by the above quote by Pieter Omvlee, the creator of [Sketch][5].

The first order of business, then, was to settle on an ambitious, yet manageable feature set for an initial, proof-of-concept type release.  From a high-level perspective, here is what I decided Pen should be able to do out of the gate.

### Drawing tools
From a user perspective, a design tool like Pen at the very least should provide:
- *drawing mode* (create and edit shapes on the canvas)
- *select mode* (select and transform shapes)
- *group/ungroup* (hierarchically organize shapes)

### Markup editing
As per what was said above, we also need to offer: 
- a *markup editor* with at least minimal amenities
- *two-way live-sync* between drawing canvas and markup editor

### Document management
In addition, we need some document management features that users will expect from a modern document-oriented application in the browser.
- *CRUD:* commit documents to storage, retrieve, update and delete them
- *auto-save:* persist changes to storage without user intervention
- *undo:* revert to previous states of the current editing session

These features lie at the intersection of what I felt was feasible and what I deemed desirable for a product that I would feel comfortable sharing with the world. A mature application will, of course, have to support both a broader feature set, and additional depth to the features mentioned.

## Challenges

This section aims to get the main challenges in developing an app like Pen in perspective. They fall into two categories: domain-centric, and app-centric. 

{::comment}
> The above feature list talks about shapes and their hierarchical relations, about a canvas and a markup editor, about documents and the way they are managed. We need to find a technical language that makes these concepts amenable for computational processing. 
{:/comment}

### Domain-centric challenges
Let’s start on the fairly concrete level of the application domain: how to put a vector-based drawing on the screen? For this, we need a drawing API that enables us to
1. represent primitive visual shapes in a mathematical fashion,
2. express ways of manipulating shapes (scale, rotate, move etc),
3. organize them in some kind of data structure, and
4. render visual data to the screen.

In our present context, the last task is actually not that complicated, as it is taken care of by the browser environment we have chosen to work in. Since the browser natively supports SVG, we can programmatically create SVG DOM nodes that correspond to our visual content, and the browser will take care of the rest. 

For the first three tasks, well-known concepts are available. *Bezier curves* are an ubiquitous means of representing visual information (even though there are other choices, like NURBS); the manipulation of shapes can be expressed in terms of *matrix transformations*; and the data structure of choice used by most vector-oriented applications is the *scene graph*. 

> #### Scene graphs 
> - The most fundamental data structure used in vector-based graphics applications is the scene graph. 
> - The fundamental intuition that makes scene graphs so useful is probably this: „The world consists of things made from parts.“
> - A scene graph is a tree(-like) data structure whose purpose is to structure information about the world into hierarchical relations.
> - The SVG format itself should be seen as a scene graph representation language for 2D drawings. 
> - For our purposes: shapes and groups.
> - More generally, in 3D graphics and game programming, scene graphs will typically contain additional objects, such as cameras, light sources, and information about actions. 
> - This article gives good intuitions why scene graphs are so useful, drawn from the context of game programming. 
> 
> #### Bezier curves 
> - The leaf nodes in a scene graph typically consist of Bezier paths (or some other kind of paths).
> 
> #### Matrix transformations
> - Scene graph objects may be altered by means of various transformations such as rotation, scaling, and movement. 
> - Such transformations can be applied to individual shapes as well as to group nodes

[Paper.js][6] is a library that integrates these concepts in a nice and very comprehensive drawing API. Using this library as a „vector graphics workhorse“ for Pen would thus have been a natural choice. However, Paper.js runs on top of the HTML5 canvas rather than on top of the SVG capabilities of the browser. This is somewhat at cross-purposes with Pen, since it would have involved working with yet another technology that we are ultimately not interested in. Still, relying on Paper.js is something I am considering for a later version of Pen, especially since Paper.js provides support for a number of features that are very important in practice, but time-consuming to implement, in particular Boolean operations on paths. For now, Pen uses only two low-level libraries for working with Bezier curves and matrix transformations ([Bezier.js][7] and [mat2d][8]). Essentially, all the domain logic related to representing and organizing vector shapes is implemented from scratch. While this took some time to get right, it will not be the main focus of this case study. 

### App-centric challenges
The above concepts are some of the key ingredients for developing a simple drawing API. However, the main challenges of developing Pen are *app-centric* rather than *domain-centric*.

Given that we have an internal representation of visual content using the above ingredients, the real work just begins. Remember that we are not …

> Still, the concepts mentioned are so clear that I was able to more or less take them off the shelf and express them in code.
> While understanding the details of these concepts takes a bit of time, there is no rocket science involved. The real challenges for an application like Pen lie in crafting the editor.

> It’s all about complexity. [John Ousterhout]()
{: .quote}


- Event Handling
	- Accept a variety of inputs that change the internal state, both via mouse input on the canvas, and via keyboard input in the markup editor
	- Diversity of inputs
	- What do they mean? 
- State Management
	- Complex application state
	- Variety of data representations: 
		- persistence layer
		- history
		- view
		- markup representation
		- canvas representation
	- Maintain the application state in some sort of useful data structure
	- Generate, and display a markup representation of the current scenegraph

Challenges: 
- Complexity explosion
- Have many „data formats“ representing roughly the same thing:
	- markup editor
	- drawing canvas
	- database storage
	- *keep all this stuff in sync!*
- Challenges of making a vector editor in the first place
- Develop a sensible data model that allows us to represent nested shapes of Bezier splines and (possibly nested) transformations applied to them. 
- Manage complexity  — state management
- Organize data flow to support live-sync
- Optimize code so as to support short response times.

This is also due to the fact that I decided early on to develop Pen from scratch, rather than relying on a framework such as React or Vue. 

After doing a ton of research, and developing a number of small prototypes, I had developed a number of ideas for how I wanted to tackle the complexity explosion alluded to above. 

> - Should we talk about the choices we faced? Which libraries to use, which development style to pursue 
> - jQuery style/React style: the jQuery style just won’t cut it. I was afraid of being boxed in by a framework. I wanted to explore the organizational challenges that come with a project like Pen to depth.
> - jQuery has an „imperative style“, React aims at a more „declarative“, pure/functional style
> - Paper.js, Codemirror
> - Making an in-browser code editor is hard, and has little to do with our application’s core domain
> - Making an in-browser graphics editor is also kind of hard (as I found out), but more manageable, and more deeply tied to our application’s core domain
{: .notes}

*Rules of thumb:*
- Modularize the application as much as possible. 
- Keep DOM manipulation separate from core domain/application logic.

> Decision: Use an internal scene graph, and convert it into an SVG DOM as needed. Why?
> Our scene graph depicts not simply an SVG, but an editor! That is an important distinction.
{: .notes}

## Decisions

> In software architecture, you are concerned about the decisions that are hard to change. [Martin Fowler][10]
{: .quote}

The high-level design I settled on is represented in the diagram below.

### Hexagonal architecture

The core feature of hexagonal architecture is …

- *The Core*
	- *The Domain*
		- contains all the business logic		
		- is not tied to a particular host environment (such as the browser)
	- *The Application*
		- applies the inputs that originate at the periphery to the domain
		- is not the actual app, despite the name
- *The Periphery*
	- hooks up the (environment-independent) core with a specific environment
	- applies internal changes to the environment (e.g., by updating the DOM), and converts external events (e.g., user events) to inputs that are sent to the core
- *The Environment*
	- consists of the technologies that the periphery is hooked up with (e.g., the browser environment)
	- is visible only to the periphery, not to the core

> - Pen isolates domain logic and application framework from what I call „peripheral devices“ or „peripherals“. Peripherals include the view layer (i.e., the UI), but also database access, and the app history (a device that keeps track of past application states, and enables undo/redo functionality). 
> - Peripherals are not allowed to directly talk to the domain. They interact solely with the app framework wrapped around the domain logic.  
> - Just as real life peripherals do, our peripherals play a double role: they are input and output devices. A user may use the mouse to provide an input. A screen displays the output of a program. If the screen happens to be a touch-screen, we can think of it as both an input and an output device. 
> - The two roles naturally translate to a more technical perspective:
> 	- *Peripherals observe the application core:* The application core maintains a list of periphal devices that are attached to it and should be notified of changes. Every state transition is taken to correspond to a „tick of the clock“, and will result in observers being notified. This may result, e.g., in a visual update of the app viewport, or a network request being sent. 
> 	- *Peripherals initiate state transitions:* Events occuring at the periphery trigger inputs that are sent to the core. The finite state machine that sits at the core processes the input, mutates the scenegraph, and notifies the observers.
> - The picture below illustrates the cyclic nature of this process. 
{: .notes}

### Finite state machines

As another measure to cope with the potential for complexity explosion alluded to above, Pen imposes further structure on the application using *finite state machines* (FSMs). The basic flow is as follows:

- The finite state machine is always in a particular internal *state*, characterized by a label, which is simply a string.
- The machine accepts *inputs* that may change its internal state. Inputs are plain JS objects.
- An input that is acceptable in a given state results in a state *transition*, i.e., the internal state of the FSM changes to a new label. 
- As the machine transitions to a new state, an *update* is issued that mutates the scenegraph.

The update is simply a callback attached to the transition. It should be pointed out that the only way of changing the scenegraph is through an update, that is, a callback triggered by a state transition. The machine thus acts as a strict gatekeeper for our application. Since core and periphery are effectively decoupled (see above), the only way for a peripheral device to initiate a change in the application core is to send an input that results in a transition, which triggers an update as its associated callback function.

> - The callback is the *output* of the machine.
> - The machine *controls* the application flow.
> - Our machine is a *Mealy machine*, a particular type of *finite state transducer*.
> - [The Rise of the State Machines][11]
> - [How I Learned to Stop Worrying and Love the State Machine][12]
{: .notes }

	{
	  from: { 
	    mode: 'select', 
	    label: 'idle' 
	  },
	  input: {
	    type: 'mousedown',  
	    target: [types.CURVE, types.SHAPE, types.GROUP, types.CANVAS]
	  },
	  output: 'select',
	  to: { 
	    mode: 'select', 
	    label: 'shifting'
	  },
	}

### Mutable State

As in Redux, data flow in Pen is *unidirectional*, and respects the *single source of truth* principle. Unlike Redux, however, Pen works with *mutable state*. 

- Lose the tight bundling of objects and their behaviour typical for the object-oriented style of programming

- The primary reason Redux employs a functional approach is to enable shallow comparisons. 
- However, we can still make use of them in an indirect manner.

Why not use the Redux pattern? 
- Are there disadvantages? 
- Does it flow out of the idea of a finite state machine with callbacks?
- In a sense. 

> Immutability in the context of a Web app enables sophisticated change detection techniques to be implemented simply and cheaply, ensuring the computationally expensive process of updating the DOM occurs only when it absolutely has to. [Redux Docs][13]

## Optimization

### The RAIL model

- response (discrete tasks)
- animate (continuous tasks)

> People can only tolerate a lack of visual feedback to their actions for a limited time. For continuous actions like gestures and scroll, this limit is low. (Even skipping a single 16ms frame feels “janky”.) For discrete actions like clicks, there is research saying users perceive any \< 100ms delays as equally fast. If an action takes longer, we need to show a visual indicator. But there are some counter-intuitive challenges. Indicators that cause the page layout to “jump” or that go through several loading “stages” can make the action feel longer than it was. Similarly, handling an interaction within 20ms at the cost of dropping an animation frame can feel slower than handling it within 30ms and no dropped frames. Brains aren’t benchmarks. How do we keep our apps responsive to different kinds of inputs? [Dan Abramov]()
{: .quote}

### Synchronize tasks with the rendering engine

- `requestAnimationFrame`

### Optimize the app cycle

- Use structural sharing
	- Swap components only when their props are changed
- Postpone workloads
	- If you are aiming for a frame budget of around 16ms, every little bit helps.
- Minimize painting
	- split SVG paths into Bezier curves

## Material
{: .no-toc}

- [Dan Abramov: React as a UI Runtime][15]
- [Dan Abramov: The Elements of UI Engineering][16]
- [Reginald Braithwaite: How I learned to stop worrying and love the state machine][17]
- [SVG For Developers: Why You Should Be Using Them If You’re Not Ready][18]
- [The SVG path syntax: an illustrated guide][19]
- [A practical guide to SVG and Design Tools][20]
- [The Past, Present and Future of Sketch (Pieter Omvlee)][21]
- [An Interview with Pieter Omvlee, the Founder of Bohemian Coding][22]
- [An Ode to the Bezier curve][23]
- [Understanding and Implementing Scene Graphs][24]
- [Open Scene Graph: The Basics][25]
- [Jake Giltsoff: SVG on the web][26]
- [Avi Bar-Zeev: Scenegraphs: Past, Present and Future][27]

[1]:	https://css-tricks.com/svg-path-syntax-illustrated-guide/
[2]:	https://classic.framer.com
[3]:	http://patrickbrosset.com/articles/2017-02-01-where-is-devtools-headed.html
[4]:	https://layervault.tumblr.com/post/100588054474/an-interview-with-pieter-omvlee-the-founder-of
[5]:	https://www.sketch.com
[6]:	http://paperjs.org
[7]:	https://pomax.github.io/bezierjs/
[8]:	http://glmatrix.net/docs/module-mat2d.html
[10]:	https://www.youtube.com/watch?time_continue=345&v=DngAZyWMGR0
[11]:	https://www.smashingmagazine.com/2018/01/rise-state-machines/
[12]:	http://raganwald.com/2018/02/23/forde.html
[13]:	https://redux.js.org/faq/immutable-data#what-are-the-benefits-of-immutability
[15]:	https://overreacted.io/react-as-a-ui-runtime/
[16]:	https://overreacted.io/the-elements-of-ui-engineering/
[17]:	https://raganwald.com/2018/02/23/forde.html
[18]:	https://deliciousbrains.com/svg-advantages-developers/
[19]:	https://css-tricks.com/svg-path-syntax-illustrated-guide/
[20]:	https://www.smashingmagazine.com/2019/05/svg-design-tools-practical-guide/
[21]:	https://medium.com/habit-of-introspection/the-past-present-and-future-of-sketch-d5237879b7af
[22]:	https://layervault.tumblr.com/post/100588054474/an-interview-with-pieter-omvlee-the-founder-of
[23]:	https://blog.prototypr.io/an-ode-to-the-bezier-curve-3eb9eca038ff
[24]:	http://archive.gamedev.net/archive/reference/programming/features/scenegraph/index.html
[25]:	https://stackedboxes.org/2010/05/05/osg-part-1-the-basics/
[26]:	https://svgontheweb.com
[27]:	https://web.archive.org/web/20190207215718/http://www.realityprime.com/blog/2007/06/scenegraphs-past-present-and-future/

[image-1]:	/assets/images/pen/out.gif
[image-2]:	/assets/images/pen/framer.png