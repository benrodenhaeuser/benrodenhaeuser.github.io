---
title: Pen
case-study: true
description: A vector design tool that live-syncs a drawing canvas with an SVG markup editor.
long-description: Pen is a vector design tool that live-syncs a drawing canvas with an SVG markup editor. I built it from scratch in JavaScript, developing a custom application framework based on finite state machines and the „hexagonal architecture“ pattern, with a simple Sinatra/MongoDB backend for storage.
header-image: /assets/images/pen/warnock.png
image-caption: John Warnock drawing a cubic Bezier curve.
external-links:
  github: https://github.com/benrodenhaeuser/pen 
  demo: https://pen.benrodenhaeuser.io
---

> * TOC
> {:toc}
{: .toc}

## Introduction

Pen is a vector design application that combines the drawing canvas for visual editing typical for tools of this kind with a markup editor that represents the vector art as SVG markup. 

The main challenges I faced in developing Pen were …

Nowadays, many websites and web applications use SVG, due to its pretty unique blend of attractive features:

„We want everything to look nice and sharp for anyone who uses any of the websites we work on, but we need to keep file sizes down for performance. There is pretty much only one way to go with icons, logos and illustrations on the web — SVG. Scalable Vector Graphics can look crisp at all screen resolutions, can have super small file sizes, and can be easily edited and modified.“ ([Source][1])

> Pen is not production-ready software. A fully functional demo version is available [here][2].
{: .aside }

## 01. Motivation

### Use Cases
When I started developing Pen, I had two use cases in mind:

- *Aid the Learning Process.* Designers that want to make the most out of SVG need to acquire a working knowledge of its markup language. While using markup as a tool for creating vector images from scratch is tedious, to say the least, having a good grasp of the way SVG works is indispensable if you want to do put it on the web as is, or even animate it. This can be a challenge, as parts of SVG markup may appear [„pretty indecipherable … a ton of numbers and letters smashed together into a long string.“][3] Pen aims to be a learning aid in this context.
- *Enhance SVG Workflows.* SVGs are typically created in a graphics editor, and prepared for use on the web in a code editor. This can create a gap between the designer’s task of creating visuals, and the developer’s task of site integration (even if designer and developer happen to be the same person). Pen aims to help bridge that gap.

So Pen aims to be both a learning tool, and help with workflows for putting SVG on the web. 

### The Idea
As mentioned above, people work with SVG from two angles, using design tools (like Sketch or Illustrator), and developer tools (like a code editor, or a build tool). In a design tool, the SVG language takes the back-seat and is hidden from the user’s view. A code editor, on the other hand, typically offers no dedicated tools for working with graphics-oriented markup. To inspect the result of styles being applied to an SVG, e.g., we need yet another tool, typically, a web browser. For this reason, I felt that a tool was needed that speaks both languages, graphics and markup. 

The idea, then, is to treat markup as a first-class citizen, on a par with graphical output. Pen allows users to directly manipulate their artwork using markup, and conversely, makes the markup representation of drawing actions immediately visible. Here is how this looks in action:

![][image-1]
Pen interface featuring drawing canvas and markup editor.
{: .image .border}

As the screen capture shows, the distinguishing feature of Pen is that the shapes on the drawing canvas and the elements in the markup editor *live-sync*. The user may thus, e.g., edit the stroke or fill of a shape in markup, and have the change immediately reflected on the drawing canvas.

### Inspirations
A major inspiration for the approach taken by Pen was Framer, a design tool that in its [„Classic“][4] incarnation, made some waves in the design community a couple of years ago, boasting a side-by-side representation of JavaScript code (CoffeeScript, to be precise) and an interactive prototype generated by that code:  

![][image-2]
Framer Classic interface with layer pane (to the left), code pane (in the middle), and prototype pane.
{: .image}

Another inspiration were the developer tools offered by modern browsers, that have come a long way since „View Source“. Modern DevTools offer a myriad ways of interacting with your website or web application. One possible – and, in my opinion, desirable – future path for them would be to grow into [web-based, standalone products][5] that target the needs of those who need to see the code generating the product alongside with the product itself, on an on-going basis, be it designers or developers. On a more modest scale, Pen aims for something similar. 

- The solution Pen offers by these use cases is to treat drawing and markup editing as two sides of the same coin. 
- To this end, the live-sync between drawing canvas and markup editor provided by Pen is helpful, as it makes …
- Pen aims to facilitate this process by allowing direct manipulation of the markup underlying the artwork with immediate visual feedback. This allows to create artwork that can be more easily made production-ready …

## 02. Challenges

> „[What I probably find the most challenging about making a design tool is that everything has to do with everything else.][6]“
{: .aside }

The above quote from Pieter Omvlee, the creator of Sketch, captures my experience developing Pen well: writing an application like Pen is first and foremost an organizational challenge. 

Challenges: 
- Have many „data formats“ representing roughly the same thing:
	- markup editor
	- drawing canvas
	- database storage
	- *keep all this stuff in sync!*
- Challenges of making a vector editor in the first place
- Develop a sensible data model that allows us to represent nested shapes of Bezier splines and (possibly nested) transformations applied to them. 
- Manage complexity  STATE MANAGEMENT
- Organize data flow to support live-sync
- Optimize code so as to support short response times.

This is also due to the fact that I decided early on to develop Pen from scratch, rather than relying on a framework such as React or Vue. 

After doing a ton of research, and developing a number of small prototypes, I had developed a number of ideas for how I wanted to tackle the complexity explosion alluded to above. 

## 03. Domain Logic

Drawing and manipulating vector shapes on a canvas …

### Scenegraphs

### Bezier Curves

### Matrix Transformations

## 04. Application Framework

- Hexagonal Architecture 
	- Core: domain logic with application code wrapped around
	- Peripherals (the name I chose for what is „outside the core“): attached to the core
- Uncoupling/isolating concerns 
- Pub Sub Pattern
- Finite State Machine 
- Transitions and Updates 

### Core and Periphery

- Pen isolates domain logic and application framework from what I call „peripheral devices“ or „peripherals“. Peripherals include the view layer (i.e., the UI), but also database access, and the app history (a device that keeps track of past application states, and enables undo/redo functionality). 
- Peripherals are not allowed to directly talk to the domain. They interact solely with the app framework wrapped around the domain logic.  

### Peripherals as Input and Output Devices

Just as real life peripherals do, our peripherals play a double role: they are input and output devices. A user may use the mouse to provide an input. A screen displays the output of a program. If the screen happens to be a touch-screen, we can think of it as both an input and an output device. 

The two roles naturally translate to a more technical perspective:

- *Peripherals observe the application core:* The application core maintains a list of periphal devices that are attached to it and should be notified of changes. Every state transition is taken to correspond to a „tick of the clock“, and will result in observers being notified. This may result, e.g., in a visual update of the app viewport, or a network request being sent. 
- *Peripherals listen to events and initiate state transitions:* Events occuring at the periphery trigger inputs that are sent to the core. The finite state machine that sits at the core processes the input, mutates the scenegraph, and notifies the observers.

The picture below illustrates the cyclic nature of this process. 

### Finite State Machines

To cope with the potential for complexity explosion alluded to above, Pen imposes structure on the application using *finite state machines* (FSMs). The basic flow is as follows:

- The finite state machine is always in a particular internal *state*, characterized by a label, which is simply a string.
- The machine accepts *inputs* that may change its internal state. Inputs are plain JS objects.
- An input that is acceptable in a given state results in a state *transition*, i.e., the internal state of the FSM changes to a new label. 
- As the machine transitions to a new state, an *update* is issued that mutates the scenegraph.

The update is simply a callback attached to the transition. It should be pointed out that the only way of changing the scenegraph is through an update, that is, a callback triggered by a state transition. The machine thus acts as a strict gatekeeper for our application. Since core and periphery are effectively decoupled (see above), the only way for a peripheral device to initiate a change in the application core is to send an input that results in a transition, which triggers an update as its associated callback function.

### Mutable State

As in Redux, data flow in Pen is *unidirectional*, and respects the *single source of truth* principle. Unlike Redux, however, Pen works with *mutable state*. 

- The primary reason Redux employs a functional approach is to enable shallow comparisons. 
- However, we can still make use of them in an indirect manner.

Why not use the Redux pattern? 
- Are there disadvantages? 
- Does it flow out of the idea of a finite state machine with callbacks?
- In a sense. 


## 05. Optimization





[1]:	https://svgontheweb.com
[2]:	https://pen.benrodenhaeuser.io
[3]:	https://css-tricks.com/svg-path-syntax-illustrated-guide/
[4]:	https://classic.framer.com
[5]:	http://patrickbrosset.com/articles/2017-02-01-where-is-devtools-headed.html
[6]:	https://layervault.tumblr.com/post/100588054474/an-interview-with-pieter-omvlee-the-founder-of

[image-1]:	/assets/images/pen/out.gif
[image-2]:	/assets/images/pen/framer.png