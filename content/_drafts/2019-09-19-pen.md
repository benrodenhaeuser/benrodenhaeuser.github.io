---
title: Pen
type: major
description: A vector design tool that live-syncs a drawing canvas with an SVG markup editor.
abstract: Pen is a vector design tool that live-syncs a drawing canvas with an SVG markup editor. I built it from scratch in JavaScript, developing a custom application framework based on finite state machines and the „hexagonal architecture“ pattern, with a simple Sinatra/MongoDB backend for storage.
header-image: /assets/images/pen/warnock.png
image-caption: John Warnock drawing a cubic Bezier curve.
external-links:
  github: https://github.com/benrodenhaeuser/pen 
  demo: https://pen.benrodenhaeuser.io
---

## Introduction
{: .no_toc }

Pen is a vector design application that combines the drawing canvas for visual editing typical for tools of this kind with a markup editor that represents the vector art as SVG markup. 

> The major challenges I faced were …
{: .notes}

Nowadays, many websites and web applications use SVG, due to its pretty unique blend of attractive features:

> *We want everything to look nice and sharp for anyone who uses any of the websites we work on, but we need to keep file sizes down for performance. There is pretty much only one way to go with icons, logos and illustrations on the web — SVG. Scalable Vector Graphics can look crisp at all screen resolutions, can have super small file sizes, and can be easily edited and modified.*[Jake Giltsoff][1]
{: .quote}

## Motivation

### Use Cases
When I started developing Pen, I had two primary use cases in mind:

- *Aid the Learning Process.* Designers that want to make the most out of SVG need to acquire a working knowledge of its markup language. While using markup as a tool for creating vector images from scratch is tedious, to say the least, having a good grasp of the way SVG works is indispensable if you want to do put it on the web as is, or even animate it. This can be a challenge, as parts of SVG markup may appear [„pretty indecipherable … a ton of numbers and letters smashed together into a long string.“][2] Pen aims to be a learning aid in this context.
- *Enhance SVG Workflows.* SVGs are typically created in a graphics editor, and prepared for use on the web in a code editor. This can create a gap between the designer’s task of creating visuals, and the developer’s task of site integration (even if designer and developer happen to be the same person). Pen aims to help bridge that gap.

So Pen aims to be both a learning tool, and help with workflows for putting SVG on the web. 

### Main Idea
As mentioned above, people work with SVG from two angles, using design tools (like Sketch or Illustrator), and developer tools (like a code editor, or a build tool). In a design tool, the SVG language takes the back-seat and is hidden from the user’s view. A code editor, on the other hand, typically offers no dedicated tools for working with graphics-oriented markup. To inspect the result of styles being applied to an SVG, e.g., we need yet another tool, typically, a web browser. For this reason, I felt that a tool was needed that speaks both languages, graphics and markup. 

The idea, then, is to treat markup as a first-class citizen, on a par with graphical output. Pen allows users to directly manipulate their artwork using markup, and conversely, makes the markup representation of drawing actions immediately visible. Here is how this looks in action:

![][image-1]
Pen interface featuring drawing canvas and markup editor.
{: .image .border}

As the screen capture shows, the distinguishing feature of Pen is that the shapes on the drawing canvas and the elements in the markup editor *live-sync*. The user may thus, e.g., edit the stroke or fill of a shape in markup, and have the change immediately reflected on the drawing canvas.

### Inspirations
A major inspiration for the approach taken by Pen was Framer, a design tool that in its [„Classic“][3] incarnation, made some waves in the design community a couple of years ago, boasting a side-by-side representation of JavaScript code (CoffeeScript, to be precise) and an interactive prototype generated by that code:  

![][image-2]
Framer Classic interface with layer pane (to the left), code pane (in the middle), and prototype pane.
{: .image}

Another inspiration were the developer tools offered by modern browsers, that have come a long way since „View Source“. Modern DevTools offer a myriad ways of interacting with your website or web application. One possible – and, in my opinion, desirable – future path for them would be to grow into [web-based, standalone products][4] that target the needs of those who need to see the code generating the product alongside with the product itself, on an on-going basis, be it designers or developers. On a more modest scale, Pen aims for something similar. 

> - The solution Pen offers by these use cases is to treat drawing and markup editing as two sides of the same coin. 
> - To this end, the live-sync between drawing canvas and markup editor provided by Pen is helpful, as it makes …
> - Pen aims to facilitate this process by allowing direct manipulation of the markup underlying the artwork with immediate visual feedback. This allows to create artwork that can be more easily made production-ready …
{: .notes }

## Feature Set

> *There’s a truly enormous depth of features that people expect in a design tool. Until you get down to that level, nobody will even consider using your app.* [Pieter Omvlee][5]
{: .quote }

With the help of some initial research and prototyping, it quickly became clear to me that developing a production-ready application was wildly out of scope for the phase of this project documented here. This is nicely summarized by the above quote by Pieter Omvlee, the creator of [Sketch][6].

The first order of business, then, was to settle on an ambitious, yet manageable feature set for an initial, proof-of-concept type release.  From a high-level perspective, here is what I decided Pen should be able to do out of the gate.

### Drawing tools
From a user perspective, a design tool like Pen at the very least should provide:
- *drawing mode* (create and edit shapes on the canvas)
- *select mode* (select and transform shapes)
- *group/ungroup* (hierarchically organize shapes)

### Markup editing
As per what was said above, we also need to offer: 
- a *markup editor* with at least minimal amenities
- *two-way live-sync* between drawing canvas and markup editor

### Document management
In addition, we need some document management features. 
- *CRUD:* commit documents to storage, retrieve, update and delete them
- *auto-save:* persist changes to storage without user intervention
- *undo:* revert to previous states of the current editing session

These features lie at the intersection of what I felt was feasible and what I deemed desirable for a product that I would feel comfortable sharing with the world. A mature application will, of course, have to support both a broader feature set, and additional depth to the features mentioned.

## Key Decisions 

> In software architecture, you are concerned about the decisions that are hard to change. [Martin Fowler][7]
{: .quote}

### Hexagonal architecture

The core feature of hexagonal architecture is …

- *The Core*
	- *The Domain*
		- contains all the business logic		
		- is not tied to a particular host environment (such as the browser)
	- *The Application*
		- applies the inputs that originate at the periphery to the domain
		- is not the actual app, despite the name
- *The Periphery*
	- hooks up the (environment-independent) core with a specific environment
	- applies internal changes to the environment (e.g., by updating the DOM), and converts external events (e.g., user events) to inputs that are sent to the core
- *The Environment*
	- consists of the technologies that the periphery is hooked up with (e.g., the browser environment)
	- is visible only to the periphery, not to the core

### Finite state machines

### Mutable state


Given the above feature list, the main challenges of developing Pen come into clearer view: 
- Maintain the application state in some sort of useful data structure
- Accept a variety of inputs that change the internal state, both via mouse input on the canvas, and via keyboard input in the markup editor
- Generate, and display a markup representation of the current scenegraph

The above quote from Pieter Omvlee, the creator of Sketch, captures my experience developing Pen well: writing an application like Pen is first and foremost an organizational challenge. 

- Complex application state 
- Variety of data representations: 
	- persistence layer
	- history
	- view
	- markup representation
	- canvas representation

Challenges: 
- Complexity explosion
- Have many „data formats“ representing roughly the same thing:
	- markup editor
	- drawing canvas
	- database storage
	- *keep all this stuff in sync!*
- Challenges of making a vector editor in the first place
- Develop a sensible data model that allows us to represent nested shapes of Bezier splines and (possibly nested) transformations applied to them. 
- Manage complexity  — state management
- Organize data flow to support live-sync
- Optimize code so as to support short response times.

This is also due to the fact that I decided early on to develop Pen from scratch, rather than relying on a framework such as React or Vue. 

After doing a ton of research, and developing a number of small prototypes, I had developed a number of ideas for how I wanted to tackle the complexity explosion alluded to above. 

> - Should we talk about the choices we faced? Which libraries to use, which development style to pursue 
> - jQuery style/React style: the jQuery style just won’t cut it. I was afraid of being boxed in by a framework. I wanted to explore the organizational challenges that come with a project like Pen to depth.
> - jQuery has an „imperative style“, React aims at a more „declarative“, pure/functional style
> - Paper.js, Codemirror
> - Making an in-browser code editor is hard, and has little to do with our application’s core domain
> - Making an in-browser graphics editor is also kind of hard (as I found out), but more manageable, and more deeply tied to our application’s core domain
{: .notes}

*Rules of thumb:*
- Modularize the application as much as possible. 
- Keep DOM manipulation separate from core domain/application logic.

## Domain Logic

> What is the main purpose of this section?
> Why did I not just use the browser DOM? 
{: .notes}

> *What I probably find the most challenging about making a design tool is that everything has to do with everything else.* [Pieter Omvlee][8]
{: .quote }

### Scene graphs

Good example would go a long way.

- The most fundamental data structure used in vector-based graphics applications is the scene graph. 
- The fundamental intuition that makes scene graphs so useful is probably this: „The world consists of things made from parts.“
- A scene graph is a tree or tree-like data structure whose purpose is to structure information about the world into hierarchical relations.
- The SVG format itself should be seen as a scene graph representation language for 2D drawings. 
- For our purposes: shapes and groups.
- More generally, in 3D graphics and game programming, scene graphs will typically contain additional objects, such as cameras, light sources, and information about actions. 
- This article gives good intuitions why scene graphs are so useful, drawn from the context of game programming. 

### Bezier Curves

- The leaf nodes in a scene graph typically consist of Bezier paths (or some other kind of paths).

### Matrix Transformations

- Scene graph objects may be altered by means of various transformations such as rotation, scaling, and movement. 
- Such transformations can be applied to individual shapes as well as to group nodes

> Decision: Use an internal scene graph, and convert it into an SVG DOM as needed. Why?
> Our scene graph depicts not simply an SVG, but an editor! That is an important distinction.
{: .notes}

## Application Framework

> - Hexagonal Architecture 
> 	- Core: domain and application logic
> 	- Peripherals: user interface, data persistence, history
> - Uncoupling, modularization, isolation
> - Pub Sub Pattern (core as publisher, peripherals as subscribers)
> - Finite State Machine
> - Transitions and Updates 
{: .notes}

### Core and Periphery

- Pen isolates domain logic and application framework from what I call „peripheral devices“ or „peripherals“. Peripherals include the view layer (i.e., the UI), but also database access, and the app history (a device that keeps track of past application states, and enables undo/redo functionality). 
- Peripherals are not allowed to directly talk to the domain. They interact solely with the app framework wrapped around the domain logic.  

### Peripherals

Just as real life peripherals do, our peripherals play a double role: they are input and output devices. A user may use the mouse to provide an input. A screen displays the output of a program. If the screen happens to be a touch-screen, we can think of it as both an input and an output device. 

The two roles naturally translate to a more technical perspective:

- *Peripherals observe the application core:* The application core maintains a list of periphal devices that are attached to it and should be notified of changes. Every state transition is taken to correspond to a „tick of the clock“, and will result in observers being notified. This may result, e.g., in a visual update of the app viewport, or a network request being sent. 
- *Peripherals initiate state transitions:* Events occuring at the periphery trigger inputs that are sent to the core. The finite state machine that sits at the core processes the input, mutates the scenegraph, and notifies the observers.

The picture below illustrates the cyclic nature of this process. 

### Finite State Machines

As another measure to cope with the potential for complexity explosion alluded to above, Pen imposes further structure on the application using *finite state machines* (FSMs). The basic flow is as follows:

- The finite state machine is always in a particular internal *state*, characterized by a label, which is simply a string.
- The machine accepts *inputs* that may change its internal state. Inputs are plain JS objects.
- An input that is acceptable in a given state results in a state *transition*, i.e., the internal state of the FSM changes to a new label. 
- As the machine transitions to a new state, an *update* is issued that mutates the scenegraph.

The update is simply a callback attached to the transition. It should be pointed out that the only way of changing the scenegraph is through an update, that is, a callback triggered by a state transition. The machine thus acts as a strict gatekeeper for our application. Since core and periphery are effectively decoupled (see above), the only way for a peripheral device to initiate a change in the application core is to send an input that results in a transition, which triggers an update as its associated callback function.

> - The callback is the *output* of the machine.
> - The machine *controls* the application flow.
> - Our machine is a *Mealy machine*, a particular type of *finite state transducer*.
> - [The Rise of the State Machines][9]
> - [How I Learned to Stop Worrying and Love the State Machine][10]
{: .notes }

	{
	  from: { 
	    mode: 'select', 
	    label: 'idle' 
	  },
	  input: {
	    type: 'mousedown',  
	    target: [types.CURVE, types.SHAPE, types.GROUP, types.CANVAS]
	  },
	  output: 'select',
	  to: { 
	    mode: 'select', 
	    label: 'shifting'
	  },
	}


### Mutable State

As in Redux, data flow in Pen is *unidirectional*, and respects the *single source of truth* principle. Unlike Redux, however, Pen works with *mutable state*. 

- The primary reason Redux employs a functional approach is to enable shallow comparisons. 
- However, we can still make use of them in an indirect manner.

Why not use the Redux pattern? 
- Are there disadvantages? 
- Does it flow out of the idea of a finite state machine with callbacks?
- In a sense. 

## Optimization

### requestAnimationFrame

### Structural sharing

### Defer tasks

### Avoid painting

## Material
{: .no_toc}

- [Dan Abramov: React as a UI Runtime][11]{:target="_blank"}
- [Dan Abramov: The Elements of UI Engineering][12]{:target="_blank"}
- [Reginald Braithwaite: How I learned to stop worrying and love the state machine][13]{:target="_blank"}
- [SVG For Developers: Why You Should Be Using Them If You’re Not Ready][14]{:target="_blank"}
- [The SVG path syntax: an illustrated guide][15]{:target="_blank"}
- [A practical guide to SVG and Design Tools][16]{:target="_blank"}
- [The Past, Present and Future of Sketch (Pieter Omvlee)][17]{:target="_blank"}
- [An Interview with Pieter Omvlee, the Founder of Bohemian Coding][18]{:target="_blank"}
- [An Ode to the Bezier curve][19]{:target="_blank"}
- [Understanding and Implementing Scene Graphs][20]{:target="_blank"}

[1]:	https://svgontheweb.com
[2]:	https://css-tricks.com/svg-path-syntax-illustrated-guide/
[3]:	https://classic.framer.com
[4]:	http://patrickbrosset.com/articles/2017-02-01-where-is-devtools-headed.html
[5]:	https://layervault.tumblr.com/post/100588054474/an-interview-with-pieter-omvlee-the-founder-of
[6]:	https://www.sketch.com
[7]:	https://www.youtube.com/watch?time_continue=345&v=DngAZyWMGR0
[8]:	https://layervault.tumblr.com/post/100588054474/an-interview-with-pieter-omvlee-the-founder-of
[9]:	https://www.smashingmagazine.com/2018/01/rise-state-machines/
[10]:	http://raganwald.com/2018/02/23/forde.html
[11]:	https://overreacted.io/react-as-a-ui-runtime/
[12]:	https://overreacted.io/the-elements-of-ui-engineering/
[13]:	https://raganwald.com/2018/02/23/forde.html
[14]:	https://deliciousbrains.com/svg-advantages-developers/
[15]:	https://css-tricks.com/svg-path-syntax-illustrated-guide/
[16]:	https://www.smashingmagazine.com/2019/05/svg-design-tools-practical-guide/
[17]:	https://medium.com/habit-of-introspection/the-past-present-and-future-of-sketch-d5237879b7af
[18]:	https://layervault.tumblr.com/post/100588054474/an-interview-with-pieter-omvlee-the-founder-of
[19]:	https://blog.prototypr.io/an-ode-to-the-bezier-curve-3eb9eca038ff
[20]:	http://archive.gamedev.net/archive/reference/programming/features/scenegraph/index.html

[image-1]:	/assets/images/pen/out.gif
[image-2]:	/assets/images/pen/framer.png