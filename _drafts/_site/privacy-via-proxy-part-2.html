<h2 id="stack-factory">Stack factory</h2>

<p>When faced with the task of implementing a stack, the obvious choice that comes to mind first would be to reach for a factory function:</p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">stack</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">data</span> <span class="o">=</span> <span class="p">[];</span>

  <span class="k">return</span> <span class="p">{</span>
    <span class="na">push</span><span class="p">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">data</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
    <span class="p">},</span>

    <span class="na">pop</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">data</span><span class="p">.</span><span class="nx">pop</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">};</span>
<span class="p">}</span>
</code></pre>
</div>

<p>The function above allows us to create a series of stacks, each with its own private data, hidden in a closure that both the <code class="highlighter-rouge">push</code> and the <code class="highlighter-rouge">pop</code> function have access to. So our second requirement, pertaining to data hiding, is satisfied. This is as far as it goes, however:</p>

<ul>
  <li>The prototype of objects returned by <code class="highlighter-rouge">stack</code> invocations is <code class="highlighter-rouge">Object.prototype</code> rather than a meaningful <code class="highlighter-rouge">Stack</code> type. This violates our requirement 1.</li>
  <li>Each stack has <em>own</em> methods <code class="highlighter-rouge">push</code> and <code class="highlighter-rouge">pop</code>. This violates requirement 3.</li>
  <li>Dynamically attaching methods to stacks that reference the stack-internal data is not possible. This violates requirement 4.</li>
</ul>

<p>As for the last point, the main problem is that we need to be able to access the length of the array that internally stores our stack data to get our <code class="highlighter-rouge">size</code> method off the ground. However, that array is private, hidden in the closure of our stack methods. This is going to be a problem in situations where we need on the fly extensions of objects that make use of private data.</p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="nx">stack</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">length</span><span class="p">();</span> <span class="c1">// throws an error, since `data` is not defined</span>
</code></pre>
</div>

<h2 id="immediately-invoked-function-expressions">Immediately invoked function expressions</h2>

<p>To try and improve on the situation, letâ€™s reach for IIFEs (immediately invoked function expressions):</p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="c1">// IIFE solution with indices.</span>
</code></pre>
</div>

<p>This solution ticks off a lot more boxes than the previous one.</p>

<h2 id="method-overriding-and-delegation">Method overriding and delegation</h2>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="c1">// My first solution.</span>
</code></pre>
</div>
