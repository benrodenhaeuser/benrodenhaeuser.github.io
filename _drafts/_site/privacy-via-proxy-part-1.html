<p>JavaScript does not provide a means to tag an object property as “private”. There is support for data hiding though: using closures. Still, providing instances of a given prototype with their own private data presents some challenges if additional requirements come into play. This post suggests a pattern for data hiding that takes advantage of the Proxy object introduced in ES6.</p>

<h2 id="lets-make-a-stack">Let’s Make a Stack</h2>

<p>Our starting point is a modest example: let’s make a stack. My plan is to illustrate the challenges that arise with respect to data hiding in JavaScript using the example. We will then work our way towards an eventual solution, what I call the “Privacy via Proxy” pattern.</p>

<p>Here are our requirements:</p>

<blockquote class="aside">
  <p>Implement a stack with <code class="highlighter-rouge">push</code>/<code class="highlighter-rouge">pop</code> API satisfying the following:</p>

  <ol>
    <li>Stack instances share a common, meaningful type <code class="highlighter-rouge">Stack</code>.</li>
    <li>Stack instance data is private, i.e., accessible <em>only</em> through the <code class="highlighter-rouge">Stack</code> API.</li>
    <li>The API is implemented on the level of the type, not the instance.</li>
    <li>The API is dynamically extensible: new methods can be added to the <code class="highlighter-rouge">Stack</code> type after its creation. Such methods are capable of working with the private data hidden in instances.</li>
  </ol>
</blockquote>

<p>To provide some context for these requirements, let’s switch languages for a moment.</p>

<h2 id="a-ruby-solution">A Ruby solution</h2>

<p>Consider the following Ruby implementation of a stack:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Stack</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">()</span>
    <span class="vi">@data</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="vi">@data</span> <span class="o">&lt;&lt;</span> <span class="n">value</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">pop</span>
    <span class="vi">@data</span><span class="p">.</span><span class="nf">pop</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Instances of the class <code class="highlighter-rouge">Stack</code> obviously (and somewhat tautologically) belong to the <code class="highlighter-rouge">Stack</code> class. So they have a meaningful common “type” (requirement 1). Stack instance data is stored in an instance variable <code class="highlighter-rouge">@data</code> which is part of the private state of a stack, inaccessible from the outside as long as we do not provide accessors (requirement 2). Further, Stack instances get their behaviour from the class they belong to, rather than implementing the Stack API themselves. Their behaviour is thus fully determined by their class, and by the private data they store (requirement 3). The <code class="highlighter-rouge">Stack</code> class is also extensible in the sense that we can reopen it after the fact, and add further methods that automatically become available to instances, even to those already created earlier (requirement 4):</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="n">stack</span> <span class="o">=</span> <span class="no">Stack</span><span class="p">.</span><span class="nf">new</span>
<span class="n">stack</span> <span class="o">&lt;&lt;</span> <span class="s1">'a'</span>

<span class="k">class</span> <span class="nc">Stack</span>
  <span class="k">def</span> <span class="nf">size</span>
    <span class="vi">@data</span><span class="p">.</span><span class="nf">size</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">stack</span><span class="p">.</span><span class="nf">size</span> <span class="c1"># 1</span>
</code></pre>
</div>

<p>Notice in particular that the <code class="highlighter-rouge">size</code> method accesses the <code class="highlighter-rouge">@data</code> instance variable. So even though stack data is private, we can still jump inside the class, and make use of the private data, thereby changing the contract between the class and its users.</p>

<p>This also means that private data is private only “up to a point”:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Stack</span>
  <span class="kp">attr_reader</span> <span class="ss">:data</span>
<span class="k">end</span>

<span class="n">stack</span> <span class="o">=</span> <span class="no">Stack</span><span class="p">.</span><span class="nf">new</span>
<span class="n">stack</span> <span class="o">&lt;&lt;</span> <span class="s1">'a'</span> <span class="o">&lt;&lt;</span> <span class="s1">'b'</span>
<span class="n">stack</span><span class="p">.</span><span class="nf">data</span> <span class="c1"># ['a', 'b']</span>
</code></pre>
</div>

<p>Here, the internal data of a stack is exposed by providing a getter method. So private data can always be “made public” if so desired. But notice that this requires changing the API of the class, and thus the contract between a class and its users (in addition, many languages will provide generic ways to bypass access restrictions; Ruby, e.g., provides <code class="highlighter-rouge">instance_variable_get</code> as part of the <code class="highlighter-rouge">Object</code> class).</p>

<h2 id="what-about-javascript">What about JavaScript?</h2>

<p>The upshot of the preceding section is that, in a Ruby context, satisfying our requirements is almost trivial. It’s the default behaviour, the way things work out of the box. In JavaScript, the situations is more complicated. Of course, JavaScript does not have classes, the fact that ES6 provides a <code class="highlighter-rouge">class</code> keyword notwithstanding. JavaScript also does not have anything resembling the concept of an instance variable that would store data “internal” to an object. But that’s not the heart of the problem, because our requirements do make sense in the context of JavaScript. Let’s reformulate them, using more specific JavaScript terminology:</p>

<ol>
  <li>Stack instances should have a common prototype <code class="highlighter-rouge">Stack</code>.</li>
  <li>Stack instance data should be private, i.e., accessible <em>only</em> through the Stack API.</li>
  <li>Stack instances should have no own properties, which is to say that the prototype, rather than the instance, implements the API.</li>
  <li>It should be possible to dynamically add methods to the prototype that become available automatically to all Stack instances. Such additional methods may even frustrate the attempts of the prototype creator to hide data from public access.</li>
</ol>

<p>We will now first consider a number of stack implementations at some length that will <em>fail</em> to satisfy all of these requirements. Combining their strengths will, however, lead us to our final proposal, which will involve making use of <em>Proxy objects</em>, a functionality that was introduced in ES6 for metaprogramming purposes. As it will turn out, Proxies are just what we need to solve our challenge.</p>

<blockquote class="aside">
  <p><a href="privacy-via-proxy-part-2/">Part 2</a> of this series walks through a number of failing attempts to satisfy the requirements laid out in this post. <a href="(privacy-via-proxy-part-3/)">Part 3</a> will suggest a proxy-based pattern for data hiding.</p>
</blockquote>
