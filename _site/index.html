<!doctype html>
<html lang="en-US">
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <title>Ben Rodenhäuser | Notes on programming.</title>

  <link href="https://fonts.googleapis.com/css?family=PT+Sans|Anton|Roboto+Mono" rel="stylesheet">
  <link rel="stylesheet" href="/assets/css/style.css?v=">
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    CommonHTML: { linebreaks: { automatic: true } },
    "HTML-CSS": { linebreaks: { automatic: true } },
           SVG: { linebreaks: { automatic: true } }
  });
  </script>
  <script type="text/javascript"
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML&delayStartupUntilConfig">
  </script>
  <script src="/assets/jax/config.js"></script>

  <meta name="viewport" content="width=device-width">
  <!--[if lt IE 9]>
  <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  
    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-99334571-1', 'auto');
        ga('send', 'pageview');
    </script>
  
</head>

  <body>
    <div class="wrapper">
      <section>
      
      <small>07 March 2018</small>
      <h1 class="title">Understanding Sinatra</h1>
      <div class="description">Building a toy version of a popular Ruby framework from the ground up.</div>

      <div class="content">
        <hr class="line" />
        <div class="content-inner">
          <p>We are going to develop our toy version of Sinatra in a number of iterations, starting “tiny”, and building towards “small”. This corresponds to how I built Frankie, too, even though this blog post makes the process perhaps appear a little more orderly than it really was.</p>

<h2 id="01-hello-frankie">0.1. Hello Frankie</h2>

<p>At its core, Sinatra is (1) a mechanism for storing routes, and (2) a mechanism for handling requests based on the routes stored. So this is where we start.</p>

<p>If you investigate the Sinatra source code, you will see that part (1), route storage, is a class task, while part (2), request handling, happens at the instance level. Let’s first see how to store routes.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Application</span>
  <span class="k">class</span> <span class="o">&lt;&lt;</span> <span class="nb">self</span>
    <span class="k">def</span> <span class="nf">routes</span>
      <span class="vi">@routes</span> <span class="o">||=</span> <span class="p">[]</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
      <span class="n">route</span><span class="p">(</span><span class="s1">'GET'</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">block</span><span class="p">)</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nf">post</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
      <span class="n">route</span><span class="p">(</span><span class="s1">'POST'</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">block</span><span class="p">)</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nf">route</span><span class="p">(</span><span class="n">verb</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">block</span><span class="p">)</span>
      <span class="n">routes</span> <span class="o">&lt;&lt;</span> <span class="p">{</span>
        <span class="ss">verb:  </span><span class="n">verb</span><span class="p">,</span>
        <span class="ss">path:  </span><span class="n">path</span><span class="p">,</span>
        <span class="ss">block: </span><span class="n">block</span>
      <span class="p">}</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>Routes are stored in an array which we can access via the <code class="highlighter-rouge">routes</code> class method. Invoking the <code class="highlighter-rouge">get</code> and <code class="highlighter-rouge">post</code> method defined above leads to a route being stored. As you can see by inspecting the <code class="highlighter-rouge">route</code> method, a route has three components: an HTTP <code class="highlighter-rouge">verb</code>, a URL <code class="highlighter-rouge">path</code>, and a block (a Proc object, to be precise). If the <code class="highlighter-rouge">verb</code> for a given request is <code class="highlighter-rouge">GET</code>, and its <code class="highlighter-rouge">path</code> is <code class="highlighter-rouge">'/'</code>, then you can imagine that the block will determine how to handle that request.</p>

<p>Now, how are requests handled?</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Application</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">call</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
    <span class="kp">new</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
    <span class="vi">@request</span>  <span class="o">=</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Request</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
    <span class="vi">@verb</span>     <span class="o">=</span> <span class="vi">@request</span><span class="p">.</span><span class="nf">request_method</span>
    <span class="vi">@path</span>     <span class="o">=</span> <span class="vi">@request</span><span class="p">.</span><span class="nf">path_info</span>

    <span class="vi">@response</span> <span class="o">=</span> <span class="p">{</span>
      <span class="ss">status:  </span><span class="mi">200</span><span class="p">,</span>
      <span class="ss">headers: </span><span class="n">headers</span><span class="p">,</span>
      <span class="ss">body:    </span><span class="p">[]</span>
    <span class="p">}</span>

    <span class="n">route!</span>

    <span class="vi">@response</span><span class="p">.</span><span class="nf">values</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">params</span>
    <span class="vi">@request</span><span class="p">.</span><span class="nf">params</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">status</span><span class="p">(</span><span class="n">code</span><span class="p">)</span>
    <span class="vi">@response</span><span class="p">[</span><span class="ss">:status</span><span class="p">]</span> <span class="o">=</span> <span class="n">code</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">headers</span>
    <span class="vi">@headers</span> <span class="o">||=</span> <span class="p">{</span> <span class="s1">'Content-Type'</span> <span class="o">=&gt;</span> <span class="s1">'text/html'</span> <span class="p">}</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">body</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
    <span class="vi">@response</span><span class="p">[</span><span class="ss">:body</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">string</span><span class="p">]</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">route!</span>
    <span class="n">match</span> <span class="o">=</span> <span class="no">Application</span><span class="p">.</span><span class="nf">routes</span>
                       <span class="p">.</span><span class="nf">select</span> <span class="p">{</span> <span class="o">|</span><span class="n">route</span><span class="o">|</span> <span class="n">route</span><span class="p">[</span><span class="ss">:verb</span><span class="p">]</span> <span class="o">==</span> <span class="vi">@verb</span> <span class="p">}</span>
                       <span class="p">.</span><span class="nf">find</span>   <span class="p">{</span> <span class="o">|</span><span class="n">route</span><span class="o">|</span> <span class="n">route</span><span class="p">[</span><span class="ss">:path</span><span class="p">]</span> <span class="o">==</span> <span class="vi">@path</span> <span class="p">}</span>
    <span class="k">return</span> <span class="n">status</span><span class="p">(</span><span class="mi">404</span><span class="p">)</span> <span class="k">unless</span> <span class="n">match</span>

    <span class="n">body</span> <span class="n">match</span><span class="p">[</span><span class="ss">:block</span><span class="p">].</span><span class="nf">call</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>
</div>

<h2 id="02-frankie-goes-top-level">0.2. Frankie goes top level</h2>

<p>New module <code class="highlighter-rouge">Frankie::Delegator</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10</pre></td><td class="code"><pre><span class="k">module</span> <span class="nn">Delegator</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">delegate</span><span class="p">(</span><span class="n">method_name</span><span class="p">)</span>
    <span class="n">define_method</span><span class="p">(</span><span class="n">method_name</span><span class="p">)</span> <span class="k">do</span> <span class="o">|*</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="o">|</span>
      <span class="no">Application</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="n">method_name</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="n">delegate</span><span class="p">(</span><span class="ss">:get</span><span class="p">)</span>
  <span class="n">delegate</span><span class="p">(</span><span class="ss">:post</span><span class="p">)</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>We also need (at the top level):</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre><span class="kp">extend</span> <span class="no">Frankie</span><span class="o">::</span><span class="no">Delegator</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>If we just did this, we could actually already run a ‘Hello world’ route. However, more work needs to be done. E.g., we want to be able to use the <code class="highlighter-rouge">params</code> method in our route blocks.</p>

<p>Change the <code class="highlighter-rouge">Application#route!</code> method to use <code class="highlighter-rouge">instance_eval</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">route!</span>
  <span class="n">match</span> <span class="o">=</span> <span class="no">Application</span><span class="p">.</span><span class="nf">routes</span>
                     <span class="p">.</span><span class="nf">select</span> <span class="p">{</span> <span class="o">|</span><span class="n">route</span><span class="o">|</span> <span class="n">route</span><span class="p">[</span><span class="ss">:verb</span><span class="p">]</span> <span class="o">==</span> <span class="vi">@verb</span> <span class="p">}</span>
                     <span class="p">.</span><span class="nf">find</span>   <span class="p">{</span> <span class="o">|</span><span class="n">route</span><span class="o">|</span> <span class="n">route</span><span class="p">[</span><span class="ss">:path</span><span class="p">]</span> <span class="o">==</span> <span class="vi">@path</span> <span class="p">}</span>
  <span class="k">return</span> <span class="n">status</span><span class="p">(</span><span class="mi">404</span><span class="p">)</span> <span class="k">unless</span> <span class="n">match</span>

  <span class="n">body</span> <span class="nb">instance_eval</span><span class="p">(</span><span class="o">&amp;</span><span class="n">match</span><span class="p">[</span><span class="ss">:block</span><span class="p">])</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>And a <code class="highlighter-rouge">Templates</code> module:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13</pre></td><td class="code"><pre><span class="k">module</span> <span class="nn">Templates</span>
  <span class="k">def</span> <span class="nf">path_to_template</span><span class="p">(</span><span class="n">app_root</span><span class="p">,</span> <span class="n">template</span><span class="p">)</span>
    <span class="n">template_dir</span> <span class="o">=</span> <span class="no">File</span><span class="p">.</span><span class="nf">expand_path</span><span class="p">(</span><span class="s1">'../views'</span><span class="p">,</span> <span class="n">app_root</span><span class="p">)</span>
    <span class="s2">"</span><span class="si">#{</span><span class="n">template_dir</span><span class="si">}</span><span class="s2">/</span><span class="si">#{</span><span class="n">template</span><span class="si">}</span><span class="s2">.erb"</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">erb</span><span class="p">(</span><span class="n">template</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="nb">binding</span>
    <span class="n">app_root</span> <span class="o">=</span> <span class="n">caller_locations</span><span class="p">.</span><span class="nf">first</span><span class="p">.</span><span class="nf">absolute_path</span>
    <span class="n">content</span> <span class="o">=</span> <span class="no">File</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="n">path_to_template</span><span class="p">(</span><span class="n">app_root</span><span class="p">,</span> <span class="n">template</span><span class="p">))</span>
    <span class="no">ERB</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">content</span><span class="p">).</span><span class="nf">result</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>
</div>

<h2 id="03-frankie-recognizes-patterns">0.3. Frankie recognizes patterns</h2>

<p>Change the <code class="highlighter-rouge">route</code> class method, and add <code class="highlighter-rouge">compile</code> class method:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Application</span>
  <span class="k">class</span> <span class="o">&lt;&lt;</span> <span class="nb">self</span>
    <span class="k">def</span> <span class="nf">route</span><span class="p">(</span><span class="n">verb</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">block</span><span class="p">)</span>
      <span class="n">pattern</span><span class="p">,</span> <span class="n">keys</span> <span class="o">=</span> <span class="n">compile</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>

      <span class="n">routes</span> <span class="o">&lt;&lt;</span> <span class="p">{</span>
        <span class="ss">verb:     </span><span class="n">verb</span><span class="p">,</span>
        <span class="ss">pattern:  </span><span class="n">pattern</span><span class="p">,</span>
        <span class="ss">keys:     </span><span class="n">keys</span><span class="p">,</span>
        <span class="ss">block:    </span><span class="n">block</span>
      <span class="p">}</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nf">compile</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
      <span class="n">segments</span> <span class="o">=</span> <span class="n">path</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="s1">'/'</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
      <span class="n">keys</span> <span class="o">=</span> <span class="p">[]</span>

      <span class="n">segments</span><span class="p">.</span><span class="nf">map!</span> <span class="k">do</span> <span class="o">|</span><span class="n">segment</span><span class="o">|</span>
        <span class="k">if</span> <span class="n">segment</span><span class="p">.</span><span class="nf">start_with?</span><span class="p">(</span><span class="s1">':'</span><span class="p">)</span>
          <span class="n">keys</span> <span class="o">&lt;&lt;</span> <span class="n">segment</span><span class="p">[</span><span class="mi">1</span><span class="p">.</span><span class="nf">.</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
          <span class="s2">"([^</span><span class="se">\/</span><span class="s2">]+)"</span>
        <span class="k">else</span>
          <span class="n">segment</span>
        <span class="k">end</span>
      <span class="k">end</span>

      <span class="n">pattern</span> <span class="o">=</span> <span class="no">Regexp</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="s2">"</span><span class="se">\\</span><span class="s2">A</span><span class="si">#{</span><span class="n">segments</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="s1">'/'</span><span class="p">)</span><span class="si">}</span><span class="se">\\</span><span class="s2">z"</span><span class="p">)</span>
      <span class="p">[</span><span class="n">pattern</span><span class="p">,</span> <span class="n">keys</span><span class="p">]</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>Change the <code class="highlighter-rouge">route!</code> instance method:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Application</span>
  <span class="k">def</span> <span class="nf">route!</span>
    <span class="n">match</span> <span class="o">=</span> <span class="no">Application</span><span class="p">.</span><span class="nf">routes</span>
                       <span class="p">.</span><span class="nf">select</span> <span class="p">{</span> <span class="o">|</span><span class="n">route</span><span class="o">|</span> <span class="n">route</span><span class="p">[</span><span class="ss">:verb</span><span class="p">]</span> <span class="o">==</span> <span class="vi">@verb</span> <span class="p">}</span>
                       <span class="p">.</span><span class="nf">find</span>   <span class="p">{</span> <span class="o">|</span><span class="n">route</span><span class="o">|</span> <span class="n">route</span><span class="p">[</span><span class="ss">:pattern</span><span class="p">].</span><span class="nf">match</span><span class="p">(</span><span class="vi">@path</span><span class="p">)</span> <span class="p">}</span>
    <span class="k">return</span> <span class="n">status</span><span class="p">(</span><span class="mi">404</span><span class="p">)</span> <span class="k">unless</span> <span class="n">match</span>

    <span class="c1"># CHANGE in 0.3: process captured groups</span>
    <span class="n">values</span> <span class="o">=</span> <span class="n">match</span><span class="p">[</span><span class="ss">:pattern</span><span class="p">].</span><span class="nf">match</span><span class="p">(</span><span class="vi">@path</span><span class="p">).</span><span class="nf">captures</span>
    <span class="n">params</span><span class="p">.</span><span class="nf">merge!</span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="ss">:keys</span><span class="p">].</span><span class="nf">zip</span><span class="p">(</span><span class="n">values</span><span class="p">).</span><span class="nf">to_h</span><span class="p">)</span>
    <span class="n">body</span><span class="p">(</span><span class="nb">instance_eval</span><span class="p">(</span><span class="o">&amp;</span><span class="n">match</span><span class="p">[</span><span class="ss">:block</span><span class="p">]))</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>
</div>

<h2 id="04-frankie-plays-catch">0.4. Frankie plays catch</h2>

<p>The <code class="highlighter-rouge">Application#call</code> method used to invoke the <code class="highlighter-rouge">Application#route!</code> method. It now reads <code class="highlighter-rouge">catch(:halt) { dispatch! }</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Application</span>
  <span class="c1"># CHANGE: changed method in 0.4:</span>
  <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
    <span class="vi">@request</span>  <span class="o">=</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Request</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
    <span class="vi">@verb</span>     <span class="o">=</span> <span class="vi">@request</span><span class="p">.</span><span class="nf">request_method</span>
    <span class="vi">@path</span>     <span class="o">=</span> <span class="vi">@request</span><span class="p">.</span><span class="nf">path_info</span>

    <span class="vi">@response</span> <span class="o">=</span> <span class="p">{</span>
      <span class="ss">status:  </span><span class="mi">200</span><span class="p">,</span>
      <span class="ss">headers: </span><span class="n">headers</span><span class="p">,</span>
      <span class="ss">body:    </span><span class="p">[]</span>
    <span class="p">}</span>

    <span class="c1"># CHANGE: changed line in 0.4:</span>
    <span class="kp">catch</span><span class="p">(</span><span class="ss">:halt</span><span class="p">)</span> <span class="p">{</span> <span class="n">dispatch!</span> <span class="p">}</span>

    <span class="vi">@response</span><span class="p">.</span><span class="nf">values</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>Define <code class="highlighter-rouge">dispatch!</code>, change <code class="highlighter-rouge">route!</code>, define <code class="highlighter-rouge">not_found</code> and <code class="highlighter-rouge">redirect</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Application</span>
  <span class="c1"># CHANGE: new method in 0.4</span>
  <span class="k">def</span> <span class="nf">dispatch!</span>
    <span class="n">route!</span>
    <span class="n">not_found</span>
  <span class="k">end</span>

  <span class="c1"># CHANGE in 0.4: handle not_found separately, use throw:</span>
  <span class="k">def</span> <span class="nf">route!</span>
    <span class="n">match</span> <span class="o">=</span> <span class="no">Application</span><span class="p">.</span><span class="nf">routes</span>
                       <span class="p">.</span><span class="nf">select</span> <span class="p">{</span> <span class="o">|</span><span class="n">route</span><span class="o">|</span> <span class="n">route</span><span class="p">[</span><span class="ss">:verb</span><span class="p">]</span> <span class="o">==</span> <span class="vi">@verb</span> <span class="p">}</span>
                       <span class="p">.</span><span class="nf">find</span>   <span class="p">{</span> <span class="o">|</span><span class="n">route</span><span class="o">|</span> <span class="n">route</span><span class="p">[</span><span class="ss">:pattern</span><span class="p">].</span><span class="nf">match</span><span class="p">(</span><span class="vi">@path</span><span class="p">)</span> <span class="p">}</span>
    <span class="k">return</span> <span class="k">unless</span> <span class="n">match</span>

    <span class="n">values</span> <span class="o">=</span> <span class="n">match</span><span class="p">[</span><span class="ss">:pattern</span><span class="p">].</span><span class="nf">match</span><span class="p">(</span><span class="vi">@path</span><span class="p">).</span><span class="nf">captures</span>
    <span class="n">params</span><span class="p">.</span><span class="nf">merge!</span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="ss">:keys</span><span class="p">].</span><span class="nf">zip</span><span class="p">(</span><span class="n">values</span><span class="p">).</span><span class="nf">to_h</span><span class="p">)</span>
    <span class="n">body</span><span class="p">(</span><span class="nb">instance_eval</span><span class="p">(</span><span class="o">&amp;</span><span class="n">match</span><span class="p">[</span><span class="ss">:block</span><span class="p">]))</span>
    <span class="c1"># CHANGE in 0.4: new line</span>
    <span class="kp">throw</span> <span class="ss">:halt</span>
  <span class="k">end</span>

  <span class="c1"># CHANGE: new method in 0.4</span>
  <span class="k">def</span> <span class="nf">not_found</span>
    <span class="n">status</span> <span class="mi">404</span>
    <span class="n">body</span> <span class="s2">"&lt;h1&gt;404 Not Found&lt;/h1"</span>
    <span class="kp">throw</span> <span class="ss">:halt</span>
  <span class="k">end</span>

  <span class="c1"># CHANGE: new method in 0.4</span>
  <span class="k">def</span> <span class="nf">redirect</span><span class="p">(</span><span class="n">uri</span><span class="p">)</span>
    <span class="n">status</span> <span class="p">(</span><span class="vi">@verb</span> <span class="o">==</span> <span class="s1">'GET'</span> <span class="p">?</span> <span class="mi">302</span> <span class="p">:</span> <span class="mi">303</span><span class="p">)</span>
    <span class="n">headers</span><span class="p">[</span><span class="s1">'Location'</span><span class="p">]</span> <span class="o">=</span> <span class="n">uri</span>
    <span class="kp">throw</span> <span class="ss">:halt</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>
</div>

<h2 id="05-frankie-likes-cookies">0.5. Frankie likes cookies</h2>

<p>Setting up middleware</p>

<p>As an example, we will set up Frankie to use cookie-based session management as provided by <code class="highlighter-rouge">Rack::Session::Cookie</code> (which is also what Sinatra uses by default).</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Application</span>
  <span class="k">class</span> <span class="o">&lt;&lt;</span> <span class="nb">self</span>
    <span class="c1"># CHANGE: changed method</span>
    <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
      <span class="n">prototype</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
    <span class="k">end</span>

    <span class="c1"># CHANGE: new method</span>
    <span class="k">def</span> <span class="nf">prototype</span>
      <span class="vi">@prototype</span> <span class="o">||=</span> <span class="kp">new</span>
    <span class="k">end</span>

    <span class="c1"># CHANGE: new alias</span>
    <span class="k">alias</span> <span class="kp">new</span><span class="o">!</span> <span class="kp">new</span>

    <span class="c1"># CHANGE: new/overridden method</span>
    <span class="k">def</span> <span class="nf">new</span>
      <span class="n">instance</span> <span class="o">=</span> <span class="kp">new</span><span class="o">!</span>
      <span class="n">build</span><span class="p">(</span><span class="n">instance</span><span class="p">).</span><span class="nf">to_app</span>
    <span class="k">end</span>

    <span class="c1"># CHANGE: new method</span>
    <span class="k">def</span> <span class="nf">build</span><span class="p">(</span><span class="n">app</span><span class="p">)</span>
      <span class="n">builder</span> <span class="o">=</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Builder</span><span class="p">.</span><span class="nf">new</span>

      <span class="k">if</span> <span class="vi">@middleware</span>
        <span class="vi">@middleware</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">middleware</span><span class="p">,</span> <span class="n">args</span><span class="o">|</span>
          <span class="n">builder</span><span class="p">.</span><span class="nf">use</span><span class="p">(</span><span class="n">middleware</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">end</span>
      <span class="k">end</span>

      <span class="n">builder</span><span class="p">.</span><span class="nf">run</span> <span class="n">app</span>
      <span class="n">builder</span>
    <span class="k">end</span>

    <span class="c1"># CHANGE: new method</span>
    <span class="k">def</span> <span class="nf">use</span><span class="p">(</span><span class="n">middleware</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
      <span class="p">(</span><span class="vi">@middleware</span> <span class="o">||=</span> <span class="p">[])</span> <span class="o">&lt;&lt;</span> <span class="p">[</span><span class="n">middleware</span><span class="p">,</span> <span class="n">args</span><span class="p">]</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>Rename <code class="highlighter-rouge">call</code> method to <code class="highlighter-rouge">call!</code>, introduce new <code class="highlighter-rouge">call</code> method:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Application</span>
  <span class="c1"># CHANGE: new method</span>
  <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
    <span class="nb">dup</span><span class="p">.</span><span class="nf">call!</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="c1"># CHANGE: this method used to be called `call`.</span>
  <span class="c1"># It is otherwise unchanged.</span>
  <span class="k">def</span> <span class="nf">call!</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
    <span class="vi">@request</span>  <span class="o">=</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Request</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
    <span class="vi">@verb</span>     <span class="o">=</span> <span class="vi">@request</span><span class="p">.</span><span class="nf">request_method</span>
    <span class="vi">@path</span>     <span class="o">=</span> <span class="vi">@request</span><span class="p">.</span><span class="nf">path_info</span>

    <span class="vi">@response</span> <span class="o">=</span> <span class="p">{</span>
      <span class="ss">status:  </span><span class="mi">200</span><span class="p">,</span>
      <span class="ss">headers: </span><span class="n">headers</span><span class="p">,</span>
      <span class="ss">body:    </span><span class="p">[]</span>
    <span class="p">}</span>

    <span class="kp">catch</span><span class="p">(</span><span class="ss">:halt</span><span class="p">)</span> <span class="p">{</span> <span class="n">dispatch!</span> <span class="p">}</span>

    <span class="vi">@response</span><span class="p">.</span><span class="nf">values</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>We also add a <code class="highlighter-rouge">session</code> method for accessing the session:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Application</span>
  <span class="c1"># CHANGE: new method</span>
  <span class="k">def</span> <span class="nf">session</span>
    <span class="vi">@request</span><span class="p">.</span><span class="nf">session</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>
</div>

<h2 id="06-frankie-returns">0.6. Frankie returns</h2>

<p>For flexible return values, we need to introduce one additional level of indirection. Within the <code class="highlighter-rouge">call!</code> method, we invoke <code class="highlighter-rouge">invoke</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Application</span>
  <span class="k">class</span> <span class="o">&lt;&lt;</span> <span class="nb">self</span>
    <span class="k">def</span> <span class="nf">call!</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
      <span class="vi">@request</span>  <span class="o">=</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Request</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
      <span class="vi">@verb</span>     <span class="o">=</span> <span class="vi">@request</span><span class="p">.</span><span class="nf">request_method</span>
      <span class="vi">@path</span>     <span class="o">=</span> <span class="vi">@request</span><span class="p">.</span><span class="nf">path_info</span>

      <span class="vi">@response</span> <span class="o">=</span> <span class="p">{</span>
        <span class="ss">status:  </span><span class="mi">200</span><span class="p">,</span>
        <span class="ss">headers: </span><span class="n">headers</span><span class="p">,</span>
        <span class="ss">body:    </span><span class="p">[]</span>
      <span class="p">}</span>

      <span class="c1"># CHANGE: we use invoke now</span>
      <span class="n">invoke</span> <span class="p">{</span> <span class="n">dispatch!</span> <span class="p">}</span>

      <span class="vi">@response</span><span class="p">.</span><span class="nf">values</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p><code class="highlighter-rouge">invoke</code> is defined as follows:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Application</span>
  <span class="k">class</span> <span class="o">&lt;&lt;</span> <span class="nb">self</span>
    <span class="k">def</span> <span class="nf">invoke</span>
      <span class="n">caught</span> <span class="o">=</span> <span class="kp">catch</span><span class="p">(</span><span class="ss">:halt</span><span class="p">)</span> <span class="p">{</span> <span class="k">yield</span> <span class="p">}</span>
      <span class="k">return</span> <span class="k">unless</span> <span class="n">caught</span>

      <span class="k">case</span> <span class="n">caught</span>
      <span class="k">when</span> <span class="no">Integer</span> <span class="k">then</span> <span class="n">status</span> <span class="n">caught</span>
      <span class="k">when</span> <span class="no">String</span> <span class="k">then</span> <span class="n">body</span> <span class="n">caught</span>
      <span class="k">else</span>
        <span class="n">body</span><span class="p">(</span><span class="o">*</span><span class="n">caught</span><span class="p">.</span><span class="nf">pop</span><span class="p">)</span>
        <span class="n">status</span> <span class="n">caught</span><span class="p">.</span><span class="nf">shift</span>
        <span class="n">headers</span><span class="p">.</span><span class="nf">merge!</span><span class="p">(</span><span class="o">*</span><span class="n">caught</span><span class="p">)</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>
</div>

<h3 id="finishing-touches">Finishing touches</h3>

<p>The code on github includes some additional minor changes.</p>

        </div>
      </div>
      <div class="pad"></div><hr class="line" /><div class="triplepad"></div>

      <!-- 
      <small>07 March 2018</small>
      <p>We are going to develop our toy version of Sinatra in a number of iterations, starting “tiny”, and building towards “small”. This corresponds to how I built Frankie, too, even though this blog post makes the process perhaps appear a little more orderly than it really was.</p>

<h2 id="01-hello-frankie">0.1. Hello Frankie</h2>

<p>At its core, Sinatra is (1) a mechanism for storing routes, and (2) a mechanism for handling requests based on the routes stored. So this is where we start.</p>

<p>If you investigate the Sinatra source code, you will see that part (1), route storage, is a class task, while part (2), request handling, happens at the instance level. Let’s first see how to store routes.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Application</span>
  <span class="k">class</span> <span class="o">&lt;&lt;</span> <span class="nb">self</span>
    <span class="k">def</span> <span class="nf">routes</span>
      <span class="vi">@routes</span> <span class="o">||=</span> <span class="p">[]</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
      <span class="n">route</span><span class="p">(</span><span class="s1">'GET'</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">block</span><span class="p">)</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nf">post</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
      <span class="n">route</span><span class="p">(</span><span class="s1">'POST'</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">block</span><span class="p">)</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nf">route</span><span class="p">(</span><span class="n">verb</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">block</span><span class="p">)</span>
      <span class="n">routes</span> <span class="o">&lt;&lt;</span> <span class="p">{</span>
        <span class="ss">verb:  </span><span class="n">verb</span><span class="p">,</span>
        <span class="ss">path:  </span><span class="n">path</span><span class="p">,</span>
        <span class="ss">block: </span><span class="n">block</span>
      <span class="p">}</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>Routes are stored in an array which we can access via the <code class="highlighter-rouge">routes</code> class method. Invoking the <code class="highlighter-rouge">get</code> and <code class="highlighter-rouge">post</code> method defined above leads to a route being stored. As you can see by inspecting the <code class="highlighter-rouge">route</code> method, a route has three components: an HTTP <code class="highlighter-rouge">verb</code>, a URL <code class="highlighter-rouge">path</code>, and a block (a Proc object, to be precise). If the <code class="highlighter-rouge">verb</code> for a given request is <code class="highlighter-rouge">GET</code>, and its <code class="highlighter-rouge">path</code> is <code class="highlighter-rouge">'/'</code>, then you can imagine that the block will determine how to handle that request.</p>

<p>Now, how are requests handled?</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Application</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">call</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
    <span class="kp">new</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
    <span class="vi">@request</span>  <span class="o">=</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Request</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
    <span class="vi">@verb</span>     <span class="o">=</span> <span class="vi">@request</span><span class="p">.</span><span class="nf">request_method</span>
    <span class="vi">@path</span>     <span class="o">=</span> <span class="vi">@request</span><span class="p">.</span><span class="nf">path_info</span>

    <span class="vi">@response</span> <span class="o">=</span> <span class="p">{</span>
      <span class="ss">status:  </span><span class="mi">200</span><span class="p">,</span>
      <span class="ss">headers: </span><span class="n">headers</span><span class="p">,</span>
      <span class="ss">body:    </span><span class="p">[]</span>
    <span class="p">}</span>

    <span class="n">route!</span>

    <span class="vi">@response</span><span class="p">.</span><span class="nf">values</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">params</span>
    <span class="vi">@request</span><span class="p">.</span><span class="nf">params</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">status</span><span class="p">(</span><span class="n">code</span><span class="p">)</span>
    <span class="vi">@response</span><span class="p">[</span><span class="ss">:status</span><span class="p">]</span> <span class="o">=</span> <span class="n">code</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">headers</span>
    <span class="vi">@headers</span> <span class="o">||=</span> <span class="p">{</span> <span class="s1">'Content-Type'</span> <span class="o">=&gt;</span> <span class="s1">'text/html'</span> <span class="p">}</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">body</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
    <span class="vi">@response</span><span class="p">[</span><span class="ss">:body</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">string</span><span class="p">]</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">route!</span>
    <span class="n">match</span> <span class="o">=</span> <span class="no">Application</span><span class="p">.</span><span class="nf">routes</span>
                       <span class="p">.</span><span class="nf">select</span> <span class="p">{</span> <span class="o">|</span><span class="n">route</span><span class="o">|</span> <span class="n">route</span><span class="p">[</span><span class="ss">:verb</span><span class="p">]</span> <span class="o">==</span> <span class="vi">@verb</span> <span class="p">}</span>
                       <span class="p">.</span><span class="nf">find</span>   <span class="p">{</span> <span class="o">|</span><span class="n">route</span><span class="o">|</span> <span class="n">route</span><span class="p">[</span><span class="ss">:path</span><span class="p">]</span> <span class="o">==</span> <span class="vi">@path</span> <span class="p">}</span>
    <span class="k">return</span> <span class="n">status</span><span class="p">(</span><span class="mi">404</span><span class="p">)</span> <span class="k">unless</span> <span class="n">match</span>

    <span class="n">body</span> <span class="n">match</span><span class="p">[</span><span class="ss">:block</span><span class="p">].</span><span class="nf">call</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>
</div>

<h2 id="02-frankie-goes-top-level">0.2. Frankie goes top level</h2>

<p>New module <code class="highlighter-rouge">Frankie::Delegator</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10</pre></td><td class="code"><pre><span class="k">module</span> <span class="nn">Delegator</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">delegate</span><span class="p">(</span><span class="n">method_name</span><span class="p">)</span>
    <span class="n">define_method</span><span class="p">(</span><span class="n">method_name</span><span class="p">)</span> <span class="k">do</span> <span class="o">|*</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="o">|</span>
      <span class="no">Application</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="n">method_name</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="n">delegate</span><span class="p">(</span><span class="ss">:get</span><span class="p">)</span>
  <span class="n">delegate</span><span class="p">(</span><span class="ss">:post</span><span class="p">)</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>We also need (at the top level):</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre><span class="kp">extend</span> <span class="no">Frankie</span><span class="o">::</span><span class="no">Delegator</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>If we just did this, we could actually already run a ‘Hello world’ route. However, more work needs to be done. E.g., we want to be able to use the <code class="highlighter-rouge">params</code> method in our route blocks.</p>

<p>Change the <code class="highlighter-rouge">Application#route!</code> method to use <code class="highlighter-rouge">instance_eval</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">route!</span>
  <span class="n">match</span> <span class="o">=</span> <span class="no">Application</span><span class="p">.</span><span class="nf">routes</span>
                     <span class="p">.</span><span class="nf">select</span> <span class="p">{</span> <span class="o">|</span><span class="n">route</span><span class="o">|</span> <span class="n">route</span><span class="p">[</span><span class="ss">:verb</span><span class="p">]</span> <span class="o">==</span> <span class="vi">@verb</span> <span class="p">}</span>
                     <span class="p">.</span><span class="nf">find</span>   <span class="p">{</span> <span class="o">|</span><span class="n">route</span><span class="o">|</span> <span class="n">route</span><span class="p">[</span><span class="ss">:path</span><span class="p">]</span> <span class="o">==</span> <span class="vi">@path</span> <span class="p">}</span>
  <span class="k">return</span> <span class="n">status</span><span class="p">(</span><span class="mi">404</span><span class="p">)</span> <span class="k">unless</span> <span class="n">match</span>

  <span class="n">body</span> <span class="nb">instance_eval</span><span class="p">(</span><span class="o">&amp;</span><span class="n">match</span><span class="p">[</span><span class="ss">:block</span><span class="p">])</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>And a <code class="highlighter-rouge">Templates</code> module:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13</pre></td><td class="code"><pre><span class="k">module</span> <span class="nn">Templates</span>
  <span class="k">def</span> <span class="nf">path_to_template</span><span class="p">(</span><span class="n">app_root</span><span class="p">,</span> <span class="n">template</span><span class="p">)</span>
    <span class="n">template_dir</span> <span class="o">=</span> <span class="no">File</span><span class="p">.</span><span class="nf">expand_path</span><span class="p">(</span><span class="s1">'../views'</span><span class="p">,</span> <span class="n">app_root</span><span class="p">)</span>
    <span class="s2">"</span><span class="si">#{</span><span class="n">template_dir</span><span class="si">}</span><span class="s2">/</span><span class="si">#{</span><span class="n">template</span><span class="si">}</span><span class="s2">.erb"</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">erb</span><span class="p">(</span><span class="n">template</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="nb">binding</span>
    <span class="n">app_root</span> <span class="o">=</span> <span class="n">caller_locations</span><span class="p">.</span><span class="nf">first</span><span class="p">.</span><span class="nf">absolute_path</span>
    <span class="n">content</span> <span class="o">=</span> <span class="no">File</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="n">path_to_template</span><span class="p">(</span><span class="n">app_root</span><span class="p">,</span> <span class="n">template</span><span class="p">))</span>
    <span class="no">ERB</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">content</span><span class="p">).</span><span class="nf">result</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>
</div>

<h2 id="03-frankie-recognizes-patterns">0.3. Frankie recognizes patterns</h2>

<p>Change the <code class="highlighter-rouge">route</code> class method, and add <code class="highlighter-rouge">compile</code> class method:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Application</span>
  <span class="k">class</span> <span class="o">&lt;&lt;</span> <span class="nb">self</span>
    <span class="k">def</span> <span class="nf">route</span><span class="p">(</span><span class="n">verb</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">block</span><span class="p">)</span>
      <span class="n">pattern</span><span class="p">,</span> <span class="n">keys</span> <span class="o">=</span> <span class="n">compile</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>

      <span class="n">routes</span> <span class="o">&lt;&lt;</span> <span class="p">{</span>
        <span class="ss">verb:     </span><span class="n">verb</span><span class="p">,</span>
        <span class="ss">pattern:  </span><span class="n">pattern</span><span class="p">,</span>
        <span class="ss">keys:     </span><span class="n">keys</span><span class="p">,</span>
        <span class="ss">block:    </span><span class="n">block</span>
      <span class="p">}</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nf">compile</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
      <span class="n">segments</span> <span class="o">=</span> <span class="n">path</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="s1">'/'</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
      <span class="n">keys</span> <span class="o">=</span> <span class="p">[]</span>

      <span class="n">segments</span><span class="p">.</span><span class="nf">map!</span> <span class="k">do</span> <span class="o">|</span><span class="n">segment</span><span class="o">|</span>
        <span class="k">if</span> <span class="n">segment</span><span class="p">.</span><span class="nf">start_with?</span><span class="p">(</span><span class="s1">':'</span><span class="p">)</span>
          <span class="n">keys</span> <span class="o">&lt;&lt;</span> <span class="n">segment</span><span class="p">[</span><span class="mi">1</span><span class="p">.</span><span class="nf">.</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
          <span class="s2">"([^</span><span class="se">\/</span><span class="s2">]+)"</span>
        <span class="k">else</span>
          <span class="n">segment</span>
        <span class="k">end</span>
      <span class="k">end</span>

      <span class="n">pattern</span> <span class="o">=</span> <span class="no">Regexp</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="s2">"</span><span class="se">\\</span><span class="s2">A</span><span class="si">#{</span><span class="n">segments</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="s1">'/'</span><span class="p">)</span><span class="si">}</span><span class="se">\\</span><span class="s2">z"</span><span class="p">)</span>
      <span class="p">[</span><span class="n">pattern</span><span class="p">,</span> <span class="n">keys</span><span class="p">]</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>Change the <code class="highlighter-rouge">route!</code> instance method:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Application</span>
  <span class="k">def</span> <span class="nf">route!</span>
    <span class="n">match</span> <span class="o">=</span> <span class="no">Application</span><span class="p">.</span><span class="nf">routes</span>
                       <span class="p">.</span><span class="nf">select</span> <span class="p">{</span> <span class="o">|</span><span class="n">route</span><span class="o">|</span> <span class="n">route</span><span class="p">[</span><span class="ss">:verb</span><span class="p">]</span> <span class="o">==</span> <span class="vi">@verb</span> <span class="p">}</span>
                       <span class="p">.</span><span class="nf">find</span>   <span class="p">{</span> <span class="o">|</span><span class="n">route</span><span class="o">|</span> <span class="n">route</span><span class="p">[</span><span class="ss">:pattern</span><span class="p">].</span><span class="nf">match</span><span class="p">(</span><span class="vi">@path</span><span class="p">)</span> <span class="p">}</span>
    <span class="k">return</span> <span class="n">status</span><span class="p">(</span><span class="mi">404</span><span class="p">)</span> <span class="k">unless</span> <span class="n">match</span>

    <span class="c1"># CHANGE in 0.3: process captured groups</span>
    <span class="n">values</span> <span class="o">=</span> <span class="n">match</span><span class="p">[</span><span class="ss">:pattern</span><span class="p">].</span><span class="nf">match</span><span class="p">(</span><span class="vi">@path</span><span class="p">).</span><span class="nf">captures</span>
    <span class="n">params</span><span class="p">.</span><span class="nf">merge!</span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="ss">:keys</span><span class="p">].</span><span class="nf">zip</span><span class="p">(</span><span class="n">values</span><span class="p">).</span><span class="nf">to_h</span><span class="p">)</span>
    <span class="n">body</span><span class="p">(</span><span class="nb">instance_eval</span><span class="p">(</span><span class="o">&amp;</span><span class="n">match</span><span class="p">[</span><span class="ss">:block</span><span class="p">]))</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>
</div>

<h2 id="04-frankie-plays-catch">0.4. Frankie plays catch</h2>

<p>The <code class="highlighter-rouge">Application#call</code> method used to invoke the <code class="highlighter-rouge">Application#route!</code> method. It now reads <code class="highlighter-rouge">catch(:halt) { dispatch! }</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Application</span>
  <span class="c1"># CHANGE: changed method in 0.4:</span>
  <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
    <span class="vi">@request</span>  <span class="o">=</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Request</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
    <span class="vi">@verb</span>     <span class="o">=</span> <span class="vi">@request</span><span class="p">.</span><span class="nf">request_method</span>
    <span class="vi">@path</span>     <span class="o">=</span> <span class="vi">@request</span><span class="p">.</span><span class="nf">path_info</span>

    <span class="vi">@response</span> <span class="o">=</span> <span class="p">{</span>
      <span class="ss">status:  </span><span class="mi">200</span><span class="p">,</span>
      <span class="ss">headers: </span><span class="n">headers</span><span class="p">,</span>
      <span class="ss">body:    </span><span class="p">[]</span>
    <span class="p">}</span>

    <span class="c1"># CHANGE: changed line in 0.4:</span>
    <span class="kp">catch</span><span class="p">(</span><span class="ss">:halt</span><span class="p">)</span> <span class="p">{</span> <span class="n">dispatch!</span> <span class="p">}</span>

    <span class="vi">@response</span><span class="p">.</span><span class="nf">values</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>Define <code class="highlighter-rouge">dispatch!</code>, change <code class="highlighter-rouge">route!</code>, define <code class="highlighter-rouge">not_found</code> and <code class="highlighter-rouge">redirect</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Application</span>
  <span class="c1"># CHANGE: new method in 0.4</span>
  <span class="k">def</span> <span class="nf">dispatch!</span>
    <span class="n">route!</span>
    <span class="n">not_found</span>
  <span class="k">end</span>

  <span class="c1"># CHANGE in 0.4: handle not_found separately, use throw:</span>
  <span class="k">def</span> <span class="nf">route!</span>
    <span class="n">match</span> <span class="o">=</span> <span class="no">Application</span><span class="p">.</span><span class="nf">routes</span>
                       <span class="p">.</span><span class="nf">select</span> <span class="p">{</span> <span class="o">|</span><span class="n">route</span><span class="o">|</span> <span class="n">route</span><span class="p">[</span><span class="ss">:verb</span><span class="p">]</span> <span class="o">==</span> <span class="vi">@verb</span> <span class="p">}</span>
                       <span class="p">.</span><span class="nf">find</span>   <span class="p">{</span> <span class="o">|</span><span class="n">route</span><span class="o">|</span> <span class="n">route</span><span class="p">[</span><span class="ss">:pattern</span><span class="p">].</span><span class="nf">match</span><span class="p">(</span><span class="vi">@path</span><span class="p">)</span> <span class="p">}</span>
    <span class="k">return</span> <span class="k">unless</span> <span class="n">match</span>

    <span class="n">values</span> <span class="o">=</span> <span class="n">match</span><span class="p">[</span><span class="ss">:pattern</span><span class="p">].</span><span class="nf">match</span><span class="p">(</span><span class="vi">@path</span><span class="p">).</span><span class="nf">captures</span>
    <span class="n">params</span><span class="p">.</span><span class="nf">merge!</span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="ss">:keys</span><span class="p">].</span><span class="nf">zip</span><span class="p">(</span><span class="n">values</span><span class="p">).</span><span class="nf">to_h</span><span class="p">)</span>
    <span class="n">body</span><span class="p">(</span><span class="nb">instance_eval</span><span class="p">(</span><span class="o">&amp;</span><span class="n">match</span><span class="p">[</span><span class="ss">:block</span><span class="p">]))</span>
    <span class="c1"># CHANGE in 0.4: new line</span>
    <span class="kp">throw</span> <span class="ss">:halt</span>
  <span class="k">end</span>

  <span class="c1"># CHANGE: new method in 0.4</span>
  <span class="k">def</span> <span class="nf">not_found</span>
    <span class="n">status</span> <span class="mi">404</span>
    <span class="n">body</span> <span class="s2">"&lt;h1&gt;404 Not Found&lt;/h1"</span>
    <span class="kp">throw</span> <span class="ss">:halt</span>
  <span class="k">end</span>

  <span class="c1"># CHANGE: new method in 0.4</span>
  <span class="k">def</span> <span class="nf">redirect</span><span class="p">(</span><span class="n">uri</span><span class="p">)</span>
    <span class="n">status</span> <span class="p">(</span><span class="vi">@verb</span> <span class="o">==</span> <span class="s1">'GET'</span> <span class="p">?</span> <span class="mi">302</span> <span class="p">:</span> <span class="mi">303</span><span class="p">)</span>
    <span class="n">headers</span><span class="p">[</span><span class="s1">'Location'</span><span class="p">]</span> <span class="o">=</span> <span class="n">uri</span>
    <span class="kp">throw</span> <span class="ss">:halt</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>
</div>

<h2 id="05-frankie-likes-cookies">0.5. Frankie likes cookies</h2>

<p>Setting up middleware</p>

<p>As an example, we will set up Frankie to use cookie-based session management as provided by <code class="highlighter-rouge">Rack::Session::Cookie</code> (which is also what Sinatra uses by default).</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Application</span>
  <span class="k">class</span> <span class="o">&lt;&lt;</span> <span class="nb">self</span>
    <span class="c1"># CHANGE: changed method</span>
    <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
      <span class="n">prototype</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
    <span class="k">end</span>

    <span class="c1"># CHANGE: new method</span>
    <span class="k">def</span> <span class="nf">prototype</span>
      <span class="vi">@prototype</span> <span class="o">||=</span> <span class="kp">new</span>
    <span class="k">end</span>

    <span class="c1"># CHANGE: new alias</span>
    <span class="k">alias</span> <span class="kp">new</span><span class="o">!</span> <span class="kp">new</span>

    <span class="c1"># CHANGE: new/overridden method</span>
    <span class="k">def</span> <span class="nf">new</span>
      <span class="n">instance</span> <span class="o">=</span> <span class="kp">new</span><span class="o">!</span>
      <span class="n">build</span><span class="p">(</span><span class="n">instance</span><span class="p">).</span><span class="nf">to_app</span>
    <span class="k">end</span>

    <span class="c1"># CHANGE: new method</span>
    <span class="k">def</span> <span class="nf">build</span><span class="p">(</span><span class="n">app</span><span class="p">)</span>
      <span class="n">builder</span> <span class="o">=</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Builder</span><span class="p">.</span><span class="nf">new</span>

      <span class="k">if</span> <span class="vi">@middleware</span>
        <span class="vi">@middleware</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">middleware</span><span class="p">,</span> <span class="n">args</span><span class="o">|</span>
          <span class="n">builder</span><span class="p">.</span><span class="nf">use</span><span class="p">(</span><span class="n">middleware</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">end</span>
      <span class="k">end</span>

      <span class="n">builder</span><span class="p">.</span><span class="nf">run</span> <span class="n">app</span>
      <span class="n">builder</span>
    <span class="k">end</span>

    <span class="c1"># CHANGE: new method</span>
    <span class="k">def</span> <span class="nf">use</span><span class="p">(</span><span class="n">middleware</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
      <span class="p">(</span><span class="vi">@middleware</span> <span class="o">||=</span> <span class="p">[])</span> <span class="o">&lt;&lt;</span> <span class="p">[</span><span class="n">middleware</span><span class="p">,</span> <span class="n">args</span><span class="p">]</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>Rename <code class="highlighter-rouge">call</code> method to <code class="highlighter-rouge">call!</code>, introduce new <code class="highlighter-rouge">call</code> method:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Application</span>
  <span class="c1"># CHANGE: new method</span>
  <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
    <span class="nb">dup</span><span class="p">.</span><span class="nf">call!</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="c1"># CHANGE: this method used to be called `call`.</span>
  <span class="c1"># It is otherwise unchanged.</span>
  <span class="k">def</span> <span class="nf">call!</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
    <span class="vi">@request</span>  <span class="o">=</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Request</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
    <span class="vi">@verb</span>     <span class="o">=</span> <span class="vi">@request</span><span class="p">.</span><span class="nf">request_method</span>
    <span class="vi">@path</span>     <span class="o">=</span> <span class="vi">@request</span><span class="p">.</span><span class="nf">path_info</span>

    <span class="vi">@response</span> <span class="o">=</span> <span class="p">{</span>
      <span class="ss">status:  </span><span class="mi">200</span><span class="p">,</span>
      <span class="ss">headers: </span><span class="n">headers</span><span class="p">,</span>
      <span class="ss">body:    </span><span class="p">[]</span>
    <span class="p">}</span>

    <span class="kp">catch</span><span class="p">(</span><span class="ss">:halt</span><span class="p">)</span> <span class="p">{</span> <span class="n">dispatch!</span> <span class="p">}</span>

    <span class="vi">@response</span><span class="p">.</span><span class="nf">values</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>We also add a <code class="highlighter-rouge">session</code> method for accessing the session:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Application</span>
  <span class="c1"># CHANGE: new method</span>
  <span class="k">def</span> <span class="nf">session</span>
    <span class="vi">@request</span><span class="p">.</span><span class="nf">session</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>
</div>

<h2 id="06-frankie-returns">0.6. Frankie returns</h2>

<p>For flexible return values, we need to introduce one additional level of indirection. Within the <code class="highlighter-rouge">call!</code> method, we invoke <code class="highlighter-rouge">invoke</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Application</span>
  <span class="k">class</span> <span class="o">&lt;&lt;</span> <span class="nb">self</span>
    <span class="k">def</span> <span class="nf">call!</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
      <span class="vi">@request</span>  <span class="o">=</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Request</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
      <span class="vi">@verb</span>     <span class="o">=</span> <span class="vi">@request</span><span class="p">.</span><span class="nf">request_method</span>
      <span class="vi">@path</span>     <span class="o">=</span> <span class="vi">@request</span><span class="p">.</span><span class="nf">path_info</span>

      <span class="vi">@response</span> <span class="o">=</span> <span class="p">{</span>
        <span class="ss">status:  </span><span class="mi">200</span><span class="p">,</span>
        <span class="ss">headers: </span><span class="n">headers</span><span class="p">,</span>
        <span class="ss">body:    </span><span class="p">[]</span>
      <span class="p">}</span>

      <span class="c1"># CHANGE: we use invoke now</span>
      <span class="n">invoke</span> <span class="p">{</span> <span class="n">dispatch!</span> <span class="p">}</span>

      <span class="vi">@response</span><span class="p">.</span><span class="nf">values</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p><code class="highlighter-rouge">invoke</code> is defined as follows:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Application</span>
  <span class="k">class</span> <span class="o">&lt;&lt;</span> <span class="nb">self</span>
    <span class="k">def</span> <span class="nf">invoke</span>
      <span class="n">caught</span> <span class="o">=</span> <span class="kp">catch</span><span class="p">(</span><span class="ss">:halt</span><span class="p">)</span> <span class="p">{</span> <span class="k">yield</span> <span class="p">}</span>
      <span class="k">return</span> <span class="k">unless</span> <span class="n">caught</span>

      <span class="k">case</span> <span class="n">caught</span>
      <span class="k">when</span> <span class="no">Integer</span> <span class="k">then</span> <span class="n">status</span> <span class="n">caught</span>
      <span class="k">when</span> <span class="no">String</span> <span class="k">then</span> <span class="n">body</span> <span class="n">caught</span>
      <span class="k">else</span>
        <span class="n">body</span><span class="p">(</span><span class="o">*</span><span class="n">caught</span><span class="p">.</span><span class="nf">pop</span><span class="p">)</span>
        <span class="n">status</span> <span class="n">caught</span><span class="p">.</span><span class="nf">shift</span>
        <span class="n">headers</span><span class="p">.</span><span class="nf">merge!</span><span class="p">(</span><span class="o">*</span><span class="n">caught</span><span class="p">)</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>
</div>

<h3 id="finishing-touches">Finishing touches</h3>

<p>The code on github includes some additional minor changes.</p>

      <div class="pad"></div><hr class="line" /><div class="triplepad"></div>
      
      <small>18 December 2017</small>
      <p>Ruby comes with a <a href="https://github.com/ruby/ruby/blob/trunk/lib/set.rb"><code class="highlighter-rouge">Set</code> class</a> as part of its standard library, and there is also a <a href="https://github.com/maraigue/multiset/blob/master/lib/multiset.rb"><code class="highlighter-rouge">Multiset</code> class</a> available as a gem. Both classes uses hashes internally. However, the two libraries are completely separate, so, of course, they do not share any code. This is somewhat regrettable, since—as we will see during the course of this post—sets and multisets have quite a bit in common. For this reason, I thought that it would be a nice exercise to write a more generic set class from scratch that would allow us to derive the functionality provided by the above-mentioned classes by inheritance. For good measure, I decided to throw fuzzy sets into the mix, another type of set with useful applications. The result could be called a polymorphic approach to modeling various types of sets in Ruby. This post is a tutorial-style presentation of what I came up with. If you don’t care much for lengthy explanations, head <a href="https://github.com/benrodenhaeuser/sets">straight to Github</a> to have a look at the code.</p>

<h2 id="classical-sets-multisets-and-fuzzy-sets">Classical sets, multisets, and fuzzy sets</h2>

<p>Let’s first get an overview of the types of collections we are interested in by means of some quick examples.</p>

<h3 id="classical-sets">Classical Sets</h3>

<p>Supppose we wanted to concisely represent the letters occuring in a word, while disregarding their sequential order as well as the number of times they occur in the word. A classical set would be a good choice of data structure for this task. For instance, the word “$\text{learner}$” could be represented by the set</p>

<script type="math/tex; mode=display">\lbrace a, e, l, r, n \rbrace.</script>

<p>Incidentally, the word “$\text{learn}$” corresponds to the same classical set, as it contains the same letters. The word “$\text{land}$”, on the other hand, corresponds to the set</p>

<script type="math/tex; mode=display">\lbrace a, l, n, d \rbrace.</script>

<p>Taking the intersection of the two sets, which collects the elements occuring in both of them, we obtain the set $\lbrace a, l, n\rbrace$, which captures the overlap of the two words in terms of letters contained—a crude measure of what they have in common. So sets allow us to zoom in on questions of membership, while disregarding other aspects of particular entities we wish to study.</p>

<h3 id="multisets">Multisets</h3>

<p>Suppose now we would like to count <em>how often</em> letters occur in a given word or text, while (still) disregarding their order. A multiset would be an appropriate data structure to accomplish this. For example, the above word “$\text{learner}$” corresponds to the multiset</p>

<script type="math/tex; mode=display">\lbrace a, e, e, l, r, r, n \rbrace</script>

<p>Notice that the word “$\text{learn}$” would be represented by a different multiset, namely $\lbrace a, e, l, r, n \rbrace$. So multisets make finer distinctions than classical sets.</p>

<p>A more concise way to represent a multiset is by means of key-value notation. In this notation, our multiset representation of the word “$\text{learner}$” would be written as</p>

<script type="math/tex; mode=display">\lbrace a: 1, e: 2, l: 1, r: 2, n: 1\rbrace</script>

<p>In a programming context, the elements of a set (be it a classical set or a multiset) are often called <em>keys</em>. The above multiset has five distinct keys: $a$, $e$, $l$, $r$ and $n$. In a multiset, each key comes with a count, the value associated with the key, which we will refer to as the <em>score</em> for that key. The score for the key $e$ in the above multiset, for example, is $2$.</p>

<h3 id="fuzzy-sets">Fuzzy sets</h3>

<p>Fuzzy sets also make finer distinctions compared to classical sets. However, they generalize classical sets in a different direction. As we just saw, in a multiset, the score for a particular key represents <em>multiplicity</em> of membership (how many times does the key occur in the set?). In a fuzzy set, the score indicates <em>degree of membership</em>. So besides an element being “fully contained” in the set or “not contained”, it may also be “partially contained” in the set, so to speak.</p>

<p>To see how this can be useful, take this example: consider the words “$\text{learner}$”, “$\text{learn}$”, “$\text{learned}$”, and “$\text{lean}$”. We might wish to capture how similar each of these words is to some other word, let’s say the word “$\text{learner}$” again. The similarity of “$\text{learner}$” to itself is perfect, since no edit (letter change) is required to transform one into the other. They are the same, after all. On to the more interesting cases: the word “$\text{learned}$” is very similar to “$\text{learner}$” – substituting the last letter will transform the former into the latter. “$\text{learn}$” is also very similar to “$\text{learner}$”, but a little less so – deleting the last two letters from “$\text{learner}$” results in “$\text{learner}$”, requiring two steps rather than one. The word “$\text{lean}$” is again a bit less similar to “$\text{learner}$”, requiring one additional deletion. So to transform each of the words given into “$\text{learner}$” requires:</p>

<ul>
  <li>”$\text{learner}$”: $0$ edits</li>
  <li>”$\text{learned}$”: $1$ edit</li>
  <li>”$\text{learn}$”: $2$ edits</li>
  <li>”$\text{lean}$”: $3$ edits</li>
</ul>

<p>For the sake of exposition, let us settle on $3$ as the—pretty arbitrarily chosen—treshold from which onwards two words to be considered completely dissimilar, or “not similar at all”. Then we can map our edit counts to a scale from $0$ to $1$, and represent our findings as a fuzzy set which scores the key “$\text{learner}$” with $1.0$, “$\text{learned}$” with $0.66$, “$\text{learn}$” with $0.33$ and “$\text{lean}$” with $0.0$, or, using key-value notation:</p>

<script type="math/tex; mode=display">\lbrace\text{learner}: 1.0, \text{learned}: 0.66, \text{learn}: 0.33, \text{lean}: 0.0\rbrace</script>

<p>In this fuzzy set, the degree of each element is to be interpreted as the degree of similarity to our target word “learner”.</p>

<h2 id="the-setmap-class-and-its-children">The <code class="highlighter-rouge">SetMap</code> class and its children</h2>

<p>Equipped with some basic understanding of our problem domain, let us begin to develop the main ingredients for a Ruby model of sets that encompasses the types of sets we have discussed (as well as potentially other ones). We start by discussing a <code class="highlighter-rouge">SetMap</code> class that captures the commonalities of classical sets, fuzzy sets, and multisets, while allowing us to easily define each of these specific types via inheritance.</p>

<h3 id="hash-tables">Hash tables</h3>

<p>What do the three types of sets have in common? At first glance, it seems that their internal structure is pretty different: multisets and fuzzy sets have been presented above as consisting of key-value pairs, while classical sets simply consist of a bunch of keys. However, this is merely a matter of representation. In fact, it is rather common to represent a classical set by means of a <em>characteristic function</em>, which maps the members of the set to $1$, while all other objects from a given domain are mapped to $0$. Taking a cue from this, we extend our key-value notation to classical sets, writing the set $\lbrace 0, 1, 2\rbrace$, for example, as $\lbrace 0: 1, 1: 1, 2: 1\rbrace$.</p>

<p>From this perspective, it becomes obvious that the membership information for a set—be it a fuzzy set, a classical set, or a multiset—may be stored in a hash table:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3</pre></td><td class="code"><pre><span class="p">{</span> <span class="s1">'a'</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">'b'</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">'c'</span> <span class="o">=&gt;</span> <span class="mi">1</span> <span class="p">}</span>     <span class="c1"># 'classical set'</span>
<span class="p">{</span> <span class="s1">'a'</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">'b'</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">'c'</span> <span class="o">=&gt;</span> <span class="mi">2</span> <span class="p">}</span>     <span class="c1"># 'multiset'</span>
<span class="p">{</span> <span class="s1">'a'</span> <span class="o">=&gt;</span> <span class="mi">0</span><span class="o">.</span><span class="mi">3</span><span class="p">,</span> <span class="s1">'b'</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">'c'</span> <span class="o">=&gt;</span> <span class="mi">0</span><span class="o">.</span><span class="mi">6</span> <span class="p">}</span> <span class="c1"># 'fuzzy set'</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>Hash tables will form the basis of our representation of sets. Of course, we would not want to directly expose such a table to the user of our set class. The user need not even be aware that we are using a hash table to store her set. Rather, the hash instance that stores the set keys and their associated scores will be a collaborator object to our set object. The <code class="highlighter-rouge">initialize</code> method of our <code class="highlighter-rouge">SetMap</code> class sets the stage for this:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">SetMap</span>
  <span class="k">def</span> <span class="nf">initialize</span>
    <span class="vi">@hash</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="vi">@size</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>Besides the <code class="highlighter-rouge">@hash</code> instance variable, we also decide to maintain an instance variable <code class="highlighter-rouge">@size</code>, in the interest of being able to look up the size of our set in constant time. The size of a set is commonly defined as the sum of the scores of its keys, and the idea is that <code class="highlighter-rouge">@size</code> will always store this value in an up-to-date fashion. We also make available a getter method <code class="highlighter-rouge">size</code> that returns the current value of <code class="highlighter-rouge">@size</code>, omitted here.</p>

<h3 id="valid-scores">Valid scores</h3>

<p>What distinguishes the types of sets we have seen above from each other? It is primarily what counts as a valid score according to each type:</p>

<ul>
  <li>A classical set either contains or does not contain a particular key, so the only valid scores are $0$ and $1$.</li>
  <li>A multiset may contain a given key $n$ times, where $n$ is a non-negative integer.</li>
  <li>A fuzzy set scores a given key to a degree in the unit interval from $0$ to $1$.</li>
</ul>

<p>So in each case, we have to be able to express a range of possible values. We set up a bunch of class methods and class instance variables for this purpose:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">SetMap</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">score_type</span>
    <span class="vi">@score_type</span> <span class="o">||</span> <span class="k">raise</span><span class="p">(</span><span class="no">SetError</span><span class="p">,</span> <span class="s1">'@score_type not initialized'</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">min_score</span>
    <span class="vi">@min_score</span> <span class="o">||</span> <span class="k">raise</span><span class="p">(</span><span class="no">SetError</span><span class="p">,</span> <span class="s1">'@min_score not initialized'</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">max_score</span>
    <span class="vi">@max_score</span> <span class="o">||</span> <span class="k">raise</span><span class="p">(</span><span class="no">SetError</span><span class="p">,</span> <span class="s1">'@max_score not initialized'</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">valid_score?</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
    <span class="n">val</span><span class="p">.</span><span class="nf">is_a?</span><span class="p">(</span><span class="n">score_type</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">min_score</span><span class="p">.</span><span class="nf">.</span><span class="n">max_score</span><span class="p">).</span><span class="nf">cover?</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>The first three class methods defined above are getters (on the level of the class object) for the class instance variables <code class="highlighter-rouge">@score_type</code> (the kind of object we may use as a score for a key), <code class="highlighter-rouge">@min_score</code> (the smallest value that may be used as a score), and <code class="highlighter-rouge">@max_score</code> (the largest value that maye be used as a score). The fourth method uses these getters and describes what constitutes a valid score as a predicate.</p>

<p>As the second disjunct of each of the above getter methods tells us loud and clear, we are missing something so far: our class instance variables have not been set to any value! Initializing those class instance variables is precisely the job description of our target classes.</p>

<h3 id="target-classes">Target classes</h3>

<p><code class="highlighter-rouge">SetMap</code> is meant to be subclassed, with each subclass defining a particular set type by specifying a range of legal scores via the class instance variables <code class="highlighter-rouge">@score_type</code>, <code class="highlighter-rouge">@min_score</code> and <code class="highlighter-rouge">@max_score</code>. Here is the code for classical sets:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">ClassicalSet</span> <span class="o">&lt;</span> <span class="no">SetMap</span>
  <span class="vi">@score_type</span> <span class="o">=</span> <span class="no">Integer</span>
  <span class="vi">@min_score</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="vi">@max_score</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>In other words, the only valid scores for the keys of classical sets are the integers <code class="highlighter-rouge">0</code> and <code class="highlighter-rouge">1</code>. For fuzzy sets, we write:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">FuzzySet</span> <span class="o">&lt;</span> <span class="no">SetMap</span>
  <span class="vi">@score_type</span> <span class="o">=</span> <span class="no">Numeric</span>
  <span class="vi">@min_score</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="vi">@max_score</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>So any <code class="highlighter-rouge">Numeric</code> instance in the closed interval $[0, 1]$ is a valid score for a fuzzy set key (we choose <code class="highlighter-rouge">Numeric</code> so as to allow both floats and integers). Finally, for multisets:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">MultiSet</span> <span class="o">&lt;</span> <span class="no">SetMap</span>
  <span class="vi">@score_type</span> <span class="o">=</span> <span class="no">Integer</span>
  <span class="vi">@min_score</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="vi">@max_score</span> <span class="o">=</span> <span class="no">Float</span><span class="o">::</span><span class="no">INFINITY</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>The <code class="highlighter-rouge">Float::INFINITY</code> constant has the property that <code class="highlighter-rouge">x &lt; Float::INFINITY</code> for any numeric <code class="highlighter-rouge">x</code>. Setting <code class="highlighter-rouge">@max_score</code> to <code class="highlighter-rouge">Float::INFINITY</code> is thus a way of saying that, for multisets, there is no maximal score: any non-negative integer is allowed.</p>

<p>And this is really all there is to it! Specializing the capabilities of <code class="highlighter-rouge">SetMap</code> to a particular target class boils down to providing appropriate values for a bunch of class instance variables.</p>

<p>Of course, we have not yet demonstrated what the interface for <code class="highlighter-rouge">SetMap</code> actually looks like. But from now on, we will write methods that work equally well for all three set types under consideration: classical sets, fuzzy sets, and multisets.</p>

<h3 id="key-insertion">Key insertion.</h3>

<p>The most basic part of the interface of any set class is arguably the capability of inserting scores for particular keys. Here is the <code class="highlighter-rouge">SetMap#insert</code> method:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
  <span class="k">raise</span><span class="p">(</span><span class="no">SetError</span><span class="p">,</span> <span class="s1">'Illegal value'</span><span class="p">)</span> <span class="k">unless</span> <span class="nb">self</span><span class="p">.</span><span class="nf">class</span><span class="p">.</span><span class="nf">valid_score?</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
  <span class="n">old_score</span> <span class="o">=</span> <span class="nb">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
  <span class="vi">@hash</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">+</span> <span class="n">val</span><span class="p">,</span> <span class="nb">self</span><span class="p">.</span><span class="nf">class</span><span class="p">.</span><span class="nf">max_score</span><span class="p">].</span><span class="nf">min</span>
  <span class="vi">@size</span> <span class="o">=</span> <span class="vi">@size</span> <span class="o">+</span> <span class="p">(</span><span class="nb">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">-</span> <span class="n">old_score</span><span class="p">)</span>
  <span class="nb">self</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>The general idea of this method is to increment the score of <code class="highlighter-rouge">key</code> by <code class="highlighter-rouge">val</code>. As per line 2 of the snippet, this will work only if <code class="highlighter-rouge">val</code> is a valid score according to the implementation of <code class="highlighter-rouge">valid_score?</code> (which in turn depends on the values of the class instance variables <code class="highlighter-rouge">@score_type</code>, <code class="highlighter-rouge">@min_score</code> and <code class="highlighter-rouge">@max_score</code>). If that is the case, we use what is called a <em>bounded sum</em> to add <code class="highlighter-rouge">val</code> to <code class="highlighter-rouge">self[key]</code>, capping off the sum at <code class="highlighter-rouge">@max_score</code> (line 4).</p>

<p>Let’s try this out using our target classes:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14</pre></td><td class="code"><pre><span class="n">fuzzy_set</span> <span class="o">=</span> <span class="no">FuzzySet</span><span class="p">.</span><span class="nf">new</span>
<span class="n">fuzzy_set</span><span class="p">.</span><span class="nf">insert</span><span class="p">(</span><span class="s1">'a'</span><span class="p">,</span> <span class="mi">0</span><span class="o">.</span><span class="mi">5</span><span class="p">)</span>
<span class="n">fuzzy_set</span><span class="p">.</span><span class="nf">insert</span><span class="p">(</span><span class="s1">'a'</span><span class="p">,</span> <span class="mi">0</span><span class="o">.</span><span class="mi">3</span><span class="p">)</span>
<span class="n">fuzzy_set</span> <span class="c1">#=&gt; #&lt;FuzzySet: {"a": 0.8}&gt;</span>

<span class="n">multi_set</span> <span class="o">=</span> <span class="no">MultiSet</span><span class="p">.</span><span class="nf">new</span>
<span class="n">multi_set</span><span class="p">.</span><span class="nf">insert</span><span class="p">(</span><span class="s1">'a'</span><span class="p">)</span>
<span class="n">multi_set</span><span class="p">.</span><span class="nf">insert</span><span class="p">(</span><span class="s1">'a'</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">multi_set</span> <span class="c1">#=&gt; #&lt;MultiSet: {"a": 3}&gt;</span>

<span class="n">classical_set</span> <span class="o">=</span> <span class="no">ClassicalSet</span><span class="p">.</span><span class="nf">new</span>
<span class="n">classical_set</span><span class="p">.</span><span class="nf">insert</span><span class="p">(</span><span class="s1">'a'</span><span class="p">)</span>
<span class="n">classical_set</span><span class="p">.</span><span class="nf">insert</span><span class="p">(</span><span class="s1">'a'</span><span class="p">)</span>
<span class="n">classical_set</span> <span class="c1">#=&gt; #&lt;ClassicalSet: {"a": 1}&gt;</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>These are the desired results (assuming a—standard—<code class="highlighter-rouge">inspect</code> method which we have not shown). Notice that the score range we have specified for classical sets in tandem with the bounded sum ensures that inserting the same key twice has the same effect as inserting it once: the sum of <code class="highlighter-rouge">1</code> and <code class="highlighter-rouge">1</code> bounded by <code class="highlighter-rouge">1</code> is again <code class="highlighter-rouge">1</code>.</p>

<p>Returning to the earlier snippet, we also need to keep track of the size of our set (line 5). Here, we also neutralize rounding errors that might occur for types of sets that allow <a href="http://floating-point-gui.de">floating point numbers</a> as scores.</p>

<h3 id="key-retrieval">Key retrieval</h3>

<p>Next, consider <code class="highlighter-rouge">SetMap#retrieve</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">retrieve</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
  <span class="vi">@hash</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="p">?</span> <span class="vi">@hash</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="p">:</span> <span class="mi">0</span>
<span class="k">end</span>
<span class="k">alias</span> <span class="p">[]</span> <span class="n">retrieve</span>
</pre></td></tr></tbody></table>
</div>
</div>
<p>The <code class="highlighter-rouge">retrieve</code> method (which we alias as <code class="highlighter-rouge">[]</code>) wraps the element reference method of our internal hash. If the hash does not contain a certain key, <code class="highlighter-rouge">@hash[key]</code> will return <code class="highlighter-rouge">nil</code>. In that case, <code class="highlighter-rouge">retrieve(key)</code> (or, equivalently as per our alias, <code class="highlighter-rouge">self[key]</code>) will return <code class="highlighter-rouge">0</code>. Alternatively, we could haver set a default value for <code class="highlighter-rouge">@hash</code>, but the current way seems slightly more explicit.</p>

<p>Observe that key retrieval is fast: accessing a hash key takes constant time on average (<a href="https://lemire.me/blog/2009/08/18/do-hash-tables-work-in-constant-time/">disregarding some fine-print</a>), i.e., as the number of keys in a hash increases, the average time necessary to recover the value for a key does not increase. This is one of the main reasons why using hash tables to model sets is an attractive choice.</p>

<h3 id="key-removal">Key removal</h3>

<p>While it would be possible to tweak our approach and express removal of a key as insertion with a negative score, we prefer to keep things simple here:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
  <span class="k">raise</span><span class="p">(</span><span class="no">SetError</span><span class="p">,</span> <span class="s1">'Illegal value'</span><span class="p">)</span> <span class="k">unless</span> <span class="nb">self</span><span class="p">.</span><span class="nf">class</span><span class="p">.</span><span class="nf">valid_score?</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
  <span class="n">old_score</span> <span class="o">=</span> <span class="nb">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
  <span class="vi">@hash</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">-</span> <span class="n">val</span><span class="p">,</span> <span class="nb">self</span><span class="p">.</span><span class="nf">class</span><span class="p">.</span><span class="nf">min_score</span><span class="p">].</span><span class="nf">max</span>
  <span class="vi">@size</span> <span class="o">=</span> <span class="vi">@size</span> <span class="o">-</span> <span class="p">(</span><span class="n">old_score</span> <span class="o">-</span> <span class="nb">self</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
  <span class="nb">self</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p><code class="highlighter-rouge">SetMap#remove</code> is perfectly symmetric to the earlier <code class="highlighter-rouge">insert</code> method, using a bounded difference instead of a bounded sum. For our three target classes, this ensures that negative scores cannot occur.</p>

<h3 id="enumeration">Enumeration</h3>

<p>The below <code class="highlighter-rouge">SetMap#each_pair</code> method enumerates set keys and their associated scores in a straightforward manner, piggybacking on <code class="highlighter-rouge">Hash#each_pair</code>. Notice that we only yield key-value pairs for which the value is non-zero, since a key scored with value <code class="highlighter-rouge">0</code> is not considered part of our set.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">each_pair</span>
  <span class="k">return</span> <span class="n">to_enum</span><span class="p">(</span><span class="ss">:each_pair</span><span class="p">)</span> <span class="k">unless</span> <span class="nb">block_given?</span>

  <span class="vi">@hash</span><span class="p">.</span><span class="nf">each_pair</span> <span class="k">do</span> <span class="o">|</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="o">|</span>
    <span class="k">yield</span><span class="p">([</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">])</span> <span class="k">if</span> <span class="n">val</span> <span class="o">!=</span> <span class="mi">0</span>
  <span class="k">end</span>

  <span class="nb">self</span>
<span class="k">end</span>
<span class="k">alias</span> <span class="n">each</span> <span class="n">each_pair</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>As we will see below, <code class="highlighter-rouge">each_pair</code> forms the basis for all our methods that iterate over sets. This includes pretty much all the interesting operations on sets—<code class="highlighter-rouge">union</code>, <code class="highlighter-rouge">intersection</code>, and the like. Since <code class="highlighter-rouge">each_pair</code> is aliassed as <code class="highlighter-rouge">each</code>, it also allows us to include the <code class="highlighter-rouge">Enumerable</code> module, which any respectable Ruby collection class should have access to.</p>

<h2 id="the-setlike-module">The <code class="highlighter-rouge">SetLike</code> module</h2>

<p>The preceding methods, and the <code class="highlighter-rouge">SetMap</code> class that defines these methods, serve as a wrapper around our hash table. We have also implemented a mechanism for specifying what constitutes a valid score for a given type of set. And we have provided our three target classes that inherit from <code class="highlighter-rouge">SetMap</code>. The basics of our model are thus in place.</p>

<p>What remains to be implemented is all the interesting operations on sets! The remaining part of the interface will, however, not interact with the internally used hash table directly, but only through the interface developed so far.</p>

<p>For the purpose of implementing those additional operations, we open a new module <code class="highlighter-rouge">SetLike</code>, which we include in <code class="highlighter-rouge">SetMap</code>.</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{matrix}
 && \text{SetLike} & \\
&& \large\uparrow  \\
&& \text{SetMap} \\
&\large\nearrow & \large\uparrow & \large\nwarrow \\
\text{ClassicalSet} & & \text{MultiSet}&  & \text{FuzzySet}\\
\end{matrix} %]]></script>

<p>Since our target classes <code class="highlighter-rouge">ClassicalSet</code>, <code class="highlighter-rouge">FuzzySet</code> and <code class="highlighter-rouge">MultiSet</code> inherit from <code class="highlighter-rouge">SetMap</code>, as shown in the above diagram, they will also be able to access the functionality provided by <code class="highlighter-rouge">SetLike</code>.</p>

<h3 id="division-of-labor">Division of Labor</h3>

<p>The division of labor we adopt here takes a cue from the place the <code class="highlighter-rouge">Enumerable</code> module occupies in Ruby’s design. <code class="highlighter-rouge">Enumerable</code> provides a number of useful methods for working with collections to any class that chooses to include it. In doing so, <code class="highlighter-rouge">Enumerable</code> assumes that the class implements an <code class="highlighter-rouge">each</code> method, which forms the basis for all the methods <code class="highlighter-rouge">Enumerable</code> defines. Beyond this, however, <code class="highlighter-rouge">Enumerable</code> does not (need to) know anything about the class using it. Here, we do something very similar:</p>

<ul>
  <li><code class="highlighter-rouge">SetLike</code> provides most of the functionality commonly associated with sets.</li>
  <li><code class="highlighter-rouge">SetLike</code> assumes that any class that uses it implements the instance methods <code class="highlighter-rouge">retrieve</code>, <code class="highlighter-rouge">insert</code>, <code class="highlighter-rouge">delete</code>, <code class="highlighter-rouge">each</code> and <code class="highlighter-rouge">size</code>.</li>
  <li><code class="highlighter-rouge">SetLike</code> does not make any further assumptions about the internals of the class using it.</li>
</ul>

<p>In particular, none of the methods in <code class="highlighter-rouge">SetLike</code> need to know that we are using a hash for internal storage. This draws a distinction between methods that do need to know that we have chosen to represent sets with hash tables (they go in the <code class="highlighter-rouge">SetMap</code> class), and methods that don’t need to know this (they go in the <code class="highlighter-rouge">SetLike</code> module), and thus encapsulates the internal state of a set in <code class="highlighter-rouge">SetMap</code>. As long as we keep the public interface of <code class="highlighter-rouge">SetMap</code> stable, we could just as well reimplement all its methods using a binary search tree instead of a hash for storing a set, say: <code class="highlighter-rouge">SetLike</code> will not care.</p>

<h3 id="operations-on-sets">Operations on sets</h3>

<p>We would like to implement the usual operations on sets, like <code class="highlighter-rouge">union</code>, <code class="highlighter-rouge">intersection</code>, and <code class="highlighter-rouge">difference</code>. Since they all follow essentially the same pattern, we focus on just one of them, <code class="highlighter-rouge">union!</code> (the  destructive version of <code class="highlighter-rouge">union</code>).</p>

<p>Following the example established by Ruby’s <a href="https://github.com/ruby/ruby/blob/trunk/lib/set.rb"><code class="highlighter-rouge">Set</code> class</a>, we first implement a helper method <code class="highlighter-rouge">SetLike#do_with</code> that yields to a block:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">do_with</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
  <span class="k">unless</span> <span class="n">other</span><span class="p">.</span><span class="nf">instance_of?</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="nf">class</span><span class="p">)</span>
    <span class="k">raise</span> <span class="no">SetError</span><span class="p">,</span> <span class="s2">"</span><span class="si">#{</span><span class="nb">self</span><span class="p">.</span><span class="nf">class</span><span class="si">}</span><span class="s2"> instance needed"</span>
  <span class="k">end</span>

  <span class="k">return</span> <span class="n">other</span><span class="p">.</span><span class="nf">each</span> <span class="k">unless</span> <span class="nb">block_given?</span>
  <span class="n">other</span><span class="p">.</span><span class="nf">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="o">|</span> <span class="k">yield</span><span class="p">([</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">])</span> <span class="p">}</span>
<span class="k">end</span>
<span class="kp">private</span> <span class="ss">:do_with</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>This methods takes care of the type-checking for us. We would not, e.g., want to subtract a fuzzy set from a classical set, as the result will not in general be a classical set. The above guard clause ensures that the operations we will define are only carried out for two objects that belong to the same target class. Beyond this, <code class="highlighter-rouge">do_with</code> simply yields the key-value pairs of the set passed to it as an argument. Using <code class="highlighter-rouge">do_with</code>, we implement <code class="highlighter-rouge">union!</code> as follows:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">union!</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
  <span class="n">do_with</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">key</span><span class="p">,</span> <span class="n">_</span><span class="o">|</span>
    <span class="nb">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">self</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">other</span><span class="p">[</span><span class="n">key</span><span class="p">]].</span><span class="nf">max</span>
  <span class="k">end</span>
  <span class="nb">self</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>The union of a given set with another one is defined by maximizing scores for given keys across the two sets. This is how the union is usually defined, and it yields the expected results.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8</pre></td><td class="code"><pre><span class="c1"># SetMap::from_hash(hsh) creates a new set instance and populates it</span>
<span class="c1"># with the key-value pairs from the given hash `hsh`</span>

<span class="n">multi_set1</span> <span class="o">=</span> <span class="no">MultiSet</span><span class="p">.</span><span class="nf">from_hash</span><span class="p">(</span><span class="mi">2</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span> <span class="o">=&gt;</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">multi_set2</span> <span class="o">=</span> <span class="no">MultiSet</span><span class="p">.</span><span class="nf">from_hash</span><span class="p">(</span><span class="mi">2</span> <span class="o">=&gt;</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">multi_set1</span><span class="p">.</span><span class="nf">union!</span><span class="p">(</span><span class="n">multi_set2</span><span class="p">)</span>

<span class="n">multi_set1</span> <span class="o">==</span> <span class="no">MultiSet</span><span class="p">.</span><span class="nf">from_hash</span><span class="p">(</span><span class="mi">2</span> <span class="o">=&gt;</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="o">=&gt;</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># true</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p><code class="highlighter-rouge">union!</code> implements a notion of “combining what is contained in two given sets”. There is a similar, yet slightly different notion which is interesting from the perspective of our polymorphic approach: the <em>sum</em> of two sets. So let’s briefly digress:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">sum!</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
  <span class="n">do_with</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="p">{</span> <span class="o">|</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="o">|</span> <span class="n">insert</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="p">}</span>
  <span class="nb">self</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>Rather than maximizing scores, as <code class="highlighter-rouge">union!</code> did, <code class="highlighter-rouge">sum!</code> adds the scores given by the other set to the scores of the receiver. For classical sets, <code class="highlighter-rouge">sum!</code> and <code class="highlighter-rouge">union!</code> amount to the very same thing:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10</pre></td><td class="code"><pre><span class="c1"># SetMap::[](*list) creates a new set instance and turns the</span>
<span class="c1"># members of `list` into keys of the new instance.</span>

<span class="n">set1</span> <span class="o">=</span> <span class="no">ClassicalSet</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="n">set2</span> <span class="o">=</span> <span class="no">ClassicalSet</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>

<span class="n">set3</span> <span class="o">=</span> <span class="no">ClassicalSet</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="n">set4</span> <span class="o">=</span> <span class="no">ClassicalSet</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>

<span class="n">set1</span><span class="p">.</span><span class="nf">union!</span><span class="p">(</span><span class="n">set2</span><span class="p">)</span> <span class="o">==</span> <span class="n">set3</span><span class="p">.</span><span class="nf">sum!</span><span class="p">(</span><span class="n">set4</span><span class="p">)</span> <span class="c1"># true</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>This is why Ruby’s own <code class="highlighter-rouge">Set</code> class simply defines <code class="highlighter-rouge">+</code> (the sum operator) to be an alias of <code class="highlighter-rouge">|</code> (the union operator). However, for other types of sets, sum and union are not always the same. This is because taking the maximum of two scores is not generally the same as summing up those two scores! For example:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11</pre></td><td class="code"><pre><span class="n">set1</span> <span class="o">=</span> <span class="no">FuzzySet</span><span class="p">.</span><span class="nf">from_hash</span><span class="p">(</span><span class="mi">2</span> <span class="o">=&gt;</span> <span class="mi">0</span><span class="o">.</span><span class="mi">4</span><span class="p">)</span>
<span class="n">set2</span> <span class="o">=</span> <span class="no">FuzzySet</span><span class="p">.</span><span class="nf">from_hash</span><span class="p">(</span><span class="mi">2</span> <span class="o">=&gt;</span> <span class="mi">0</span><span class="o">.</span><span class="mi">3</span><span class="p">)</span>

<span class="n">set3</span> <span class="o">=</span> <span class="no">FuzzySet</span><span class="p">.</span><span class="nf">from_hash</span><span class="p">(</span><span class="mi">2</span> <span class="o">=&gt;</span> <span class="mi">0</span><span class="o">.</span><span class="mi">4</span><span class="p">)</span>
<span class="n">set4</span> <span class="o">=</span> <span class="no">FuzzySet</span><span class="p">.</span><span class="nf">from_hash</span><span class="p">(</span><span class="mi">2</span> <span class="o">=&gt;</span> <span class="mi">0</span><span class="o">.</span><span class="mi">3</span><span class="p">)</span>

<span class="n">set1</span><span class="p">.</span><span class="nf">sum!</span><span class="p">(</span><span class="n">set2</span><span class="p">)</span>
<span class="n">set3</span><span class="p">.</span><span class="nf">union!</span><span class="p">(</span><span class="n">set4</span><span class="p">)</span>

<span class="n">set1</span> <span class="o">==</span> <span class="no">FuzzySet</span><span class="p">.</span><span class="nf">from_hash</span><span class="p">(</span><span class="mi">2</span> <span class="o">=&gt;</span> <span class="mi">0</span><span class="o">.</span><span class="mi">7</span><span class="p">)</span> <span class="c1"># true</span>
<span class="n">set3</span> <span class="o">==</span> <span class="no">FuzzySet</span><span class="p">.</span><span class="nf">from_hash</span><span class="p">(</span><span class="mi">2</span> <span class="o">=&gt;</span> <span class="mi">0</span><span class="o">.</span><span class="mi">4</span><span class="p">)</span> <span class="c1"># true</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>Our model captures all of this correctly.</p>

<h3 id="set-predicates">Set predicates</h3>

<p>A classical set $A$ is a subset of a classical set of $B$ if any element of $A$ is also an element of $B$. This can be expressed in terms of keys and their associated scores by saying that the score for any key in $A$ is less than or equal to the score for that same key in $B$. This definition also applies to multisets, and fuzzy sets, so that, again, a common implementation is possible. Here is a first stab at the <code class="highlighter-rouge">SetLike#subset?</code> method:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">subset?</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
  <span class="k">return</span> <span class="kp">false</span> <span class="k">unless</span> <span class="n">other</span><span class="p">.</span><span class="nf">instance_of?</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="nf">class</span><span class="p">)</span>

  <span class="n">all?</span> <span class="k">do</span> <span class="o">|</span><span class="n">key</span><span class="p">,</span> <span class="n">_</span><span class="o">|</span>
    <span class="nb">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">other</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
  <span class="k">end</span>
<span class="k">end</span>
<span class="k">alias</span> <span class="o">&lt;=</span> <span class="n">subset?</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>Following the pattern established by the <code class="highlighter-rouge">do_with</code> method discussed above, however, it makes sense to extract the “key comparison” functionality to a separate <code class="highlighter-rouge">compare_with?</code> method that takes a block (you may want to check out the <a href="https://github.com/maraigue/multiset/blob/master/lib/multiset.rb">code of the multiset gem</a>—the gem author does exactly this).</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">keys</span>
  <span class="n">each</span><span class="p">.</span><span class="nf">map</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:first</span><span class="p">)</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">compare_with?</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
  <span class="k">return</span> <span class="kp">false</span> <span class="k">unless</span> <span class="n">other</span><span class="p">.</span><span class="nf">instance_of?</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="nf">class</span><span class="p">)</span>

  <span class="p">(</span><span class="n">keys</span> <span class="o">|</span> <span class="n">other</span><span class="p">.</span><span class="nf">keys</span><span class="p">).</span><span class="nf">all?</span> <span class="k">do</span> <span class="o">|</span><span class="n">key</span><span class="o">|</span>
    <span class="k">yield</span><span class="p">(</span><span class="nb">self</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">other</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>According to line 2 above, the keys of a set object are given by the first component of each key-value pair. <code class="highlighter-rouge">SetLike#compare_with?</code> then iterates over the keys of both <code class="highlighter-rouge">self</code> and <code class="highlighter-rouge">other</code>, and yields the corresponding values to the block. This allows us to implement <code class="highlighter-rouge">subset?</code> as follows:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">subset?</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
  <span class="n">compare_with?</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">s</span><span class="p">,</span> <span class="n">o</span><span class="o">|</span>
    <span class="n">s</span> <span class="o">&lt;=</span> <span class="n">o</span>
  <span class="k">end</span>
<span class="k">end</span>
<span class="k">alias</span> <span class="o">&lt;=</span> <span class="n">subset?</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>Definitions for the other common set predicates (<code class="highlighter-rouge">proper_subset?</code>, <code class="highlighter-rouge">superset?</code> and <code class="highlighter-rouge">proper_superset?</code>) are similar, so we omit them here.</p>

<h3 id="equivalence">Equivalence</h3>

<p>When are two sets $A$ and $B$ the same? Again, there is an answer that works for all three target classes: the two sets should be in a mutual inclusion relation, i.e., $A$ should be a subset of $B$, and $B$ a subset of $A$. However, invoking <code class="highlighter-rouge">subset?</code> twice seems slightly redundant, since in the worst case, this amounts to performing every comparison twice. Using the <code class="highlighter-rouge">compare_with?</code> method defined above, we can more simply write the following code:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">equivalent?</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
  <span class="n">compare_with?</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">s</span><span class="p">,</span> <span class="n">o</span><span class="o">|</span>
    <span class="n">s</span> <span class="o">==</span> <span class="n">o</span>
  <span class="k">end</span>
<span class="k">end</span>
<span class="k">alias</span> <span class="o">==</span> <span class="n">equivalent?</span>
<span class="k">alias</span> <span class="nb">eql?</span> <span class="n">equivalent?</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>Notice that we have aliassed the <code class="highlighter-rouge">equivalent?</code> method both as <code class="highlighter-rouge">==</code> and <code class="highlighter-rouge">eql?</code>. We have already taken the <code class="highlighter-rouge">==</code> method for granted in some earlier snippets. Now what about <code class="highlighter-rouge">eql?</code>? This brings us to our final topic for today:</p>

<h3 id="nested-sets">Nested sets</h3>

<p>Unless overridden, the <code class="highlighter-rouge">Object#eql?</code> method considers two objects to be the same if they are identical (i.e., are stored at the same location in memory). In the current context, overriding <code class="highlighter-rouge">Object#eql?</code> is critical, because <code class="highlighter-rouge">eql?</code> is the method that Ruby uses when accessing hash keys. Let’s leave the context of our <code class="highlighter-rouge">SetLike</code> module for a moment, and consider this line of Ruby code:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre><span class="n">some_hash</span><span class="p">[</span><span class="n">some_obj</span><span class="p">]</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>When executing this line, Ruby will check if there is a key <code class="highlighter-rouge">key</code> to be found in <code class="highlighter-rouge">some_hash</code> with the property that <code class="highlighter-rouge">some_obj.eql?(key)</code>. If so, the value for <code class="highlighter-rouge">key</code> will be returned.</p>

<p>For our purposes, this process of looking up keys in a hash is crucial because (1) we are using hashes for storing set membership information, and (2) we would like to be able to model <em>nested</em> sets, which are sets that have sets among their keys. Consider:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9</pre></td><td class="code"><pre><span class="c1"># SetMap::[](*list) creates a new set instance and turns the</span>
<span class="c1"># members of `list` into keys of the new instance.</span>

<span class="n">set1</span> <span class="o">=</span> <span class="no">ClassicalSet</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="n">set2</span> <span class="o">=</span> <span class="no">ClassicalSet</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="n">set3</span> <span class="o">=</span> <span class="no">ClassicalSet</span><span class="p">[</span><span class="n">set1</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="n">set4</span> <span class="o">=</span> <span class="no">ClassicalSet</span><span class="p">[</span><span class="n">set2</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>

<span class="n">set3</span> <span class="o">==</span> <span class="n">set4</span> <span class="c1">#=&gt; ?</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>Now the question is whether <code class="highlighter-rouge">set3</code> and <code class="highlighter-rouge">set4</code> are the same set. It seems that the answer should be yes, because, after all, they <em>contain the same elements</em>. Assume, however, for a moment that we had not overridden <code class="highlighter-rouge">eql?</code>. Then <code class="highlighter-rouge">set3</code> and <code class="highlighter-rouge">set4</code> do <em>not</em> come out the same in the sense of <code class="highlighter-rouge">==</code> because <code class="highlighter-rouge">set1</code> and <code class="highlighter-rouge">set2</code> do not reference the same object, which implies that <code class="highlighter-rouge">set3[set1] == set4[set1]</code> will return false, for the simple reason that <code class="highlighter-rouge">set1</code> is not considered a key in the set <code class="highlighter-rouge">other</code>, since it is not the case that <code class="highlighter-rouge">set2.eql?(set1)</code>. So overriding <code class="highlighter-rouge">eql?</code>, like we did above, is indeed critical.</p>

<h3 id="the-hash-method">The <code class="highlighter-rouge">hash</code> method</h3>

<p>As a final aside: For our set comparisons to work, we also need to override the <code class="highlighter-rouge">Object#hash</code> method so as to ensure that two set objects that are <code class="highlighter-rouge">eql?</code> have the same return value when <code class="highlighter-rouge">hash</code> is called on them. This can be achieved, e.g., like this:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">hash</span>
  <span class="n">each</span><span class="p">.</span><span class="nf">map</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:hash</span><span class="p">).</span><span class="nf">sum</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>Here, we simply map each key-value pair (a two-element array) yielded by <code class="highlighter-rouge">each</code> to its <code class="highlighter-rouge">hash</code> value and sum up the result, trusting that <code class="highlighter-rouge">Array#hash</code> is implemented in a meaningful way. And this indeed ensures that <code class="highlighter-rouge">eql?</code> sets have the same <code class="highlighter-rouge">hash</code> return value.</p>

<h3 id="coda">Coda</h3>

<p>What has been achieved? As mentioned at the beginning of the post, the set functionality that we have discussed is either readily available as part of Ruby’s Standard Library (for classical sets), or via an easily accesible Ruby gem (for multisets). However, the code presented here presents a <em>uniform</em> perspective on classical sets and multisets. While I have written <code class="highlighter-rouge">SetMap</code> and its child classes as an exercise for myself, I consider this uniformity an advantage over the pre-existing implementation. We have also seen how easily the approach generalizes to further use cases by considering fuzzy sets.</p>

<p>This has been a long post. I hope I have not overstretched the limits of your patience. While coming up with a first working implementation of the types of sets discussed here was pretty straightforward, arriving at a way to structure and modularize my code that I found convincing myself required me to go back to the drawing board several times. If you have a chance to <a href="https://github.com/benrodenhaeuser/sets">check out my code</a>, your feedback would be greatly appreciated.</p>

      <div class="pad"></div><hr class="line" /><div class="triplepad"></div>
      
      <small>06 July 2017</small>
      <p>The following characterizations come from <a href="http://javadude.com/articles/passbyvalue.htm">this article</a> and are quoted verbatim.</p>

<ul>
  <li><em>Pass-by-value:</em> “The actual parameter (or argument expression) is fully evaluated and the resulting value is <em>copied</em> into a location being used to hold the formal parameter’s value during method/function execution. That location is typically a chunk of memory on the runtime stack for the application (which is how Java handles it), but other languages could choose parameter storage differently.”</li>
  <li><em>Pass-by-reference:</em> “The formal parameter merely acts as an <em>alias</em> for the actual parameter. Anytime the method/function uses the formal parameter (for reading or writing), it is actually using the actual parameter.”</li>
</ul>

<p>Why is the latter called “pass-by-reference”?</p>

<blockquote>
  <p>In programming language design (…) a “reference” is an alias to another variable. Any manipulation done to the reference variable directly changes the original variable.</p>
</blockquote>

<p>What is the consequence of this? If <code class="highlighter-rouge">a</code> acts as an alias for <code class="highlighter-rouge">b</code> in the above sense, then reassigning <code class="highlighter-rouge">a</code> will have the effect of reassigning <code class="highlighter-rouge">b</code>: suppose that <code class="highlighter-rouge">a</code> points to the integer <code class="highlighter-rouge">5</code>, and <code class="highlighter-rouge">b</code> is an alias for <code class="highlighter-rouge">b</code>. Then setting <code class="highlighter-rouge">b = 7</code> will make both <code class="highlighter-rouge">a</code> and <code class="highlighter-rouge">b</code> point to <code class="highlighter-rouge">7</code>, because <code class="highlighter-rouge">a</code> and <code class="highlighter-rouge">b</code> are one and the same variable.</p>

<p>So we can think of the pass-by-reference strategy as passing the variable directly into the procedure: there is really only one variable, and one value the variable is bound to. Anything that the procedure does that affects either the variable or its value will be visible to the caller.</p>

<h2 id="an-additional-distinction">An additional distinction</h2>

<p>Ruby does not use pass-by-reference. It uses pass-by-value. However, to get a better grip on object passing in Ruby, it is useful to distinguish two varieties of pass-by-value: “pass-value-by-value”, and “pass-reference-by-value”. This terminology comes from <a href="http://robertheaton.com/2014/07/22/is-ruby-pass-by-reference-or-pass-by-value/">this article</a>, from which the following explanation heavily borrows:</p>

<ol>
  <li><em>Pass-value-by-value:</em> In pass-value-by-value, the procedure receives a <em>copy of the objects</em> passed to it. There is thus no relationship between either the variables or the objects referenced by the values by the function and the caller. Nothing that happens to one will affect the other.</li>
  <li><em>Pass-reference-by-value:</em> On the pass-reference-by-value model, a procedure receives a reference to the same object in memory that is used by the caller, i.e., caller and callee <em>share</em> the object. However, the variable the procedure uses is <em>not</em> merely an alias for the variable used by the caller. The procedure has its own (“fresh”) variable, which merely happens to point to the same object as the caller variable. This means that changes made to the <em>object</em> made inside the procedure will be visible to the caller. But changes made to the <em>variable</em> inside the procedure will not be.</li>
</ol>

<p>How does Ruby do it? <em>Ruby follows the second model.</em> So the variable passed into a Ruby method is not a “complete alias” for the original variable. It is distinct. But the method variable and the variable used by the caller <em>share a single value</em>.</p>

<h2 id="examples">Examples</h2>

<p>Let’s see the consequences of this with two examples. First, contrast Ruby with the pass-by-reference model.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">reassign</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
  <span class="n">array</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">]</span>
<span class="k">end</span>

<span class="n">array</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">reassign</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
<span class="n">array</span> <span class="c1">#=&gt; [1]</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>In this example, the <code class="highlighter-rouge">reassign</code> method reassigns the variable it receives to another object. In a pass-by-reference language, this would have the effect of reassigning the caller variable <code class="highlighter-rouge">array</code> as well (because the variable used by the caller and the variable used by the method are <em>the same</em>, except for the superficial property of not having the same name). But not so in Ruby: the method uses its own variable, distinct from the variable used by the caller.</p>

<p>So the last line of the above code evaluates to <code class="highlighter-rouge">[1]</code>, not to <code class="highlighter-rouge">[10]</code> as we would expect on the pass-by-reference model. <em>Reassigning a variable within a method will have no effect on the caller in Ruby.</em></p>

<p>Let’s now contrast Ruby with the pass-value-by-value strategy used by Java.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">mutate</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
  <span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">]</span>
<span class="k">end</span>

<span class="n">array</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">mutate</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
<span class="n">array</span> <span class="c1">#=&gt; [10]</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>In this example, the <code class="highlighter-rouge">mutate</code> method mutates the object it receives. In a pass-value-by-value language, this change would not be visible to the caller, since the object used by the method, and the object used by the caller are <em>distinct</em>. But not so in Ruby: the object is shared between caller variable and method variable, so the mutation of the array object will be visible to the caller.</p>

<p>As a consequence, the last line of the above code evaluates to <code class="highlighter-rouge">[10]</code>, not to <code class="highlighter-rouge">[1]</code> as we would expect on a pass-value-by-value model. <em>Mutating an object within a method will have an effect on the caller in Ruby.</em></p>

<h2 id="takeaway">Takeaway</h2>

<p>Ruby is not a <em>pass-by-reference</em> language, it is a <em>pass-by-value</em> language. But it is not a <em>pass-value-by-value</em> language, it’s <em>pass-reference-by-value</em>. Reassignment of a variable within a method will never affect the original variable that lives outside the method. On the other hand, mutating an object within a method will affect the original object outside the method, because those two objects are shared.</p>

      <div class="pad"></div><hr class="line" /><div class="triplepad"></div>
      
      <small>15 May 2017</small>
      <p>Ruby has two built-in methods for sorting collections: <code class="highlighter-rouge">sort</code> and <code class="highlighter-rouge">sort_by</code>. Both are contained in the <code class="highlighter-rouge">Enumerable</code> module, which any Ruby class can include as long as it implements a an <code class="highlighter-rouge">each</code> method for iterating over instances of the class. The elements of a collection also need to implement a three-way comparison method <code class="highlighter-rouge">&lt;=&gt;</code> (the “spaceship operator”) if we want to invoke <code class="highlighter-rouge">sort</code> or <code class="highlighter-rouge">sort_by</code> on that collection. My question for this post is this: why would there be two sort methods rather than just one?</p>

<h2 id="exploring-sort_by">Exploring <code class="highlighter-rouge">sort_by</code></h2>

<p>Let’s first try to get a clearer picture how <code class="highlighter-rouge">sort_by</code> works. Start with an example. Suppose we would like to sort the following array <em>by the numerical values</em> of its string elements:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre><span class="n">arr</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'0'</span><span class="p">,</span> <span class="s1">'10'</span><span class="p">,</span> <span class="s1">'3'</span><span class="p">]</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>This can be achieved using <code class="highlighter-rouge">sort_by</code> as follows:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2</pre></td><td class="code"><pre><span class="n">arr</span><span class="p">.</span><span class="nf">sort_by</span> <span class="p">{</span> <span class="o">|</span><span class="n">string</span><span class="o">|</span> <span class="n">string</span><span class="p">.</span><span class="nf">to_i</span> <span class="p">}</span>
<span class="c1"># =&gt; ['0', '3', '10']</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>Or using shorthand:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2</pre></td><td class="code"><pre><span class="n">arr</span><span class="p">.</span><span class="nf">sort_by</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:to_i</span><span class="p">)</span>
<span class="c1"># =&gt; ['0', '3', '10']</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>Now the question is: how does <code class="highlighter-rouge">sort_by</code> do its magic? My initial hunch when exploring this topic was that <code class="highlighter-rouge">sort_by</code> seems fairly closely related to the functionality provided by the <code class="highlighter-rouge">map</code> method, also contained in <code class="highlighter-rouge">Enumerable</code>. There is <a href="http://ruby-doc.org/core-2.4.1/Enumerable.html#method-i-sort_by">a hint in the Ruby Docs</a> that points in the same direction: “The current implementation of <code class="highlighter-rouge">sort_by</code> generates an array of tuples containing the original collection element and the mapped value.”</p>

<p>Based on this, it looks like what <code class="highlighter-rouge">sort_by</code> must be doing is something like this:</p>

<ol>
  <li>Transform the given array to an array of pairs (making use of the block that was passed).</li>
  <li>Sort the array of pairs by accessing the second component of each pair (relying on the <code class="highlighter-rouge">&lt;=&gt;</code> method defined for the second component).</li>
  <li>Project each pair to its first component.</li>
</ol>

<p>The result of step 3 is your sorted array.</p>

<p>After some Googling, I found out that this is actually a pretty well-known technique, often called <a href="https://en.wikipedia.org/wiki/Schwartzian_transform">Schwartzian transform</a> among Perl programmers. So it does look like <code class="highlighter-rouge">sort_by</code> works just in this way.</p>

<p>Let’s make things more concrete by implementing a toy version of <code class="highlighter-rouge">sort_by</code> ourselves. This will come in handy in the second part of the post, when we want to compare <code class="highlighter-rouge">sort</code> and <code class="highlighter-rouge">sort_by</code>. Plus it’s a nice exercise – when learning a language, it can be useful to re-implement methods of interest to deepen understanding, I have been told at <a href="http://launchschool.com">Launch School</a>.</p>

<p>First, we observe that we can actually express the above three steps in Ruby code fairly easily – this is where the <code class="highlighter-rouge">map</code> method comes into play. For our running example, observe that the sorted array can be obtained as follows:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4</pre></td><td class="code"><pre><span class="n">arr</span><span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">elem</span><span class="o">|</span> <span class="p">[</span><span class="n">elem</span><span class="p">,</span> <span class="n">elem</span><span class="p">.</span><span class="nf">to_i</span><span class="p">]</span> <span class="p">}</span> <span class="c1"># step (1)</span>
  <span class="p">.</span><span class="nf">sort</span> <span class="p">{</span> <span class="o">|</span><span class="n">pair1</span><span class="p">,</span> <span class="n">pair2</span><span class="o">|</span> <span class="n">pair1</span><span class="p">.</span><span class="nf">last</span> <span class="o">&lt;=&gt;</span> <span class="n">pair2</span><span class="p">.</span><span class="nf">last</span> <span class="p">}</span> <span class="c1"># step (2)</span>
  <span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">pair</span><span class="o">|</span> <span class="n">pair</span><span class="p">.</span><span class="nf">first</span> <span class="p">}</span> <span class="c1"># step (3)</span>
<span class="c1"># =&gt; ['0', '3', '10']</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>Notice that we have replaced the invocation of <code class="highlighter-rouge">sort_by</code> with calls to <code class="highlighter-rouge">map</code>, <code class="highlighter-rouge">sort</code> and <code class="highlighter-rouge">&lt;=&gt;</code>. This is obviously a lot more cumbersome than using <code class="highlighter-rouge">sort_by</code> itself – but it makes it fairly clear how our re-implementation of <code class="highlighter-rouge">sort_by</code> should look like. Here it is:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7</pre></td><td class="code"><pre><span class="k">module</span> <span class="nn">Enumerable</span>
  <span class="k">def</span> <span class="nf">my_sort_by</span>
    <span class="nb">self</span><span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">elem</span><span class="o">|</span> <span class="p">[</span><span class="n">elem</span><span class="p">,</span> <span class="k">yield</span><span class="p">(</span><span class="n">elem</span><span class="p">)]</span> <span class="p">}</span>
      <span class="p">.</span><span class="nf">sort</span> <span class="p">{</span> <span class="o">|</span><span class="n">pair1</span><span class="p">,</span> <span class="n">pair2</span><span class="o">|</span> <span class="n">pair1</span><span class="p">.</span><span class="nf">last</span> <span class="o">&lt;=&gt;</span> <span class="n">pair2</span><span class="p">.</span><span class="nf">last</span> <span class="p">}</span>
      <span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">pair</span><span class="o">|</span> <span class="n">pair</span><span class="p">.</span><span class="nf">first</span> <span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>Looking at the <a href="https://github.com/rubinius/rubinius/blob/f9c2dffa4c894eea88abe1e476688df549a2bc4b/core/enumerable.rb#L351">Rubinius code for <code class="highlighter-rouge">sort_by</code></a> – a hint I got from one of the instructors at Launch School when sharing a draft of this post – we see just this pattern: a <code class="highlighter-rouge">map</code> invocation followed by a <code class="highlighter-rouge">sort</code> invocation followed by a <code class="highlighter-rouge">map</code> invocation. Rubinius even has a special class for representing tuples of the required kind. It is called <code class="highlighter-rouge">SortedElement</code> and comes with a <code class="highlighter-rouge">&lt;=&gt;</code> method that compares instances based on the value of the second element of the tuple.</p>

<p>For our running example, <code class="highlighter-rouge">my_sort_by</code> yields the desired return value:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre><span class="n">arr</span><span class="p">.</span><span class="nf">my_sort_by</span> <span class="p">{</span> <span class="o">|</span><span class="n">elem</span><span class="o">|</span> <span class="n">elem</span><span class="p">.</span><span class="nf">to_i</span> <span class="p">}</span> <span class="c1"># =&gt; ['0', '3', '10']</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>Or, using shorthand:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre><span class="n">arr</span><span class="p">.</span><span class="nf">my_sort_by</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:to_i</span><span class="p">)</span> <span class="c1"># =&gt; ['0', '3', '10']</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>Let’s now return to our original question: why would Ruby have two sort methods rather than just one?</p>

<h2 id="the-cost-of-transformation">The cost of transformation</h2>

<p>It turns out that there is a reason for favouring <code class="highlighter-rouge">sort_by</code> over <code class="highlighter-rouge">sort</code>, at least in certain scenarios: efficiency.</p>

<p>Both <code class="highlighter-rouge">sort</code> and <code class="highlighter-rouge">sort_by</code> are based on comparisons of elements of the collection we want to sort. Comparison-based sorting <a href="https://www.cs.cmu.edu/~avrim/451f11/lectures/lect0913.pdf">has a lower bound of $O(n \log n)$</a>, which is to say that it is not possible to come up with a (comparison-based) sorting algorithm that performs better in a worst-case scenario. This is because, in the worst case, $n \log n$ comparisons of elements have to be made in order to determine the correct sort order. Ruby <a href="https://www.igvita.com/2009/03/26/ruby-algorithms-sorting-trie-heaps/">uses quicksort for sorting</a>, an algorithm that has a worst case complexity of $O(n^2)$, but runs in $O(n \log n)$ on average (as it turns out, $O(n \log n)$ is the lower bound for the average case as well, so quicksort is optimal for average cases).</p>

<p>Since quicksort is the algorithm powering both <code class="highlighter-rouge">sort</code> and <code class="highlighter-rouge">sort_by</code>, wouldn’t it be reasonable to think that both methods should have the same performance? The answer is no, and the reason is that the overall picture is complicated by the fact that we often do not wish to sort a given collection <em>as is</em> (i.e., relying on the <code class="highlighter-rouge">&lt;=&gt;</code> operator provided for its elements), but rather relying on some special “property” of its elements, i.e., a sort criterion, or <em>sort key</em>. For example, we may want to sort user profiles by users’ last names, or available moves in a game by their expected utility – or strings by integer value, as in our running example above. The last name, the expected utility, the integer value – those would be our sort keys.</p>

<p>Now unless the sort keys are simply given to us along with the values we want to sort, we will have to compute those keys ourselves. This takes time above and beyond the actual sorting. And this is where <code class="highlighter-rouge">sort</code> and <code class="highlighter-rouge">sort_by</code> differ.</p>

<p>Both of these methods allow us to do key-based sorting by passing a block with the method invocation. Suppose we have a method <code class="highlighter-rouge">key</code> that transforms the elements of a collection <code class="highlighter-rouge">list</code> to sort keys of the required kind (in our running example, the relevant transformation is simply to convert strings to integers, because numeric values are what we want to sort by). Then we can sort our list with the <code class="highlighter-rouge">sort</code> method as follows:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre><span class="n">list</span><span class="p">.</span><span class="nf">sort</span> <span class="p">{</span> <span class="o">|</span><span class="n">elem1</span><span class="p">,</span> <span class="n">elem2</span><span class="o">|</span> <span class="n">key</span><span class="p">(</span><span class="n">elem1</span><span class="p">)</span> <span class="o">&lt;=&gt;</span> <span class="n">key</span><span class="p">(</span><span class="n">elem2</span><span class="p">)</span> <span class="p">}</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>Using <code class="highlighter-rouge">sort_by</code>, as we have seen above, we would do it like this:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre><span class="n">list</span><span class="p">.</span><span class="nf">sort_by</span> <span class="p">{</span> <span class="o">|</span><span class="n">elem</span><span class="o">|</span> <span class="n">key</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span> <span class="p">}</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>It looks like using <code class="highlighter-rouge">sort_by</code> saves us a little bit of typing. But we are also saving a lot of computation steps, potentially. Remember from above: what is happening “under the hood” when we invoke <code class="highlighter-rouge">sort_by</code> in the way just described is something like this:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3</pre></td><td class="code"><pre><span class="n">list</span><span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">elem</span><span class="o">|</span> <span class="p">[</span><span class="n">elem</span><span class="p">,</span> <span class="n">key</span><span class="p">(</span><span class="n">elem</span><span class="p">)]</span> <span class="p">}</span>
    <span class="p">.</span><span class="nf">sort</span> <span class="p">{</span> <span class="o">|</span><span class="n">pair1</span><span class="p">,</span> <span class="n">pair2</span><span class="o">|</span> <span class="n">pair1</span><span class="p">.</span><span class="nf">last</span> <span class="o">&lt;=&gt;</span> <span class="n">pair2</span><span class="p">.</span><span class="nf">last</span> <span class="p">}</span>
    <span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">pair</span><span class="o">|</span> <span class="n">pair</span><span class="p">.</span><span class="nf">first</span> <span class="p">}</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>Clearly, this procedure involves $n$ calls to the <code class="highlighter-rouge">key</code> method, assuming that the length of <code class="highlighter-rouge">list</code> is $n$: we call <code class="highlighter-rouge">key</code> once for each element <code class="highlighter-rouge">elem</code> of <code class="highlighter-rouge">list</code>, storing the pair <code class="highlighter-rouge">[elem, key(elem)]</code> in our intermediate array. However, when using <code class="highlighter-rouge">sort</code>, the number of calls to the <code class="highlighter-rouge">key</code> method may be quite a bit larger. As observed earlier, sorting our list involves making $O(n\log n)$ comparisons on average, and even $O(n^2)$ comparisons in the worst case (since quicksort is Ruby’s search algorithm of choice). If we use <code class="highlighter-rouge">sort</code>, each such comparison will require two <em>on the fly</em> calls to the <code class="highlighter-rouge">key</code> method. In cases where <code class="highlighter-rouge">key</code> itself is a time-consuming transformation, having to perform it $O(n\log n)$ times (or even $O(n^2)$, in the worst case) rather than merely $O(n)$ times will make a big difference indeed.</p>

<p>So computing the keys ahead of time, and saving them for later use – as <code class="highlighter-rouge">sort_by</code> does, a technique known as <a href="https://en.wikipedia.org/wiki/Memoization">memoization</a> – may come with a significant performance gain over computing the keys on an as-needed basis, as <code class="highlighter-rouge">sort</code> does. If, on the other hand, the transformation is trivial, <code class="highlighter-rouge">sort</code> may still be faster than <code class="highlighter-rouge">sort_by</code> – the time saved by avoiding calls to the <code class="highlighter-rouge">key</code> method may then be more than offset by the effort of calling <code class="highlighter-rouge">map</code> twice. The Ruby Docs for <code class="highlighter-rouge">sort_by</code> <a href="http://ruby-doc.org/core-2.4.1/Enumerable.html#method-i-sort_by">give an example of this</a>. So, as usual, there are trade-offs involved.</p>

<p><em>Thanks to Pete Hanson from Launch School for valuable information on the topic of this post.</em></p>

      <div class="pad"></div><hr class="line" /><div class="triplepad"></div>
       -->

      </section>
      <header>
  <small>&nbsp;</small>
  <a href="http://notes.benrodenhaeuser.io">
    <h1 class="title">
      Ben Rodenhäuser
    </h1>
  </a>

  <div class="description">
    Notes on programming.
  </div>

  <div class="content">
    <hr class="line" />
    <div class="sidebar-content-inner">


        

            <h2 class="sidebar">
              <a class="post-link" href="/2018/03/07/understanding-sinatra/">Understanding Sinatra</a><span class="pad"></span><small>07 Mar 2018</small>
            </h2>
            <div class="sidebar-description">
              Building a toy version of a popular Ruby framework from the ground up.
            </div>
        

            <h2 class="sidebar">
              <a class="post-link" href="/2017/12/18/a-bunch-of-sets/">A Bunch of Sets</a><span class="pad"></span><small>18 Dec 2017</small>
            </h2>
            <div class="sidebar-description">
              A uniform implementation of classical sets, multisets and fuzzy sets, based on a generic set class.
            </div>
        

            <h2 class="sidebar">
              <a class="post-link" href="/2017/07/06/object-passing/">Passing Objects</a><span class="pad"></span><small>06 Jul 2017</small>
            </h2>
            <div class="sidebar-description">
              Pass by reference or pass by value? A characterization of the object passing strategy followed by Ruby.
            </div>
        

            <h2 class="sidebar">
              <a class="post-link" href="/2017/05/15/sorting-in-ruby/">Sorting in Ruby</a><span class="pad"></span><small>15 May 2017</small>
            </h2>
            <div class="sidebar-description">
              Why does Ruby have two sorting methods, rather than one?
            </div>
        

    </div>
    <hr class="line" />

    <div class="external">
      <a href="http://github.com/benrodenhaeuser">
        <img class="mark" src="/assets/images/GitHub-Mark-64px.png" />
      </a>
    </div>
    <!-- <p><small><a href="http://github.com/benrodenhaeuser">GitHub Profile</a></small></p> -->
  </div>
</header>

      <!-- <footer>
  <p><small>Ben Rodenhäuser 2017 | <a href="http://github.com/benrodenhaeuser">GitHub Profile</a></small></p>
</footer> -->

    </div>
    <script src="/assets/js/scale.fix.js"></script>
  </body>
</html>
