<!doctype html>
<html lang="en-US">
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <title>Ben Rodenhäuser</title>

  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Roboto+Mono" rel="stylesheet">
  <link rel="stylesheet" href="/assets/css/style.css?v=">
  <script type="text/javascript"
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML&delayStartupUntilConfig">
  </script>
  <script src="/assets/jax/config.js"></script>

  <meta name="viewport" content="width=device-width">
  <!--[if lt IE 9]>
  <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  
    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-99334571-1', 'auto');
        ga('send', 'pageview');
    </script>
  
</head>

  <body>
    <div class="wrapper">
      <section>
      <!--  -->
      
      <small>02 December 2017</small>
      <h1 id="a-bag-of-sets">A Bag of Sets</h1>

<p><a href="https://pdxwolfy.wordpress.com">Pete</a> mentioned Ruby’s Set library the other day on the Slack channel, and how it internally uses a hash to store the elements of a set. He also pointed out that hashes can be used for representing multisets (or <em>bags</em>, as multisets are also called). This piqued my interest.</p>

<p>More specifically, I thought that it should be possible to have <code class="highlighter-rouge">Set</code> and <code class="highlighter-rouge">Bag</code> classes share a lot, even most of the same code, as an exercise in <a href="http://www.stroustrup.com/glossary.html#Gpolymorphism">polymorphism</a>.</p>

<p>After all, bags and sets have pretty much the same interface:</p>

<ul>
  <li>we can <em>add</em> elements to, or <em>delete</em> elements from a bag, same as from a set,</li>
  <li>bags can be <em>subsets</em>, or <em>supersets</em> of one another, just as sets,</li>
  <li>we can take the <em>union</em>, <em>intersection</em>, or <em>difference</em> of two bags, just as we can for two sets.</li>
</ul>

<p>The main difference between the two lies in how they count, so this should be the only point were we need code that is specific to each type of object. This post is an account of how I implemented this idea.</p>

<h2 id="sets-and-bags">Sets and bags</h2>

<p>Sets are unordered collections for which element count does not matter. So</p>

<ul>
  <li>$\lbrace a, b, c\rbrace$ and $\lbrace a, c, b\rbrace$ represent the same set (since order does not matter),</li>
  <li>$\lbrace a, b, c\rbrace$ and $\lbrace a, b, c, c\rbrace$ represent the same set (since element count does not matter).</li>
</ul>

<!-- A first smal digression is in order here. Notice that the preceding examples suggest that $\lbrace a, b, c, c\rbrace$ is a perfectly legal set, which is, however, set-theoretically equivalent to the more canonical representation $\lbrace a, b, c\rbrace$. This is not the only perspective one can take on the matter. There is another view according to which "the same element shall not be allowed to appear more than once" in a set. According to that view, $\lbrace a, b, c, c\rbrace$ would not even be a set! However, for our purposes, it is more natural to take the liberal stance of allowing sets with repeated occurences of elements like $\lbrace a, c, b\rbrace$ while identifying them $\lbrace a, c, b\rbrace$. One reason why this is more natural is that it is pretty much how our implementation of sets will turn out to work. -->

<p>For bags, on the other hand, element count does matter. That is,</p>

<ul>
  <li>$\lbrace a, b, c\rbrace$ and $\lbrace a, c, b\rbrace$ represent the same bag, since order (still) does not matter,</li>
  <li>but $\lbrace a, b, c\rbrace$ and $\lbrace a, b, c, c\rbrace$ <em>do not</em> represent the same bag.</li>
</ul>

<p>The number of times an element occurs in a bag is called the <em>multiplicity</em> of that element, and the size of the bag is the sum of the multiplicity of its elements.</p>

<h2 id="characteristic-functions-and-multiplicity-functions">Characteristic functions and multiplicity functions</h2>

<p>Sets whose elements are drawn from a given domain (i.e., another set) can be represented by what is called a <em>characteristic function</em>, which specifies for each element of the domain whether it is an element of the set in question.</p>

<p>Suppose that our domain is the characters in the Roman alphabet. Then we can represent the set $\lbrace a, b, c\rbrace$ by means of the function that maps the characters $a$, $b$ and $c$ to $1$ (indicating that they are elements of the set), while mapping all other characters to $0$ (indicating that they are not elements of the set). So sets can be defined as maps from a given universe of objects to the set $\lbrace 0, 1\rbrace$.</p>

<p>This approach can be generalized to bags. Instead of mapping elements to either one of $0$ or $1$, we map them to their element count in the bag. This means that the bag $\lbrace a, b, c, c\rbrace$ would be defined by the function that maps $a$ and $b$ to $1$, $c$ to $2$, and all other characters in the Roman alphabet to $0$.</p>

<p>Such a function is called a multiplicity function.</p>

<p>This perspective on the matter is useful for our purposes for two reasons. First, a characteristic function (be it for a set or a bag) can be neatly captured by a hash table, which is just what we are after. Second, viewing sets and bags through the lens of characteristic functions paves the way towards implementing operations on both types of objects in a uniform way.</p>

<p>As an example, consider the union operation. For two sets given by their characteristic function.</p>

<h2 id="setting-up-the-bag-and-set-classes">Setting up the Bag and Set classes</h2>

<p>Let’s start with the basic setup of our <code class="highlighter-rouge">Bag</code> and <code class="highlighter-rouge">Set</code> classes. We will expand the capabilities of both classes as we go along.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Bag</span>
  <span class="kp">include</span> <span class="no">Enumerable</span>

  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">enum</span> <span class="o">=</span> <span class="p">[])</span>
    <span class="vi">@hash</span> <span class="o">=</span> <span class="no">Hash</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">merge</span><span class="p">(</span><span class="n">enum</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">indicator</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
    <span class="vi">@hash</span><span class="p">[</span><span class="n">elem</span><span class="p">]</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">count</span><span class="p">(</span><span class="n">elem</span> <span class="o">=</span> <span class="kp">nil</span><span class="p">)</span>
    <span class="n">elem</span> <span class="p">?</span> <span class="n">indicator</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span> <span class="p">:</span> <span class="n">size</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">each</span>
    <span class="k">return</span> <span class="n">to_enum</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:each</span><span class="p">)</span> <span class="k">unless</span> <span class="nb">block_given?</span>
    <span class="vi">@hash</span><span class="p">.</span><span class="nf">each_key</span> <span class="p">{</span> <span class="o">|</span><span class="n">elem</span><span class="o">|</span> <span class="n">count</span><span class="p">(</span><span class="n">elem</span><span class="p">).</span><span class="nf">times</span> <span class="p">{</span> <span class="k">yield</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span> <span class="p">}</span> <span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Set</span> <span class="o">&lt;</span> <span class="no">Bag</span>
  <span class="k">def</span> <span class="nf">indicator</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
    <span class="vi">@hash</span><span class="p">[</span><span class="n">elem</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">?</span> <span class="mi">1</span> <span class="p">:</span> <span class="mi">0</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>As announced, we use a hash, referenced by the instance variable <code class="highlighter-rouge">@hash</code>, as an internal storage device for <code class="highlighter-rouge">Bag</code> objects. The intent is that <code class="highlighter-rouge">@hash[elem] == 0</code> indicates that a given <code class="highlighter-rouge">elem</code> is <em>not</em> a member of our collection, while <code class="highlighter-rouge">@hash[elem] &gt; 0</code> indicates that <code class="highlighter-rouge">elem</code> <em>is</em> a member of our collection.</p>

<p>The intent is that the presence of a particular hash key indicates that the object given by the key is part of the set, and the value for a particular key indicates the count of the object.</p>

<p>For plain sets, this is really all we need to know. For multisets, or bags, as they are also called, their count also matters. The count will be given by the value stored in a hash for a particular key. To see how this works out, lets implement a couple more methods.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9</pre></td><td class="code"><pre><span class="n">enum</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="n">set</span> <span class="o">=</span> <span class="no">Set</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">enum</span><span class="p">)</span>
<span class="n">bag</span> <span class="o">=</span> <span class="no">Bag</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">enum</span><span class="p">)</span>

<span class="n">set</span><span class="p">.</span><span class="nf">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">elem</span><span class="o">|</span> <span class="nb">puts</span> <span class="n">elem</span> <span class="p">}</span> <span class="c1"># output: 1 2 3</span>
<span class="n">bag</span><span class="p">.</span><span class="nf">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">elem</span><span class="o">|</span> <span class="nb">puts</span> <span class="n">elem</span> <span class="p">}</span> <span class="c1"># output: 1 2 3 3</span>

<span class="n">set</span><span class="p">.</span><span class="nf">count</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="c1">#=&gt; 1</span>
<span class="n">bag</span><span class="p">.</span><span class="nf">count</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="c1">#=&gt; 2</span>
</pre></td></tr></tbody></table>
</div>
</div>

<h2 id="topics-for-discussion">Topics for discussion</h2>

<ul>
  <li>definition of <code class="highlighter-rouge">count</code> in terms of <code class="highlighter-rouge">indicator</code></li>
  <li>illustrate the consequences: <code class="highlighter-rouge">each</code></li>
  <li>set interface: like multiset, but don’t care about values in internal hash –
override <code class="highlighter-rouge">count</code> method</li>
  <li>interface difference: each: yield without repetitions</li>
  <li>use of eql? and hash methods</li>
  <li>set equality can be defined in terms of subset relation</li>
</ul>

<p>Maybe build both classes (bag and set) as we go?</p>

<p>… For recapitulation, this is the code we have so far:</p>

      <div class="pad"></div><hr class="line" /><div class="triplepad"></div>
      
      <small>28 October 2017</small>
      <h1 id="on-subproblems">On Subproblems</h1>

<h2 id="subroutines">Subroutines</h2>

<p>Breaking down a problem into smaller pieces necessary to solve it.</p>

<p>Big problems as collections of small problems.</p>

<p>Subroutines!</p>

<h2 id="subinstances">Subinstances</h2>

<ul>
  <li>Non-overlapping subproblems:
    <ul>
      <li>Mergesort</li>
    </ul>
  </li>
  <li>Overlapping subproblems:
    <ul>
      <li>Fibonacci</li>
      <li>TicTacToe</li>
      <li>Dynamic Programming</li>
    </ul>
  </li>
</ul>

<h2 id="objects">Objects</h2>

<p>=&gt; Objects break down a problem into “responsibilities”.</p>

      <div class="pad"></div><hr class="line" /><div class="triplepad"></div>
      
      <small>06 July 2017</small>
      <h1 id="object-passing-in-ruby">Object Passing in Ruby</h1>

<p>The following is a characterization of the object passing strategy followed by Ruby.</p>

<h2 id="pass-by-reference-vs-pass-by-value">Pass-by-reference vs pass-by-value</h2>

<p>The following characterizations come from <a href="http://javadude.com/articles/passbyvalue.htm">this article</a> and are quoted verbatim.</p>

<ul>
  <li><em>Pass-by-value:</em> “The actual parameter (or argument expression) is fully evaluated and the resulting value is <em>copied</em> into a location being used to hold the formal parameter’s value during method/function execution. That location is typically a chunk of memory on the runtime stack for the application (which is how Java handles it), but other languages could choose parameter storage differently.”</li>
  <li><em>Pass-by-reference:</em> “The formal parameter merely acts as an <em>alias</em> for the actual parameter. Anytime the method/function uses the formal parameter (for reading or writing), it is actually using the actual parameter.”</li>
</ul>

<p>Why is the latter called “pass-by-reference”?</p>

<blockquote>
  <p>In programming language design (…) a “reference” is an alias to another variable. Any manipulation done to the reference variable directly changes the original variable.</p>
</blockquote>

<p>What is the consequence of this? If <code class="highlighter-rouge">a</code> acts as an alias for <code class="highlighter-rouge">b</code> in the above sense, then reassigning <code class="highlighter-rouge">a</code> will have the effect of reassigning <code class="highlighter-rouge">b</code>: suppose that <code class="highlighter-rouge">a</code> points to the integer <code class="highlighter-rouge">5</code>, and <code class="highlighter-rouge">b</code> is an alias for <code class="highlighter-rouge">b</code>. Then setting <code class="highlighter-rouge">b = 7</code> will make both <code class="highlighter-rouge">a</code> and <code class="highlighter-rouge">b</code> point to <code class="highlighter-rouge">7</code>, because <code class="highlighter-rouge">a</code> and <code class="highlighter-rouge">b</code> are one and the same variable.</p>

<p>So we can think of the pass-by-reference strategy as passing the variable directly into the procedure: there is really only one variable, and one value the variable is bound to. Anything that the procedure does that affects either the variable or its value will be visible to the caller.</p>

<h2 id="an-additional-distinction">An additional distinction</h2>

<p>Ruby does not use pass-by-reference. It uses pass-by-value. However, to get a better grip on object passing in Ruby, it is useful to distinguish two varieties of pass-by-value: “pass-value-by-value”, and “pass-reference-by-value”. This terminology comes from <a href="http://robertheaton.com/2014/07/22/is-ruby-pass-by-reference-or-pass-by-value/">this article</a>, from which the following explanation heavily borrows:</p>

<ol>
  <li><em>Pass-value-by-value:</em> In pass-value-by-value, the procedure receives a <em>copy of the objects</em> passed to it. There is thus no relationship between either the variables or the objects referenced by the values by the function and the caller. Nothing that happens to one will affect the other.</li>
  <li><em>Pass-reference-by-value:</em> On the pass-reference-by-value model, a procedure receives a reference to the same object in memory that is used by the caller, i.e., caller and callee <em>share</em> the object. However, the variable the procedure uses is <em>not</em> merely an alias for the variable used by the caller. The procedure has its own (“fresh”) variable, which merely happens to point to the same object as the caller variable. This means that changes made to the <em>object</em> made inside the procedure will be visible to the caller. But changes made to the <em>variable</em> inside the procedure will not be.</li>
</ol>

<p>How does Ruby do it? <em>Ruby follows the second model.</em> So the variable passed into a Ruby method is not a “complete alias” for the original variable. It is distinct. But the method variable and the variable used by the caller <em>share a single value</em>.</p>

<h2 id="examples">Examples</h2>

<p>Let’s see the consequences of this with two examples. First, contrast Ruby with the pass-by-reference model.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">reassign</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
  <span class="n">array</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">]</span>
<span class="k">end</span>

<span class="n">array</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">reassign</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
<span class="n">array</span> <span class="c1">#=&gt; [1]</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>In this example, the <code class="highlighter-rouge">reassign</code> method reassigns the variable it receives to another object. In a pass-by-reference language, this would have the effect of reassigning the caller variable <code class="highlighter-rouge">array</code> as well (because the variable used by the caller and the variable used by the method are <em>the same</em>, except for the superficial property of not having the same name). But not so in Ruby: the method uses its own variable, distinct from the variable used by the caller.</p>

<p>So the last line of the above code evaluates to <code class="highlighter-rouge">[1]</code>, not to <code class="highlighter-rouge">[10]</code> as we would expect on the pass-by-reference model. <em>Reassigning a variable within a method will have no effect on the caller in Ruby.</em></p>

<p>Let’s now contrast Ruby with the pass-value-by-value strategy used by Java.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">mutate</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
  <span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">]</span>
<span class="k">end</span>

<span class="n">array</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">mutate</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
<span class="n">array</span> <span class="c1">#=&gt; [10]</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>In this example, the <code class="highlighter-rouge">mutate</code> method mutates the object it receives. In a pass-value-by-value language, this change would not be visible to the caller, since the object used by the method, and the object used by the caller are <em>distinct</em>. But not so in Ruby: the object is shared between caller variable and method variable, so the mutation of the array object will be visible to the caller.</p>

<p>As a consequence, the last line of the above code evaluates to <code class="highlighter-rouge">[10]</code>, not to <code class="highlighter-rouge">[1]</code> as we would expect on a pass-value-by-value model. <em>Mutating an object within a method will have an effect on the caller in Ruby.</em></p>

<h3 id="takeaway">Takeaway</h3>

<p>Ruby is not a <em>pass-by-reference</em> language, it is a <em>pass-by-value</em> language. But it is not a <em>pass-value-by-value</em> language, it’s <em>pass-reference-by-value</em>. Reassignment of a variable within a method will never affect the original variable that lives outside the method. On the other hand, mutating an object within a method will affect the original object outside the method, because those two objects are shared.</p>

      <div class="pad"></div><hr class="line" /><div class="triplepad"></div>
      
      <small>31 May 2017</small>
      <h1 id="tic-tac-toe-with-negamax">Tic Tac Toe with Negamax</h1>

<p>The first version of the Tic Tac Toe negamax algorithm that I implemented was painfully slow. It took more than 30 seconds to return a move for the initial position of a standard 3x3 game. So I had a strong incentive to try and understand the algorithm better. Beginning programmers are typically advised not to spend time worrying about performance, but here, we are not talking about micro-optimization – we are talking about an algorithm implementation that makes a game unplayable.</p>

<p>In this post, I will discuss the baseline negamax algorithm for solving Tic Tac Toe, and a few improvements to this algorithm – both more generic ones (that could be applied, more or less directly, to any strictly competitive games) and more specific ones (that exploit certain properties of <em>this</em> game, Tic Tac Toe).</p>

<!-- ## Tic Tac Toe

We will represent a 3x3 Tic Tac Toe position as a nine-element array that we can access by index, with indices ranging from 0 to 8. Using the common player markers, and a blank space for squares that have not been chosen by either of the players yet. So the following board position ...

... will be represented by this array:

```ruby
['X', 'O', ' ', 'X', ' ', ' ', ' ', ' ', ' ']
```

Let's now agree on a bag of Ruby methods that implement the rules of Tic Tac Toe for us. -->

<h2 id="brute-force-negamax">Brute force Negamax</h2>

<p>Here is an implementation of the Negamax algorithm for Tic Tac Toe in Ruby:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">nega_max</span><span class="p">(</span><span class="n">player</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">terminal?</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
    <span class="n">payoff</span><span class="p">(</span><span class="n">player</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
  <span class="k">else</span>
    <span class="n">available_moves</span><span class="p">(</span><span class="n">state</span><span class="p">).</span><span class="nf">map</span> <span class="k">do</span> <span class="o">|</span><span class="n">move</span><span class="o">|</span>
      <span class="n">make</span><span class="p">(</span><span class="n">move</span><span class="p">,</span> <span class="n">player</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
      <span class="n">value_for_move</span> <span class="o">=</span> <span class="o">-</span><span class="n">nega_max</span><span class="p">(</span><span class="n">opponent</span><span class="p">(</span><span class="n">player</span><span class="p">),</span> <span class="n">state</span><span class="p">)</span>
      <span class="n">unmake</span><span class="p">(</span><span class="n">move</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
      <span class="n">value_for_move</span>
    <span class="k">end</span><span class="p">.</span><span class="nf">max</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>The method returns the value of a game state <code class="highlighter-rouge">state</code> for the player <code class="highlighter-rouge">player</code>, assumed to be the player who moves next. This value is the highest payoff that <code class="highlighter-rouge">player</code> can be guaranteed to achieve with optimal play, and it is denoted  with the variable <code class="highlighter-rouge">best_value</code>.</p>

<p>For terminal states, the value of <code class="highlighter-rouge">state</code> for <code class="highlighter-rouge">player</code> is given by the Tic Tac Toe payoff function — that’s the first branch of the conditional:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre><span class="n">best_value</span> <span class="o">=</span> <span class="n">payoff</span><span class="p">(</span><span class="n">player</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>For non-terminal states, <code class="highlighter-rouge">player</code> has to evaluate all available choices. Suppose she is at the moment looking at one particular move <code class="highlighter-rouge">move</code>. She makes the move (that’s the line <code class="highlighter-rouge">make(move, player, state)</code>, which updates <code class="highlighter-rouge">state</code> as a side-effect), and evaluates the resulting position. She uses our <code class="highlighter-rouge">nega_max</code> method to do this. Assume that the method tells her that the best her opponent can do in the successor state (referenced by <code class="highlighter-rouge">state</code> at this point) is $n$. So what can <code class="highlighter-rouge">player</code> herself achieve by choosing <code class="highlighter-rouge">move</code>? It’s $-n$. Here is why:</p>

<ul>
  <li>If <code class="highlighter-rouge">opponent(player)</code> can guarantee a win, then opponent will get $1$, so <code class="highlighter-rouge">player</code> gets $-1$ if she chooses <code class="highlighter-rouge">move</code>.</li>
  <li>If <code class="highlighter-rouge">opponent(player)</code> can only guarantee a tie, opponent will get $0$, so <code class="highlighter-rouge">player</code> gets $-0$, which is $0$.</li>
  <li>If <code class="highlighter-rouge">opponent(player)</code> is bound to lose, opponent will get $-1$, so <code class="highlighter-rouge">player</code> gets $-(-1)$, which is $1$.</li>
</ul>

<p>So the best <code class="highlighter-rouge">player</code> can guarantee to achieve when choosing <code class="highlighter-rouge">move</code> is indeed $-n$. This explains the crucial line of the method containing the recursive call:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre><span class="n">value_for_move</span> <span class="o">=</span> <span class="o">-</span><span class="n">nega_max</span><span class="p">(</span><span class="n">opponent</span><span class="p">(</span><span class="n">player</span><span class="p">),</span> <span class="n">state</span><span class="p">)</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>Notice that this only works because Tic Tac Toe is <em>zero-sum</em>, i.e., one player’s loss is another player’s gain: the payoffs of both players always add up to 0.</p>

<p>Return to <code class="highlighter-rouge">player</code>, who is deliberating which move to take. She proceeds in the manner described, evaluating <em>all</em> her moves. In this way, <code class="highlighter-rouge">player</code> obtains a list of values, one for each move (that list is the return value of the <code class="highlighter-rouge">map</code> invocation). The maximal value from this list is the best she can guarantee, so this is what we return.</p>

<h2 id="the-best-move">The best move</h2>

<h2 id="algorithms">Algorithms</h2>

<ul>
  <li>brute force negamax</li>
  <li>negamax with transposition table</li>
  <li>negamax with symmetry table
    <ul>
      <li>consider: instead of solving all of the eight subtrees of the initial game node, we have to solve just three.</li>
    </ul>
  </li>
  <li>negamax with symmetry lookup</li>
  <li>alpha-beta pruning</li>
  <li>negamax with shortcuts</li>
</ul>

<p>these fall onto a spectrum from “more generic” to “more game-specific”</p>
<ul>
  <li>negamax and negamax with alpha-beta pruning are generic algorithms that work pretty much for every game.</li>
  <li>transposition tables are useful whenever there are several ways to reach the same position.</li>
  <li>symmetry is useful if there are … symmetries!</li>
  <li>the shortcut method makes use of the fact that tic tac toe is solved. so why not use the fact that the best we can guarantee is a tie?</li>
</ul>

<h2 id="results">Results</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: left"> </th>
      <th style="text-align: right">time</th>
      <th style="text-align: right">calls</th>
      <th style="text-align: right">table size</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">brute force</td>
      <td style="text-align: right">5.781872</td>
      <td style="text-align: right">549,946</td>
      <td style="text-align: right">-</td>
    </tr>
    <tr>
      <td style="text-align: left">transposition table</td>
      <td style="text-align: right">0.105050</td>
      <td style="text-align: right">16,168</td>
      <td style="text-align: right">5,477</td>
    </tr>
    <tr>
      <td style="text-align: left">symmetry table</td>
      <td style="text-align: right">0.048830</td>
      <td style="text-align: right">2,271</td>
      <td style="text-align: right">5,477</td>
    </tr>
    <tr>
      <td style="text-align: left">symmetry lookup</td>
      <td style="text-align: right">0.058844</td>
      <td style="text-align: right">2,271</td>
      <td style="text-align: right">764</td>
    </tr>
    <tr>
      <td style="text-align: left">alpha-beta</td>
      <td style="text-align: right">0.193677</td>
      <td style="text-align: right">18,297</td>
      <td style="text-align: right">-</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>549,946 is the size of the 3x3 ttt game tree (i.e., the number of nodes)</li>
  <li>5477 is the number of distinct board positions minus the initial state</li>
  <li>
    <p>764 is the number of board positions up to symmetry minus the initial state</p>
  </li>
  <li>
    <p>In the transposition table case, around 6,000 calls are calls that result (as a side-effect) in values being stored to the lookup table, whereas around 10,000 calls return a looked-up value.</p>
  </li>
  <li>In the symmetry table case, the table is built “much faster”, because whenever we save to the table, we save eight values instead of merely one.</li>
</ul>

<h3 id="time">time</h3>

<ul>
  <li>
    <p>with a symmetry table, we can realize a hundred fold speed increase.</p>
  </li>
  <li>memoizing values is a dramatic improvement over brute force negamax</li>
  <li>exploiting symmetries allows us reduce computation time by half</li>
  <li>saving symmetric values as we compute them seems slightly faster than computing symmetries during lookup</li>
  <li>the memoization approaches are quite a bit faster than alpha-beta-search on a 3x3 board</li>
  <li>(it looks like alpa-beta scales a lot better, viz the results for a 4x4 board)</li>
</ul>

<h3 id="calls">calls</h3>

<ul>
  <li>brute force: the number of method calls is a lot higher than the number of distinct positions, because many positions are computed several times.</li>
  <li>transposition table: with this algorithm, the number of calls is still higher than the number of positions, because it may happen that our negamax method is called for some state, even if that state has been evaluated already and stored … but we still need to retrieve it!</li>
  <li>symmetry table: now the number of calls is lower than the size of the table. this looks certainly odd at first sight. but the thing is that with every function call, we write up to eight new values to the table.</li>
</ul>

<h3 id="method-calls-in-relation-to-time">method calls in relation to time</h3>
<ul>
  <li>the number of method calls does not correlate neatly with computation time spent.</li>
  <li>compare brute force and transposition table: 549946/16168 is about 34, so the evaluation function is called 34 times less when we use the transposition table vs brute force. the speed gain, on the other hand, is around 57-fold. Why is that?</li>
  <li>
    <p>When going from a transposition to a symmetry table, there is a 7-fold decrease in function calls, but the computation time is only halved. Filling in the table entries comes with an extra cost that partially offsets avoiding negamax calls. That seems to be the plausible explanation.</p>
  </li>
  <li><strong>What does the number of method calls actually correspond to?</strong> In brute force negamax, it is simply the number of nodes in the complete game tree (see https://books.google.com/books?id=1xHPDAAAQBAJ&amp;pg=PA151&amp;lpg=PA151&amp;dq=size+of+tic+tac+toe+game+tree&amp;source=bl&amp;ots=J3Tp09kbbL&amp;sig=DJoyUjGx2XGMm-gvMg-QW5bQ8sI&amp;hl=de&amp;sa=X&amp;ved=0ahUKEwivzpGyjpHUAhVG0WMKHVRqD704ChDoAQhXMAc#v=onepage&amp;q=size%20of%20tic%20tac%20toe%20game%20tree&amp;f=false)</li>
</ul>

<h3 id="table-size">table size</h3>

<ul>
  <li>transposition table: there are 5478 distinct positions in 3x3 tic tac toe (see http://www.mathrec.org/old/2002jan/solutions.html). Since we do not store a value for the initial state in the table, our table has 5477 entries.</li>
  <li>symmetry lookup: since we only store a “representative” of each equivalence class, this is a smaller table. there are 765 distinct ttt positions modulo symmetries (see http://www.mathrec.org/old/2002jan/solutions.html), and since we don’t store the initial state, our table has 764 entries.</li>
</ul>

<h3 id="why-is-the-number-of-method-calls-smaller-than-the-number-of-distinct-ttt-positions-when-we-use-a-symmetry-table">Why is the number of method calls smaller than the number of distinct ttt positions when we use a symmetry table?</h3>

<p>This might come as a surprise, because shouldn’t we have to visit every distinct node at least once? well, no, actually! The reason we don’t have to do this is that there are certain positions we never even have to evaluate, because they are descendants of nodes that are symmetric to nodes we have evaluated (if that makes sense).</p>

<h3 id="shortcut">shortcut</h3>

<ul>
  <li>
    <p>suppose we already know that the best we can guarantee is a tie. then we could stop looking for a win (we know we cannot find a guaranteed win path), but instead look for a tie path. this is the idea behind the two “shortcut” algorithms I looked at: one adds the shortcut to the brute force algorithm, the second adds the shortcut to the transposition table. The second one (transposition with shortcut) is the fastest algorithms I considered.</p>
  </li>
  <li>
    <p>there is a pitfall here, however. if we are playing against a less than perfect opponent, than we might miss a chance to score a win if we take the shortcut!</p>
  </li>
</ul>

      <div class="pad"></div><hr class="line" /><div class="triplepad"></div>
      
      <small>15 May 2017</small>
      <h1 id="sorting-in-ruby">Sorting in Ruby</h1>

<p>Ruby has two built-in methods for sorting collections: <code class="highlighter-rouge">sort</code> and <code class="highlighter-rouge">sort_by</code>. Both are contained in the <code class="highlighter-rouge">Enumerable</code> module, which any Ruby class can include as long as it implements a an <code class="highlighter-rouge">each</code> method for iterating over instances of the class. The elements of a collection also need to implement a three-way comparison method <code class="highlighter-rouge">&lt;=&gt;</code> (the “spaceship operator”) if we want to invoke <code class="highlighter-rouge">sort</code> or <code class="highlighter-rouge">sort_by</code> on that collection.</p>

<p>My question for this post is this: why would there be two sort methods rather than just one?</p>

<h2 id="exploring-sort_by">Exploring <code class="highlighter-rouge">sort_by</code></h2>

<p>Let’s first try to get a clearer picture how <code class="highlighter-rouge">sort_by</code> works. Start with an example. Suppose we would like to sort the following array <em>by the numerical values</em> of its string elements:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre><span class="n">arr</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'0'</span><span class="p">,</span> <span class="s1">'10'</span><span class="p">,</span> <span class="s1">'3'</span><span class="p">]</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>This can be achieved using <code class="highlighter-rouge">sort_by</code> as follows:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2</pre></td><td class="code"><pre><span class="n">arr</span><span class="p">.</span><span class="nf">sort_by</span> <span class="p">{</span> <span class="o">|</span><span class="n">string</span><span class="o">|</span> <span class="n">string</span><span class="p">.</span><span class="nf">to_i</span> <span class="p">}</span>
<span class="c1"># =&gt; ['0', '3', '10']</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>Or using shorthand:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2</pre></td><td class="code"><pre><span class="n">arr</span><span class="p">.</span><span class="nf">sort_by</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:to_i</span><span class="p">)</span>
<span class="c1"># =&gt; ['0', '3', '10']</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>Now the question is: how does <code class="highlighter-rouge">sort_by</code> do its magic? My initial hunch when exploring this topic was that <code class="highlighter-rouge">sort_by</code> seems fairly closely related to the functionality provided by the <code class="highlighter-rouge">map</code> method, also contained in <code class="highlighter-rouge">Enumerable</code>. There is <a href="http://ruby-doc.org/core-2.4.1/Enumerable.html#method-i-sort_by">a hint in the Ruby Docs</a> that points in the same direction: “The current implementation of <code class="highlighter-rouge">sort_by</code> generates an array of tuples containing the original collection element and the mapped value.”</p>

<p>Based on this, it looks like what <code class="highlighter-rouge">sort_by</code> must be doing is something like this:</p>

<ol>
  <li>Transform the given array to an array of pairs (making use of the block that was passed).</li>
  <li>Sort the array of pairs by accessing the second component of each pair (relying on the <code class="highlighter-rouge">&lt;=&gt;</code> method defined for the second component).</li>
  <li>Project each pair to its first component.</li>
</ol>

<p>The result of step 3 is your sorted array.</p>

<p>After some Googling, I found out that this is actually a pretty well-known technique, often called <a href="https://en.wikipedia.org/wiki/Schwartzian_transform">Schwartzian transform</a> among Perl programmers. So it does look like <code class="highlighter-rouge">sort_by</code> works just in this way.</p>

<p>Let’s make things more concrete by implementing a toy version of <code class="highlighter-rouge">sort_by</code> ourselves. This will come in handy in the second part of the post, when we want to compare <code class="highlighter-rouge">sort</code> and <code class="highlighter-rouge">sort_by</code>. Plus it’s a nice exercise – when learning a language, it can be useful to re-implement methods of interest to deepen understanding, I have been told at <a href="http://launchschool.com">Launch School</a>.</p>

<p>First, we observe that we can actually express the above three steps in Ruby code fairly easily – this is where the <code class="highlighter-rouge">map</code> method comes into play. For our running example, observe that the sorted array can be obtained as follows:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4</pre></td><td class="code"><pre><span class="n">arr</span><span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">elem</span><span class="o">|</span> <span class="p">[</span><span class="n">elem</span><span class="p">,</span> <span class="n">elem</span><span class="p">.</span><span class="nf">to_i</span><span class="p">]</span> <span class="p">}</span> <span class="c1"># step (1)</span>
  <span class="p">.</span><span class="nf">sort</span> <span class="p">{</span> <span class="o">|</span><span class="n">pair1</span><span class="p">,</span> <span class="n">pair2</span><span class="o">|</span> <span class="n">pair1</span><span class="p">.</span><span class="nf">last</span> <span class="o">&lt;=&gt;</span> <span class="n">pair2</span><span class="p">.</span><span class="nf">last</span> <span class="p">}</span> <span class="c1"># step (2)</span>
  <span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">pair</span><span class="o">|</span> <span class="n">pair</span><span class="p">.</span><span class="nf">first</span> <span class="p">}</span> <span class="c1"># step (3)</span>
<span class="c1"># =&gt; ['0', '3', '10']</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>Notice that we have replaced the invocation of <code class="highlighter-rouge">sort_by</code> with calls to <code class="highlighter-rouge">map</code>, <code class="highlighter-rouge">sort</code> and <code class="highlighter-rouge">&lt;=&gt;</code>. This is obviously a lot more cumbersome than using <code class="highlighter-rouge">sort_by</code> itself – but it makes it fairly clear how our re-implementation of <code class="highlighter-rouge">sort_by</code> should look like. Here it is:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7</pre></td><td class="code"><pre><span class="k">module</span> <span class="nn">Enumerable</span>
  <span class="k">def</span> <span class="nf">my_sort_by</span>
    <span class="nb">self</span><span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">elem</span><span class="o">|</span> <span class="p">[</span><span class="n">elem</span><span class="p">,</span> <span class="k">yield</span><span class="p">(</span><span class="n">elem</span><span class="p">)]</span> <span class="p">}</span>
      <span class="p">.</span><span class="nf">sort</span> <span class="p">{</span> <span class="o">|</span><span class="n">pair1</span><span class="p">,</span> <span class="n">pair2</span><span class="o">|</span> <span class="n">pair1</span><span class="p">.</span><span class="nf">last</span> <span class="o">&lt;=&gt;</span> <span class="n">pair2</span><span class="p">.</span><span class="nf">last</span> <span class="p">}</span>
      <span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">pair</span><span class="o">|</span> <span class="n">pair</span><span class="p">.</span><span class="nf">first</span> <span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>Looking at the <a href="https://github.com/rubinius/rubinius/blob/f9c2dffa4c894eea88abe1e476688df549a2bc4b/core/enumerable.rb#L351">Rubinius code for <code class="highlighter-rouge">sort_by</code></a> – a hint I got from one of the instructors at Launch School when sharing a draft of this post – we see just this pattern: a <code class="highlighter-rouge">map</code> invocation followed by a <code class="highlighter-rouge">sort</code> invocation followed by a <code class="highlighter-rouge">map</code> invocation. Rubinius even has a special class for representing tuples of the required kind. It is called <code class="highlighter-rouge">SortedElement</code> and comes with a <code class="highlighter-rouge">&lt;=&gt;</code> method that compares instances based on the value of the second element of the tuple.</p>

<p>For our running example, <code class="highlighter-rouge">my_sort_by</code> yields the desired return value:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre><span class="n">arr</span><span class="p">.</span><span class="nf">my_sort_by</span> <span class="p">{</span> <span class="o">|</span><span class="n">elem</span><span class="o">|</span> <span class="n">elem</span><span class="p">.</span><span class="nf">to_i</span> <span class="p">}</span> <span class="c1"># =&gt; ['0', '3', '10']</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>Or, using shorthand:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre><span class="n">arr</span><span class="p">.</span><span class="nf">my_sort_by</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:to_i</span><span class="p">)</span> <span class="c1"># =&gt; ['0', '3', '10']</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>Let’s now return to our original question: why would Ruby have two sort methods rather than just one?</p>

<h2 id="the-cost-of-transformation">The cost of transformation</h2>

<p>It turns out that there is a reason for favouring <code class="highlighter-rouge">sort_by</code> over <code class="highlighter-rouge">sort</code>, at least in certain scenarios: efficiency.</p>

<p>Both <code class="highlighter-rouge">sort</code> and <code class="highlighter-rouge">sort_by</code> are based on comparisons of elements of the collection we want to sort. Comparison-based sorting <a href="https://www.cs.cmu.edu/~avrim/451f11/lectures/lect0913.pdf">has a lower bound of $O(n \log n)$</a>, which is to say that it is not possible to come up with a (comparison-based) sorting algorithm that performs better in a worst-case scenario. This is because, in the worst case, $n \log n$ comparisons of elements have to be made in order to determine the correct sort order. Ruby <a href="https://www.igvita.com/2009/03/26/ruby-algorithms-sorting-trie-heaps/">uses quicksort for sorting</a>, an algorithm that has a worst case complexity of $O(n^2)$, but runs in $O(n \log n)$ on average (as it turns out, $O(n \log n)$ is the lower bound for the average case as well, so quicksort is optimal for average cases).</p>

<p>Since quicksort is the algorithm powering both <code class="highlighter-rouge">sort</code> and <code class="highlighter-rouge">sort_by</code>, wouldn’t it be reasonable to think that both methods should have the same performance? The answer is no, and the reason is that the overall picture is complicated by the fact that we often do not wish to sort a given collection <em>as is</em> (i.e., relying on the <code class="highlighter-rouge">&lt;=&gt;</code> operator provided for its elements), but rather relying on some special “property” of its elements, i.e., a sort criterion, or <em>sort key</em>. For example, we may want to sort user profiles by users’ last names, or available moves in a game by their expected utility – or strings by integer value, as in our running example above. The last name, the expected utility, the integer value – those would be our sort keys.</p>

<p>Now unless the sort keys are simply given to us along with the values we want to sort, we will have to compute those keys ourselves. This takes time above and beyond the actual sorting. And this is where <code class="highlighter-rouge">sort</code> and <code class="highlighter-rouge">sort_by</code> differ.</p>

<p>Both of these methods allow us to do key-based sorting by passing a block with the method invocation. Suppose we have a method <code class="highlighter-rouge">key</code> that transforms the elements of a collection <code class="highlighter-rouge">list</code> to sort keys of the required kind (in our running example, the relevant transformation is simply to convert strings to integers, because numeric values are what we want to sort by). Then we can sort our list with the <code class="highlighter-rouge">sort</code> method as follows:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre><span class="n">list</span><span class="p">.</span><span class="nf">sort</span> <span class="p">{</span> <span class="o">|</span><span class="n">elem1</span><span class="p">,</span> <span class="n">elem2</span><span class="o">|</span> <span class="n">key</span><span class="p">(</span><span class="n">elem1</span><span class="p">)</span> <span class="o">&lt;=&gt;</span> <span class="n">key</span><span class="p">(</span><span class="n">elem2</span><span class="p">)</span> <span class="p">}</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>Using <code class="highlighter-rouge">sort_by</code>, as we have seen above, we would do it like this:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre><span class="n">list</span><span class="p">.</span><span class="nf">sort_by</span> <span class="p">{</span> <span class="o">|</span><span class="n">elem</span><span class="o">|</span> <span class="n">key</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span> <span class="p">}</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>It looks like using <code class="highlighter-rouge">sort_by</code> saves us a little bit of typing. But we are also saving a lot of computation steps, potentially. Remember from above: what is happening “under the hood” when we invoke <code class="highlighter-rouge">sort_by</code> in the way just described is something like this:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3</pre></td><td class="code"><pre><span class="n">list</span><span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">elem</span><span class="o">|</span> <span class="p">[</span><span class="n">elem</span><span class="p">,</span> <span class="n">key</span><span class="p">(</span><span class="n">elem</span><span class="p">)]</span> <span class="p">}</span>
  <span class="p">.</span><span class="nf">sort</span> <span class="p">{</span> <span class="o">|</span><span class="n">pair1</span><span class="p">,</span> <span class="n">pair2</span><span class="o">|</span> <span class="n">pair1</span><span class="p">.</span><span class="nf">last</span> <span class="o">&lt;=&gt;</span> <span class="n">pair2</span><span class="p">.</span><span class="nf">last</span> <span class="p">}</span>
  <span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">pair</span><span class="o">|</span> <span class="n">pair</span><span class="p">.</span><span class="nf">first</span> <span class="p">}</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>Clearly, this procedure involves $n$ calls to the <code class="highlighter-rouge">key</code> method, assuming that the length of <code class="highlighter-rouge">list</code> is $n$: we call <code class="highlighter-rouge">key</code> once for each element <code class="highlighter-rouge">elem</code> of <code class="highlighter-rouge">list</code>, storing the pair <code class="highlighter-rouge">[elem, key(elem)]</code> in our intermediate array. However, when using <code class="highlighter-rouge">sort</code>, the number of calls to the <code class="highlighter-rouge">key</code> method may be quite a bit larger. As observed earlier, sorting our list involves making $O(n\log n)$ comparisons on average, and even $O(n^2)$ comparisons in the worst case (since quicksort is Ruby’s search algorithm of choice). If we use <code class="highlighter-rouge">sort</code>, each such comparison will require two <em>on the fly</em> calls to the <code class="highlighter-rouge">key</code> method. In cases where <code class="highlighter-rouge">key</code> itself is a time-consuming transformation, having to perform it $O(n\log n)$ times (or even $O(n^2)$, in the worst case) rather than merely $O(n)$ times will make a big difference indeed.</p>

<p>So computing the keys ahead of time, and saving them for later use – as <code class="highlighter-rouge">sort_by</code> does, a technique known as <a href="https://en.wikipedia.org/wiki/Memoization">memoization</a> – may come with a significant performance gain over computing the keys on an as-needed basis, as <code class="highlighter-rouge">sort</code> does. If, on the other hand, the transformation is trivial, <code class="highlighter-rouge">sort</code> may still be faster than <code class="highlighter-rouge">sort_by</code> – the time saved by avoiding calls to the <code class="highlighter-rouge">key</code> method may then be more than offset by the effort of calling <code class="highlighter-rouge">map</code> twice. The Ruby Docs for <code class="highlighter-rouge">sort_by</code> <a href="http://ruby-doc.org/core-2.4.1/Enumerable.html#method-i-sort_by">give an example of this</a>. So, as usual, there are trade-offs involved.</p>

<p><em>Thanks to Pete Hanson from Launch School for valuable information on the topic of this post.</em></p>

      <div class="pad"></div><hr class="line" /><div class="triplepad"></div>
      
      </section>
      <header>
  <small>&nbsp;</small>
  <a href="http://notes.benrodenhaeuser.io">
    <h1>Ben Rodenhäuser</h1>
  </a>
  <p>Learning to program</p>
  <hr class="line" />
  <p>
      

          <h3>
            <a class="post-link" href="/2017/12/02/a-bag-of-sets/">A Bag Of Sets</a><span class="pad"></span><small>02 Dec 2017</small>
          </h3>
      

          <h3>
            <a class="post-link" href="/2017/10/28/subproblems/">Subproblems</a><span class="pad"></span><small>28 Oct 2017</small>
          </h3>
      

          <h3>
            <a class="post-link" href="/2017/07/06/object-passing/">Object Passing</a><span class="pad"></span><small>06 Jul 2017</small>
          </h3>
      

          <h3>
            <a class="post-link" href="/2017/05/31/negamax/">Negamax</a><span class="pad"></span><small>31 May 2017</small>
          </h3>
      

          <h3>
            <a class="post-link" href="/2017/05/15/sorting-in-ruby/">Sorting In Ruby</a><span class="pad"></span><small>15 May 2017</small>
          </h3>
      
  </p>
  <hr class="line" />
  <p><small><a href="http://github.com/benrodenhaeuser">GitHub Profile</a></small></p>
</header>

      <!-- <footer>
  <p><small>Ben Rodenhäuser 2017 | <a href="http://github.com/benrodenhaeuser">GitHub Profile</a></small></p>
</footer> -->

    </div>
    <script src="/assets/js/scale.fix.js"></script>
  </body>
</html>
