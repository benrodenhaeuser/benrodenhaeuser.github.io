<!doctype html>
<html lang="en-US">
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <title>Ben Rodenhäuser</title>

  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Roboto+Mono" rel="stylesheet">
  <link rel="stylesheet" href="/assets/css/style.css?v=">
  <script type="text/javascript"
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML&delayStartupUntilConfig">
  </script>
  <script src="/assets/jax/config.js"></script>

  <meta name="viewport" content="width=device-width">
  <!--[if lt IE 9]>
  <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  
    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-99334571-1', 'auto');
        ga('send', 'pageview');
    </script>
  
</head>

  <body>
    <div class="wrapper">
      <section>
      <small>15 May 2017</small>
      <h1 id="sorting-in-ruby">Sorting in Ruby</h1>

<p>Ruby has two built-in methods for sorting collections: <code class="highlighter-rouge">sort</code> and <code class="highlighter-rouge">sort_by</code>. Both are contained in the <code class="highlighter-rouge">Enumerable</code> module, which any Ruby class can include as long as it implements a an <code class="highlighter-rouge">each</code> method for iterating over instances of the class. The elements of a collection also need to implement a three-way comparison method <code class="highlighter-rouge">&lt;=&gt;</code> (the “spaceship operator”) if we want to invoke <code class="highlighter-rouge">sort</code> or <code class="highlighter-rouge">sort_by</code> on that collection.</p>

<p>My question for this post is this: why would there be two sort methods rather than just one?</p>

<h2 id="exploring-sort_by">Exploring <code class="highlighter-rouge">sort_by</code></h2>

<p>Let’s first try to get a clearer picture how <code class="highlighter-rouge">sort_by</code> works. Start with an example. Suppose we would like to sort the following array <em>by the numerical values</em> of its string elements:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="n">arr</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'0'</span><span class="p">,</span> <span class="s1">'10'</span><span class="p">,</span> <span class="s1">'3'</span><span class="p">]</span>
</code></pre>
</div>

<p>This can be achieved using <code class="highlighter-rouge">sort_by</code> as follows:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="n">arr</span><span class="p">.</span><span class="nf">sort_by</span> <span class="p">{</span> <span class="o">|</span><span class="n">string</span><span class="o">|</span> <span class="n">string</span><span class="p">.</span><span class="nf">to_i</span> <span class="p">}</span>
<span class="c1"># =&gt; ['0', '3', '10']</span>
</code></pre>
</div>

<p>Or using shorthand:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="n">arr</span><span class="p">.</span><span class="nf">sort_by</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:to_i</span><span class="p">)</span>
<span class="c1"># =&gt; ['0', '3', '10']</span>
</code></pre>
</div>

<p>Now the question is: how does <code class="highlighter-rouge">sort_by</code> do its magic? My initial hunch when exploring this topic was that <code class="highlighter-rouge">sort_by</code> seems fairly closely related to the functionality provided by the <code class="highlighter-rouge">map</code> method, also contained in <code class="highlighter-rouge">Enumerable</code>. There is <a href="http://ruby-doc.org/core-2.4.1/Enumerable.html#method-i-sort_by">a hint in the Ruby Docs</a> that points in the same direction: “The current implementation of <code class="highlighter-rouge">sort_by</code> generates an array of tuples containing the original collection element and the mapped value.”</p>

<p>Based on this, it looks like what <code class="highlighter-rouge">sort_by</code> must be doing is something like this:</p>

<ol>
  <li>Transform the given array to an array of pairs (making use of the block that was passed).</li>
  <li>Sort the array of pairs by accessing the second component of each pair (relying on the <code class="highlighter-rouge">&lt;=&gt;</code> method defined for the second component).</li>
  <li>Project each pair to its first component.</li>
</ol>

<p>The result of step 3 is your sorted array.</p>

<p>After some Googling, I found out that this is actually a pretty well-known technique, often called <a href="https://en.wikipedia.org/wiki/Schwartzian_transform">Schwartzian transform</a> among Perl programmers. So it does look like <code class="highlighter-rouge">sort_by</code> works just in this way.</p>

<p>Let’s make things more concrete by implementing a toy version of <code class="highlighter-rouge">sort_by</code> ourselves. This will come in handy in the second part of the post, when we want to compare <code class="highlighter-rouge">sort</code> and <code class="highlighter-rouge">sort_by</code>. Plus it’s a nice exercise – when learning a language, it can be useful to re-implement methods of interest to deepen understanding, I have been told at <a href="http://launchschool.com">Launch School</a>.</p>

<p>First, we observe that we can actually express the above three steps in Ruby code fairly easily – this is where the <code class="highlighter-rouge">map</code> method comes into play. For our running example, observe that the sorted array can be obtained as follows:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="n">arr</span><span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">elem</span><span class="o">|</span> <span class="p">[</span><span class="n">elem</span><span class="p">,</span> <span class="n">elem</span><span class="p">.</span><span class="nf">to_i</span><span class="p">]</span> <span class="p">}</span> <span class="c1"># step (1)</span>
  <span class="p">.</span><span class="nf">sort</span> <span class="p">{</span> <span class="o">|</span><span class="n">pair1</span><span class="p">,</span> <span class="n">pair2</span><span class="o">|</span> <span class="n">pair1</span><span class="p">.</span><span class="nf">last</span> <span class="o">&lt;=&gt;</span> <span class="n">pair2</span><span class="p">.</span><span class="nf">last</span> <span class="p">}</span> <span class="c1"># step (2)</span>
  <span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">pair</span><span class="o">|</span> <span class="n">pair</span><span class="p">.</span><span class="nf">first</span> <span class="p">}</span> <span class="c1"># step (3)</span>
<span class="c1"># =&gt; ['0', '3', '10']</span>
</code></pre>
</div>

<p>Notice that we have replaced the invocation of <code class="highlighter-rouge">sort_by</code> with calls to <code class="highlighter-rouge">map</code>, <code class="highlighter-rouge">sort</code> and <code class="highlighter-rouge">&lt;=&gt;</code>. This is obviously a lot more cumbersome than using <code class="highlighter-rouge">sort_by</code> itself – but it makes it fairly clear how our re-implementation of <code class="highlighter-rouge">sort_by</code> should look like. Here it is:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="k">module</span> <span class="nn">Enumerable</span>
  <span class="k">def</span> <span class="nf">my_sort_by</span>
    <span class="nb">self</span><span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">elem</span><span class="o">|</span> <span class="p">[</span><span class="n">elem</span><span class="p">,</span> <span class="k">yield</span><span class="p">(</span><span class="n">elem</span><span class="p">)]</span> <span class="p">}</span>
      <span class="p">.</span><span class="nf">sort</span> <span class="p">{</span> <span class="o">|</span><span class="n">pair1</span><span class="p">,</span> <span class="n">pair2</span><span class="o">|</span> <span class="n">pair1</span><span class="p">.</span><span class="nf">last</span> <span class="o">&lt;=&gt;</span> <span class="n">pair2</span><span class="p">.</span><span class="nf">last</span> <span class="p">}</span>
      <span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">pair</span><span class="o">|</span> <span class="n">pair</span><span class="p">.</span><span class="nf">first</span> <span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Looking at the <a href="https://github.com/rubinius/rubinius/blob/f9c2dffa4c894eea88abe1e476688df549a2bc4b/core/enumerable.rb#L351">Rubinius code for <code class="highlighter-rouge">sort_by</code></a> – a hint I got from one of the instructors at Launch School when sharing a draft of this post – we see just this pattern: a <code class="highlighter-rouge">map</code> invocation followed by a <code class="highlighter-rouge">sort</code> invocation followed by a <code class="highlighter-rouge">map</code> invocation. Rubinius even has a special class for representing tuples of the required kind. It is called <code class="highlighter-rouge">SortedElement</code> and comes with a <code class="highlighter-rouge">&lt;=&gt;</code> method that compares instances based on the value of the second element of the tuple.</p>

<p>For our running example, <code class="highlighter-rouge">my_sort_by</code> yields the desired return value:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="n">arr</span><span class="p">.</span><span class="nf">my_sort_by</span> <span class="p">{</span> <span class="o">|</span><span class="n">elem</span><span class="o">|</span> <span class="n">elem</span><span class="p">.</span><span class="nf">to_i</span> <span class="p">}</span> <span class="c1"># =&gt; ['0', '3', '10']</span>
</code></pre>
</div>

<p>Or, using shorthand:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="n">arr</span><span class="p">.</span><span class="nf">my_sort_by</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:to_i</span><span class="p">)</span> <span class="c1"># =&gt; ['0', '3', '10']</span>
</code></pre>
</div>

<p>Let’s now return to our original question: why would Ruby have two sort methods rather than just one?</p>

<h2 id="the-cost-of-transformation">The cost of transformation</h2>

<p>It turns out that there is a reason for favouring <code class="highlighter-rouge">sort_by</code> over <code class="highlighter-rouge">sort</code>, at least in certain scenarios: efficiency.</p>

<p>Both <code class="highlighter-rouge">sort</code> and <code class="highlighter-rouge">sort_by</code> are based on comparisons of elements of the collection we want to sort. Comparison-based sorting <a href="https://www.cs.cmu.edu/~avrim/451f11/lectures/lect0913.pdf">has a lower bound of $O(n \log n)$</a>, which is to say that it is not possible to come up with a (comparison-based) sorting algorithm that performs better in a worst-case scenario. This is because, in the worst case, $n \log n$ comparisons of elements have to be made in order to determine the correct sort order. Ruby <a href="https://www.igvita.com/2009/03/26/ruby-algorithms-sorting-trie-heaps/">uses quicksort for sorting</a>, an algorithm that has a worst case complexity of $O(n^2)$, but runs in $O(n \log n)$ on average (as it turns out, $O(n \log n)$ is the lower bound for the average case as well, so quicksort is optimal for average cases).</p>

<p>Since quicksort is the algorithm powering both <code class="highlighter-rouge">sort</code> and <code class="highlighter-rouge">sort_by</code>, wouldn’t it be reasonable to think that both methods should have the same performance? The answer is no, and the reason is that the overall picture is complicated by the fact that we often do not wish to sort a given collection <em>as is</em> (i.e., relying on the <code class="highlighter-rouge">&lt;=&gt;</code> operator provided for its elements), but rather relying on some special “property” of its elements, i.e., a sort criterion, or <em>sort key</em>. For example, we may want to sort user profiles by users’ last names, or available moves in a game by their expected utility – or strings by integer value, as in our running example above. The last name, the expected utility, the integer value – those would be our sort keys.</p>

<p>Now unless the sort keys are simply given to us along with the values we want to sort, we will have to compute those keys ourselves. This takes time above and beyond the actual sorting. And this is where <code class="highlighter-rouge">sort</code> and <code class="highlighter-rouge">sort_by</code> differ.</p>

<p>Both of these methods allow us to do key-based sorting by passing a block with the method invocation. Suppose we have a method <code class="highlighter-rouge">key</code> that transforms the elements of a collection <code class="highlighter-rouge">list</code> to sort keys of the required kind (in our running example, the relevant transformation is simply to convert strings to integers, because numeric values are what we want to sort by). Then we can sort our list with the <code class="highlighter-rouge">sort</code> method as follows:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="n">list</span><span class="p">.</span><span class="nf">sort</span> <span class="p">{</span> <span class="o">|</span><span class="n">elem1</span><span class="p">,</span> <span class="n">elem2</span><span class="o">|</span> <span class="n">key</span><span class="p">(</span><span class="n">elem1</span><span class="p">)</span> <span class="o">&lt;=&gt;</span> <span class="n">key</span><span class="p">(</span><span class="n">elem2</span><span class="p">)</span> <span class="p">}</span>
</code></pre>
</div>

<p>Using <code class="highlighter-rouge">sort_by</code>, as we have seen above, we would do it like this:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="n">list</span><span class="p">.</span><span class="nf">sort_by</span> <span class="p">{</span> <span class="o">|</span><span class="n">elem</span><span class="o">|</span> <span class="n">key</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span> <span class="p">}</span>
</code></pre>
</div>

<p>It looks like using <code class="highlighter-rouge">sort_by</code> saves us a little bit of typing. But we are also saving a lot of computation steps, potentially. Remember from above: what is happening “under the hood” when we invoke <code class="highlighter-rouge">sort_by</code> in the way just described is something like this:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="n">list</span><span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">elem</span><span class="o">|</span> <span class="p">[</span><span class="n">elem</span><span class="p">,</span> <span class="n">key</span><span class="p">(</span><span class="n">elem</span><span class="p">)]</span> <span class="p">}</span>
  <span class="p">.</span><span class="nf">sort</span> <span class="p">{</span> <span class="o">|</span><span class="n">pair1</span><span class="p">,</span> <span class="n">pair2</span><span class="o">|</span> <span class="n">pair1</span><span class="p">.</span><span class="nf">last</span> <span class="o">&lt;=&gt;</span> <span class="n">pair2</span><span class="p">.</span><span class="nf">last</span> <span class="p">}</span>
  <span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">pair</span><span class="o">|</span> <span class="n">pair</span><span class="p">.</span><span class="nf">first</span> <span class="p">}</span>
</code></pre>
</div>

<p>Clearly, this procedure involves $n$ calls to the <code class="highlighter-rouge">key</code> method, assuming that the length of <code class="highlighter-rouge">list</code> is $n$: we call <code class="highlighter-rouge">key</code> once for each element <code class="highlighter-rouge">elem</code> of <code class="highlighter-rouge">list</code>, storing the pair <code class="highlighter-rouge">[elem, key(elem)]</code> in our intermediate array. However, when using <code class="highlighter-rouge">sort</code>, the number of calls to the <code class="highlighter-rouge">key</code> method may be quite a bit larger. As observed earlier, sorting our list involves making $O(n\log n)$ comparisons on average, and even $O(n^2)$ comparisons in the worst case (since quicksort is Ruby’s search algorithm of choice). If we use <code class="highlighter-rouge">sort</code>, each such comparison will require two <em>on the fly</em> calls to the <code class="highlighter-rouge">key</code> method. In cases where <code class="highlighter-rouge">key</code> itself is a time-consuming transformation, having to perform it $O(n\log n)$ times (or even $O(n^2)$, in the worst case) rather than merely $O(n)$ times will make a big difference indeed.</p>

<p>So computing the keys ahead of time, and saving them for later use – as <code class="highlighter-rouge">sort_by</code> does, a technique known as <a href="https://en.wikipedia.org/wiki/Memoization">memoization</a> – may come with a significant performance gain over computing the keys on an as-needed basis, as <code class="highlighter-rouge">sort</code> does. If, on the other hand, the transformation is trivial, <code class="highlighter-rouge">sort</code> may still be faster than <code class="highlighter-rouge">sort_by</code> – the time saved by avoiding calls to the <code class="highlighter-rouge">key</code> method may then be more than offset by the effort of calling <code class="highlighter-rouge">map</code> twice. The Ruby Docs for <code class="highlighter-rouge">sort_by</code> <a href="http://ruby-doc.org/core-2.4.1/Enumerable.html#method-i-sort_by">give an example of this</a>. So, as usual, there are trade-offs involved.</p>

<p><em>Thanks to Pete Hanson from Launch School for valuable information on the topic of this post.</em></p>

      <div class="pad"></div><hr class="line" /><div class="triplepad"></div>
      </section>
      <header>
  <small>&nbsp;</small>
  <a href="http://notes.benrodenhaeuser.io">
    <h1>Ben Rodenhäuser</h1>
  </a>
  <p>Learning to program</p>
  <hr class="line" />
  <p>
      

          <h3>
            <a class="post-link" href="/2017/07/06/object-passing/">Object Passing</a><span class="pad"></span><small>06 Jul 2017</small>
          </h3>
      

          <h3>
            <a class="post-link" href="/2017/05/31/negamax/">Negamax</a><span class="pad"></span><small>31 May 2017</small>
          </h3>
      

          <h3>
            <a class="post-link" href="/2017/05/15/sorting-in-ruby/">Sorting In Ruby</a><span class="pad"></span><small>15 May 2017</small>
          </h3>
      
  </p>
  <hr class="line" />
  <p><small><a href="http://github.com/benrodenhaeuser">GitHub Profile</a></small></p>
</header>

      <!-- <footer>
  <p><small>Ben Rodenhäuser 2017 | <a href="http://github.com/benrodenhaeuser">GitHub Profile</a></small></p>
</footer> -->

    </div>
    <script src="/assets/js/scale.fix.js"></script>
  </body>
</html>
