<!doctype html>
<html lang="en-US">
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <title>Ben Rodenhäuser</title>
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Roboto+Mono" rel="stylesheet">
  <link rel="stylesheet" href="/assets/css/style.css?v=">
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
      "HTML-CSS" : {
        availableFonts : ["Gyre-Termes"],
        preferredFont : "Gyre-Termes",
        webFont : "Gyre-Termes",
        imageFont : null
      },
      styles: {".MathJax": {color: "#333"}}
    });
  </script>
  <script type="text/javascript"
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
  <meta name="viewport" content="width=device-width">
<!--[if lt IE 9]>
  <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  
    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-99334571-1', 'auto');
        ga('send', 'pageview');
    </script>
  
</head>

  <body>
    <div class="wrapper">
      <section>
      <small>31 May 2017</small>
      <h1 id="tic-tac-toe-with-negamax">Tic Tac Toe with Negamax</h1>

<p>The first version of the Tic Tac Toe negamax algorithm that I implemented was painfully slow. It took more than 30 seconds to return a move for the initial position of a standard 3x3 game. So I had a strong incentive to try and understand the algorithm better. Beginning programmers are typically advised not to spend time worrying about performance, but here, we are not talking about micro-optimization – we are talking about an algorithm implementation that makes a game unplayable.</p>

<p>In this post, I will discuss the baseline negamax algorithm for solving Tic Tac Toe, and a few improvements to this algorithm – both more generic ones (that could be applied, more or less directly, to any strictly competitive games) and more specific ones (that exploit certain properties of <em>this</em> game, Tic Tac Toe).</p>

<!-- ## Tic Tac Toe

We will represent a 3x3 Tic Tac Toe position as a nine-element array that we can access by index, with indices ranging from 0 to 8. Using the common player markers, and a blank space for squares that have not been chosen by either of the players yet. So the following board position ...

... will be represented by this array:

```ruby
['X', 'O', ' ', 'X', ' ', ' ', ' ', ' ', ' ']
```

Let's now agree on a bag of Ruby methods that implement the rules of Tic Tac Toe for us. -->

<h2 id="brute-force-negamax">Brute force Negamax</h2>

<p>Here is an implementation of the Negamax algorithm for Tic Tac Toe in Ruby:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="nf">nega_max</span><span class="p">(</span><span class="n">player</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">terminal?</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
    <span class="n">payoff</span><span class="p">(</span><span class="n">player</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
  <span class="k">else</span>
    <span class="n">available_moves</span><span class="p">(</span><span class="n">state</span><span class="p">).</span><span class="nf">map</span> <span class="k">do</span> <span class="o">|</span><span class="n">move</span><span class="o">|</span>
      <span class="n">make</span><span class="p">(</span><span class="n">move</span><span class="p">,</span> <span class="n">player</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
      <span class="n">value_for_move</span> <span class="o">=</span> <span class="o">-</span><span class="n">nega_max</span><span class="p">(</span><span class="n">opponent</span><span class="p">(</span><span class="n">player</span><span class="p">),</span> <span class="n">state</span><span class="p">)</span>
      <span class="n">unmake</span><span class="p">(</span><span class="n">move</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
      <span class="n">value_for_move</span>
    <span class="k">end</span><span class="p">.</span><span class="nf">max</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>The method returns the value of a game state <code class="highlighter-rouge">state</code> for the player <code class="highlighter-rouge">player</code>, assumed to be the player who moves next. This value is the highest payoff that <code class="highlighter-rouge">player</code> can be guaranteed to achieve with optimal play, and it is denoted  with the variable <code class="highlighter-rouge">best_value</code>.</p>

<p>For terminal states, the value of <code class="highlighter-rouge">state</code> for <code class="highlighter-rouge">player</code> is given by the Tic Tac Toe payoff function — that’s the first branch of the conditional:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="n">best_value</span> <span class="o">=</span> <span class="n">payoff</span><span class="p">(</span><span class="n">player</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
</code></pre>
</div>

<p>For non-terminal states, <code class="highlighter-rouge">player</code> has to evaluate all available choices. Suppose she is at the moment looking at one particular move <code class="highlighter-rouge">move</code>. She makes the move (that’s the line <code class="highlighter-rouge">make(move, player, state)</code>, which updates <code class="highlighter-rouge">state</code> as a side-effect), and evaluates the resulting position. She uses our <code class="highlighter-rouge">nega_max</code> method to do this. Assume that the method tells her that the best her opponent can do in the successor state (referenced by <code class="highlighter-rouge">state</code> at this point) is $n$. So what can <code class="highlighter-rouge">player</code> herself achieve by choosing <code class="highlighter-rouge">move</code>? It’s $-n$. Here is why:</p>

<ul>
  <li>If <code class="highlighter-rouge">opponent(player)</code> can guarantee a win, then opponent will get $1$, so <code class="highlighter-rouge">player</code> gets $-1$ if she chooses <code class="highlighter-rouge">move</code>.</li>
  <li>If <code class="highlighter-rouge">opponent(player)</code> can only guarantee a tie, opponent will get $0$, so <code class="highlighter-rouge">player</code> gets $-0$, which is $0$.</li>
  <li>If <code class="highlighter-rouge">opponent(player)</code> is bound to lose, opponent will get $-1$, so <code class="highlighter-rouge">player</code> gets $-(-1)$, which is $1$.</li>
</ul>

<p>So the best <code class="highlighter-rouge">player</code> can guarantee to achieve when choosing <code class="highlighter-rouge">move</code> is indeed $-n$. This explains the crucial line of the method containing the recursive call:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="n">value_for_move</span> <span class="o">=</span> <span class="o">-</span><span class="n">nega_max</span><span class="p">(</span><span class="n">opponent</span><span class="p">(</span><span class="n">player</span><span class="p">),</span> <span class="n">state</span><span class="p">)</span>
</code></pre>
</div>

<p>Notice that this only works because Tic Tac Toe is <em>zero-sum</em>, i.e., one player’s loss is another player’s gain: the payoffs of both players always add up to 0.</p>

<p>Return to <code class="highlighter-rouge">player</code>, who is deliberating which move to take. She proceeds in the manner described, evaluating <em>all</em> her moves. In this way, <code class="highlighter-rouge">player</code> obtains a list of values, one for each move (that list is the return value of the <code class="highlighter-rouge">map</code> invocation). The maximal value from this list is the best she can guarantee, so this is what we return.</p>

<h2 id="the-best-move">The best move</h2>

<h2 id="algorithms">Algorithms</h2>

<ul>
  <li>brute force negamax</li>
  <li>negamax with transposition table</li>
  <li>negamax with symmetry table
    <ul>
      <li>consider: instead of solving all of the eight subtrees of the initial game node, we have to solve just three.</li>
    </ul>
  </li>
  <li>negamax with symmetry lookup</li>
  <li>alpha-beta pruning</li>
  <li>negamax with shortcuts</li>
</ul>

<p>these fall onto a spectrum from “more generic” to “more game-specific”</p>
<ul>
  <li>negamax and negamax with alpha-beta pruning are generic algorithms that work pretty much for every game.</li>
  <li>transposition tables are useful whenever there are several ways to reach the same position.</li>
  <li>symmetry is useful if there are … symmetries!</li>
  <li>the shortcut method makes use of the fact that tic tac toe is solved. so why not use the fact that the best we can guarantee is a tie?</li>
</ul>

<h2 id="results">Results</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: left"> </th>
      <th style="text-align: right">time</th>
      <th style="text-align: right">calls</th>
      <th style="text-align: right">table size</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">brute force</td>
      <td style="text-align: right">5.781872</td>
      <td style="text-align: right">549,946</td>
      <td style="text-align: right">-</td>
    </tr>
    <tr>
      <td style="text-align: left">transposition table</td>
      <td style="text-align: right">0.105050</td>
      <td style="text-align: right">16,168</td>
      <td style="text-align: right">5,477</td>
    </tr>
    <tr>
      <td style="text-align: left">symmetry table</td>
      <td style="text-align: right">0.048830</td>
      <td style="text-align: right">2,271</td>
      <td style="text-align: right">5,477</td>
    </tr>
    <tr>
      <td style="text-align: left">symmetry lookup</td>
      <td style="text-align: right">0.058844</td>
      <td style="text-align: right">2,271</td>
      <td style="text-align: right">764</td>
    </tr>
    <tr>
      <td style="text-align: left">alpha-beta</td>
      <td style="text-align: right">0.193677</td>
      <td style="text-align: right">18,297</td>
      <td style="text-align: right">-</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>549,946 is the size of the 3x3 ttt game tree (i.e., the number of nodes)</li>
  <li>5477 is the number of distinct board positions minus the initial state</li>
  <li>
    <p>764 is the number of board positions up to symmetry minus the initial state</p>
  </li>
  <li>
    <p>In the transposition table case, around 6,000 calls are calls that result (as a side-effect) in values being stored to the lookup table, whereas around 10,000 calls return a looked-up value.</p>
  </li>
  <li>In the symmetry table case, the table is built “much faster”, because whenever we save to the table, we save eight values instead of merely one.</li>
</ul>

<h3 id="time">time</h3>

<ul>
  <li>
    <p>with a symmetry table, we can realize a hundred fold speed increase.</p>
  </li>
  <li>memoizing values is a dramatic improvement over brute force negamax</li>
  <li>exploiting symmetries allows us reduce computation time by half</li>
  <li>saving symmetric values as we compute them seems slightly faster than computing symmetries during lookup</li>
  <li>the memoization approaches are quite a bit faster than alpha-beta-search on a 3x3 board</li>
  <li>(it looks like alpa-beta scales a lot better, viz the results for a 4x4 board)</li>
</ul>

<h3 id="calls">calls</h3>

<ul>
  <li>brute force: the number of method calls is a lot higher than the number of distinct positions, because many positions are computed several times.</li>
  <li>transposition table: with this algorithm, the number of calls is still higher than the number of positions, because it may happen that our negamax method is called for some state, even if that state has been evaluated already and stored … but we still need to retrieve it!</li>
  <li>symmetry table: now the number of calls is lower than the size of the table. this looks certainly odd at first sight. but the thing is that with every function call, we write up to eight new values to the table.</li>
</ul>

<h3 id="method-calls-in-relation-to-time">method calls in relation to time</h3>
<ul>
  <li>the number of method calls does not correlate neatly with computation time spent.</li>
  <li>compare brute force and transposition table: 549946/16168 is about 34, so the evaluation function is called 34 times less when we use the transposition table vs brute force. the speed gain, on the other hand, is around 57-fold. Why is that?</li>
  <li>
    <p>When going from a transposition to a symmetry table, there is a 7-fold decrease in function calls, but the computation time is only halved. Filling in the table entries comes with an extra cost that partially offsets avoiding negamax calls. That seems to be the plausible explanation.</p>
  </li>
  <li><strong>What does the number of method calls actually correspond to?</strong> In brute force negamax, it is simply the number of nodes in the complete game tree (see https://books.google.com/books?id=1xHPDAAAQBAJ&amp;pg=PA151&amp;lpg=PA151&amp;dq=size+of+tic+tac+toe+game+tree&amp;source=bl&amp;ots=J3Tp09kbbL&amp;sig=DJoyUjGx2XGMm-gvMg-QW5bQ8sI&amp;hl=de&amp;sa=X&amp;ved=0ahUKEwivzpGyjpHUAhVG0WMKHVRqD704ChDoAQhXMAc#v=onepage&amp;q=size%20of%20tic%20tac%20toe%20game%20tree&amp;f=false)</li>
</ul>

<h3 id="table-size">table size</h3>

<ul>
  <li>transposition table: there are 5478 distinct positions in 3x3 tic tac toe (see http://www.mathrec.org/old/2002jan/solutions.html). Since we do not store a value for the initial state in the table, our table has 5477 entries.</li>
  <li>symmetry lookup: since we only store a “representative” of each equivalence class, this is a smaller table. there are 765 distinct ttt positions modulo symmetries (see http://www.mathrec.org/old/2002jan/solutions.html), and since we don’t store the initial state, our table has 764 entries.</li>
</ul>

<h3 id="why-is-the-number-of-method-calls-smaller-than-the-number-of-distinct-ttt-positions-when-we-use-a-symmetry-table">Why is the number of method calls smaller than the number of distinct ttt positions when we use a symmetry table?</h3>

<p>This might come as a surprise, because shouldn’t we have to visit every distinct node at least once? well, no, actually! The reason we don’t have to do this is that there are certain positions we never even have to evaluate, because they are descendants of nodes that are symmetric to nodes we have evaluated (if that makes sense).</p>

<h3 id="shortcut">shortcut</h3>

<ul>
  <li>
    <p>suppose we already know that the best we can guarantee is a tie. then we could stop looking for a win (we know we cannot find a guaranteed win path), but instead look for a tie path. this is the idea behind the two “shortcut” algorithms I looked at: one adds the shortcut to the brute force algorithm, the second adds the shortcut to the transposition table. The second one (transposition with shortcut) is the fastest algorithms I considered.</p>
  </li>
  <li>
    <p>there is a pitfall here, however. if we are playing against a less than perfect opponent, than we might miss a chance to score a win if we take the shortcut!</p>
  </li>
</ul>

      </section>
      <header>
  <small>&nbsp;</small>
  <a href="http://notes.benrodenhaeuser.io">
    <h1>Ben Rodenhäuser</h1>
  </a>
  <p>Learning to program</p>
  <hr />
  <p>
      

          <h3>
            <a class="post-link" href="/2017/06/17/Modular-Arithmetic_2/">Modular arithmetic_2</a><span class="pad"></span><small>17 Jun 2017</small>
          </h3>
      

          <h3>
            <a class="post-link" href="/2017/05/31/negamax/">Negamax</a><span class="pad"></span><small>31 May 2017</small>
          </h3>
      

          <h3>
            <a class="post-link" href="/2017/05/15/sorting-in-ruby/">Sorting In Ruby</a><span class="pad"></span><small>15 May 2017</small>
          </h3>
      
  </p>
  <hr />
  <p><small><a href="http://github.com/benrodenhaeuser">GitHub Profile</a></small></p>
</header>

      <!-- <footer>
  <p><small>Ben Rodenhäuser 2017 | <a href="http://github.com/benrodenhaeuser">GitHub Profile</a></small></p>
</footer> -->

    </div>
    <script src="/assets/js/scale.fix.js"></script>
  </body>
</html>
