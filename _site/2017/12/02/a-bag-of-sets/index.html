<!doctype html>
<html lang="en-US">
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <title>Ben Rodenhäuser</title>

  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Roboto+Mono" rel="stylesheet">
  <link rel="stylesheet" href="/assets/css/style.css?v=">
  <script type="text/javascript"
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML&delayStartupUntilConfig">
  </script>
  <script src="/assets/jax/config.js"></script>

  <meta name="viewport" content="width=device-width">
  <!--[if lt IE 9]>
  <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  
    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-99334571-1', 'auto');
        ga('send', 'pageview');
    </script>
  
</head>

  <body>
    <div class="wrapper">
      <section>
      <small>02 December 2017</small>
      <h1 id="a-bag-of-sets">A Bag of Sets</h1>

<p><a href="https://pdxwolfy.wordpress.com">Pete</a> mentioned Ruby’s Set library the other day on the Slack channel, and how it internally uses a hash to store the elements of a set. He also pointed out that hashes can be used for representing multisets (or <em>bags</em>, as multisets are also called). This piqued my interest.</p>

<p>More specifically, I thought that it should be possible to have <code class="highlighter-rouge">Set</code> and <code class="highlighter-rouge">Bag</code> classes share a lot, even most of the same code, as an exercise in <a href="http://www.stroustrup.com/glossary.html#Gpolymorphism">polymorphism</a>.</p>

<p>After all, bags and sets have pretty much the same interface:</p>

<ul>
  <li>we can <em>add</em> elements to, or <em>delete</em> elements from a bag, same as from a set,</li>
  <li>bags can be <em>subsets</em>, or <em>supersets</em> of one another, just as sets,</li>
  <li>we can take the <em>union</em>, <em>intersection</em>, or <em>difference</em> of two bags, just as we can for two sets.</li>
</ul>

<p>The main difference between the two lies in how they count, so this should be the only point were we need code that is specific to each type of object. This post is an account of how I implemented this idea.</p>

<h2 id="sets-and-bags">Sets and bags</h2>

<p>Sets are unordered collections for which element count does not matter. So</p>

<ul>
  <li>$\lbrace a, b, c\rbrace$ and $\lbrace a, c, b\rbrace$ represent the same set (since order does not matter),</li>
  <li>$\lbrace a, b, c\rbrace$ and $\lbrace a, b, c, c\rbrace$ represent the same set (since element count does not matter).</li>
</ul>

<!-- A first smal digression is in order here. Notice that the preceding examples suggest that $\lbrace a, b, c, c\rbrace$ is a perfectly legal set, which is, however, set-theoretically equivalent to the more canonical representation $\lbrace a, b, c\rbrace$. This is not the only perspective one can take on the matter. There is another view according to which "the same element shall not be allowed to appear more than once" in a set. According to that view, $\lbrace a, b, c, c\rbrace$ would not even be a set! However, for our purposes, it is more natural to take the liberal stance of allowing sets with repeated occurences of elements like $\lbrace a, c, b\rbrace$ while identifying them $\lbrace a, c, b\rbrace$. One reason why this is more natural is that it is pretty much how our implementation of sets will turn out to work. -->

<p>For bags, on the other hand, element count does matter. That is,</p>

<ul>
  <li>$\lbrace a, b, c\rbrace$ and $\lbrace a, c, b\rbrace$ represent the same bag, since order (still) does not matter,</li>
  <li>but $\lbrace a, b, c\rbrace$ and $\lbrace a, b, c, c\rbrace$ <em>do not</em> represent the same bag.</li>
</ul>

<p>The number of times an element occurs in a bag is called the <em>multiplicity</em> of that element, and the size of the bag is the sum of the multiplicity of its elements.</p>

<h2 id="characteristic-functions-and-multiplicity-functions">Characteristic functions and multiplicity functions</h2>

<p>Sets whose elements are drawn from a given domain (i.e., another set) can be represented by what is called a <em>characteristic function</em>, which specifies for each element of the domain whether it is an element of the set in question.</p>

<p>Suppose that our domain is the characters in the Roman alphabet. Then we can represent the set $\lbrace a, b, c\rbrace$ by means of the function that maps the characters $a$, $b$ and $c$ to $1$ (indicating that they are elements of the set), while mapping all other characters to $0$ (indicating that they are not elements of the set). So sets can be defined as maps from a given universe of objects to the set $\lbrace 0, 1\rbrace$.</p>

<p>This approach can be generalized to bags. Instead of mapping elements to either one of $0$ or $1$, we map them to their element count in the bag. This means that the bag $\lbrace a, b, c, c\rbrace$ would be defined by the function that maps $a$ and $b$ to $1$, $c$ to $2$, and all other characters in the Roman alphabet to $0$.</p>

<p>Such a function is called a multiplicity function.</p>

<p>This perspective on the matter is useful for our purposes for two reasons. First, a characteristic function (be it for a set or a bag) can be neatly captured by a hash table, which is just what we are after. Second, viewing sets and bags through the lens of characteristic functions paves the way towards implementing operations on both types of objects in a uniform way.</p>

<p>As an example, consider the union operation. For two sets given by their characteristic function.</p>

<h2 id="setting-up-the-bag-and-set-classes">Setting up the Bag and Set classes</h2>

<p>Let’s start with the basic setup of our <code class="highlighter-rouge">Bag</code> and <code class="highlighter-rouge">Set</code> classes. We will expand the capabilities of both classes as we go along.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Bag</span>
  <span class="kp">include</span> <span class="no">Enumerable</span>

  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">enum</span> <span class="o">=</span> <span class="p">[])</span>
    <span class="vi">@hash</span> <span class="o">=</span> <span class="no">Hash</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">merge</span><span class="p">(</span><span class="n">enum</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">indicator</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
    <span class="vi">@hash</span><span class="p">[</span><span class="n">elem</span><span class="p">]</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">count</span><span class="p">(</span><span class="n">elem</span> <span class="o">=</span> <span class="kp">nil</span><span class="p">)</span>
    <span class="n">elem</span> <span class="p">?</span> <span class="n">indicator</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span> <span class="p">:</span> <span class="n">size</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">each</span>
    <span class="k">return</span> <span class="n">to_enum</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:each</span><span class="p">)</span> <span class="k">unless</span> <span class="nb">block_given?</span>
    <span class="vi">@hash</span><span class="p">.</span><span class="nf">each_key</span> <span class="p">{</span> <span class="o">|</span><span class="n">elem</span><span class="o">|</span> <span class="n">count</span><span class="p">(</span><span class="n">elem</span><span class="p">).</span><span class="nf">times</span> <span class="p">{</span> <span class="k">yield</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span> <span class="p">}</span> <span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Set</span> <span class="o">&lt;</span> <span class="no">Bag</span>
  <span class="k">def</span> <span class="nf">indicator</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
    <span class="vi">@hash</span><span class="p">[</span><span class="n">elem</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">?</span> <span class="mi">1</span> <span class="p">:</span> <span class="mi">0</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>As announced, we use a hash, referenced by the instance variable <code class="highlighter-rouge">@hash</code>, as an internal storage device for <code class="highlighter-rouge">Bag</code> objects. The intent is that <code class="highlighter-rouge">@hash[elem] == 0</code> indicates that a given <code class="highlighter-rouge">elem</code> is <em>not</em> a member of our collection, while <code class="highlighter-rouge">@hash[elem] &gt; 0</code> indicates that <code class="highlighter-rouge">elem</code> <em>is</em> a member of our collection.</p>

<p>The intent is that the presence of a particular hash key indicates that the object given by the key is part of the set, and the value for a particular key indicates the count of the object.</p>

<p>For plain sets, this is really all we need to know. For multisets, or bags, as they are also called, their count also matters. The count will be given by the value stored in a hash for a particular key. To see how this works out, lets implement a couple more methods.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9</pre></td><td class="code"><pre><span class="n">enum</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="n">set</span> <span class="o">=</span> <span class="no">Set</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">enum</span><span class="p">)</span>
<span class="n">bag</span> <span class="o">=</span> <span class="no">Bag</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">enum</span><span class="p">)</span>

<span class="n">set</span><span class="p">.</span><span class="nf">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">elem</span><span class="o">|</span> <span class="nb">puts</span> <span class="n">elem</span> <span class="p">}</span> <span class="c1"># output: 1 2 3</span>
<span class="n">bag</span><span class="p">.</span><span class="nf">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">elem</span><span class="o">|</span> <span class="nb">puts</span> <span class="n">elem</span> <span class="p">}</span> <span class="c1"># output: 1 2 3 3</span>

<span class="n">set</span><span class="p">.</span><span class="nf">count</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="c1">#=&gt; 1</span>
<span class="n">bag</span><span class="p">.</span><span class="nf">count</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="c1">#=&gt; 2</span>
</pre></td></tr></tbody></table>
</div>
</div>

<h2 id="topics-for-discussion">Topics for discussion</h2>

<ul>
  <li>definition of <code class="highlighter-rouge">count</code> in terms of <code class="highlighter-rouge">indicator</code></li>
  <li>illustrate the consequences: <code class="highlighter-rouge">each</code></li>
  <li>set interface: like multiset, but don’t care about values in internal hash –
override <code class="highlighter-rouge">count</code> method</li>
  <li>interface difference: each: yield without repetitions</li>
  <li>use of eql? and hash methods</li>
  <li>set equality can be defined in terms of subset relation</li>
</ul>

<p>Maybe build both classes (bag and set) as we go?</p>

<p>… For recapitulation, this is the code we have so far:</p>

      <div class="pad"></div><hr class="line" /><div class="triplepad"></div>
      </section>
      <header>
  <small>&nbsp;</small>
  <a href="http://notes.benrodenhaeuser.io">
    <h1>Ben Rodenhäuser</h1>
  </a>
  <p>Learning to program</p>
  <hr class="line" />
  <p>
      

          <h3>
            <a class="post-link" href="/2017/12/02/a-bag-of-sets/">A Bag Of Sets</a><span class="pad"></span><small>02 Dec 2017</small>
          </h3>
      

          <h3>
            <a class="post-link" href="/2017/10/28/subproblems/">Subproblems</a><span class="pad"></span><small>28 Oct 2017</small>
          </h3>
      

          <h3>
            <a class="post-link" href="/2017/07/06/object-passing/">Object Passing</a><span class="pad"></span><small>06 Jul 2017</small>
          </h3>
      

          <h3>
            <a class="post-link" href="/2017/05/31/negamax/">Negamax</a><span class="pad"></span><small>31 May 2017</small>
          </h3>
      

          <h3>
            <a class="post-link" href="/2017/05/15/sorting-in-ruby/">Sorting In Ruby</a><span class="pad"></span><small>15 May 2017</small>
          </h3>
      
  </p>
  <hr class="line" />
  <p><small><a href="http://github.com/benrodenhaeuser">GitHub Profile</a></small></p>
</header>

      <!-- <footer>
  <p><small>Ben Rodenhäuser 2017 | <a href="http://github.com/benrodenhaeuser">GitHub Profile</a></small></p>
</footer> -->

    </div>
    <script src="/assets/js/scale.fix.js"></script>
  </body>
</html>
