<!doctype html>
<html lang="en-US">
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <title>Ben Rodenhäuser | Notes on programming</title>

  <link href="https://fonts.googleapis.com/css?family=Lato|Anton|Roboto Mono" rel="stylesheet">
  <link rel="stylesheet" href="/assets/css/main.css?v=">
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    CommonHTML: { linebreaks: { automatic: true } },
    "HTML-CSS": { linebreaks: { automatic: true } },
           SVG: { linebreaks: { automatic: true } }
  });
  </script>
  <script type="text/javascript"
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML&delayStartupUntilConfig">
  </script>
  <script src="/assets/jax/config.js"></script>

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!--[if lt IE 9]>
  <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  
    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-99334571-1', 'auto');
        ga('send', 'pageview');
    </script>
  
</head>

  <body>
    <div class="wrapper">
      <section>
  <p>
    <small>
      19 December 2017
    </small>
  </p>

  <h1 class="title">
    Operations on Sets
  </h1>

  <div class="description">
    Part 03 of the "Bunch of Sets" series.
  </div>

  <div class="content">
    <hr class="line" />
    <div class="content-inner">
      <blockquote class="aside">
  <p>This is the last part of a three part series that starts <a href="/2017/12/17/a-bunch-of-sets/">here</a>.</p>
</blockquote>

<p>The <code class="highlighter-rouge">SetMap</code> class discussed in the <a href="http://localhost:4000/2017/12/18/the-set-map-class/">previous entry</a> essentially serves as a wrapper around our hash table. We have also implemented a mechanism for specifying what constitutes a valid score for a given type of set. And we have provided our three target classes that inherit from <code class="highlighter-rouge">SetMap</code>. The basics of our model are thus in place.</p>

<p>What remains to be implemented is all the interesting operations on sets! The remaining part of the interface will, however, not interact with the internally used hash table directly, but only through the interface developed so far.</p>

<p>For the purpose of implementing those additional operations, we open a new module <code class="highlighter-rouge">SetLike</code>, which we include in <code class="highlighter-rouge">SetMap</code>. Since our target classes <code class="highlighter-rouge">ClassicalSet</code>, <code class="highlighter-rouge">FuzzySet</code> and <code class="highlighter-rouge">MultiSet</code> inherit from <code class="highlighter-rouge">SetMap</code>, they will also be able to access the functionality provided by <code class="highlighter-rouge">SetLike</code>.</p>

<h3 id="division-of-labor">Division of Labor</h3>

<p>The division of labor we adopt here takes a cue from the place the <code class="highlighter-rouge">Enumerable</code> module occupies in Ruby’s design. <code class="highlighter-rouge">Enumerable</code> provides a number of useful methods for working with collections to any class that chooses to include it. In doing so, <code class="highlighter-rouge">Enumerable</code> assumes that the class implements an <code class="highlighter-rouge">each</code> method, which forms the basis for all the methods <code class="highlighter-rouge">Enumerable</code> defines. Beyond this, however, <code class="highlighter-rouge">Enumerable</code> does not (need to) know anything about the class using it. Here, we do something very similar:</p>

<ul>
  <li><code class="highlighter-rouge">SetLike</code> provides most of the functionality commonly associated with sets.</li>
  <li><code class="highlighter-rouge">SetLike</code> assumes that any class that uses it implements the instance methods <code class="highlighter-rouge">retrieve</code>, <code class="highlighter-rouge">insert</code>, <code class="highlighter-rouge">delete</code>, <code class="highlighter-rouge">each</code> and <code class="highlighter-rouge">size</code>.</li>
  <li><code class="highlighter-rouge">SetLike</code> does not make any further assumptions about the internals of the class using it.</li>
</ul>

<p>In particular, none of the methods in <code class="highlighter-rouge">SetLike</code> need to know that we are using a hash for internal storage. This draws a distinction between methods that do need to know that we have chosen to represent sets with hash tables (they go in the <code class="highlighter-rouge">SetMap</code> class), and methods that don’t need to know this (they go in the <code class="highlighter-rouge">SetLike</code> module), and thus encapsulates the internal state of a set in <code class="highlighter-rouge">SetMap</code>. As long as we keep the public interface of <code class="highlighter-rouge">SetMap</code> stable, we could just as well reimplement all its methods using a binary search tree instead of a hash for storing a set, say: <code class="highlighter-rouge">SetLike</code> will not care.</p>

<h3 id="operations-on-sets">Operations on sets</h3>

<p>We would like to implement the usual operations on sets, like <code class="highlighter-rouge">union</code>, <code class="highlighter-rouge">intersection</code>, and <code class="highlighter-rouge">difference</code>. Since they all follow essentially the same pattern, we focus on just one of them, <code class="highlighter-rouge">union!</code> (the  destructive version of <code class="highlighter-rouge">union</code>).</p>

<p>Following the example established by Ruby’s <a href="https://github.com/ruby/ruby/blob/trunk/lib/set.rb"><code class="highlighter-rouge">Set</code> class</a>, we first implement a helper method <code class="highlighter-rouge">SetLike#do_with</code> that yields to a block:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">do_with</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
  <span class="k">unless</span> <span class="n">other</span><span class="p">.</span><span class="nf">instance_of?</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="nf">class</span><span class="p">)</span>
    <span class="k">raise</span> <span class="no">SetError</span><span class="p">,</span> <span class="s2">"</span><span class="si">#{</span><span class="nb">self</span><span class="p">.</span><span class="nf">class</span><span class="si">}</span><span class="s2"> instance needed"</span>
  <span class="k">end</span>

  <span class="k">return</span> <span class="n">other</span><span class="p">.</span><span class="nf">each</span> <span class="k">unless</span> <span class="nb">block_given?</span>
  <span class="n">other</span><span class="p">.</span><span class="nf">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="o">|</span> <span class="k">yield</span><span class="p">([</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">])</span> <span class="p">}</span>
<span class="k">end</span>
<span class="kp">private</span> <span class="ss">:do_with</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>This methods takes care of the type-checking for us. We would not, e.g., want to subtract a fuzzy set from a classical set, as the result will not in general be a classical set. The above guard clause ensures that the operations we will define are only carried out for two objects that belong to the same target class. Beyond this, <code class="highlighter-rouge">do_with</code> simply yields the key-value pairs of the set passed to it as an argument. Using <code class="highlighter-rouge">do_with</code>, we implement <code class="highlighter-rouge">union!</code> as follows:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">union!</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
  <span class="n">do_with</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">key</span><span class="p">,</span> <span class="n">_</span><span class="o">|</span>
    <span class="nb">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">self</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">other</span><span class="p">[</span><span class="n">key</span><span class="p">]].</span><span class="nf">max</span>
  <span class="k">end</span>
  <span class="nb">self</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>The union of a given set with another one is defined by maximizing scores for given keys across the two sets. This is how the union is usually defined, and it yields the expected results.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8</pre></td><td class="code"><pre><span class="c1"># SetMap::from_hash(hsh) creates a new set instance and populates it</span>
<span class="c1"># with the key-value pairs from the given hash `hsh`</span>

<span class="n">multi_set1</span> <span class="o">=</span> <span class="no">MultiSet</span><span class="p">.</span><span class="nf">from_hash</span><span class="p">(</span><span class="mi">2</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span> <span class="o">=&gt;</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">multi_set2</span> <span class="o">=</span> <span class="no">MultiSet</span><span class="p">.</span><span class="nf">from_hash</span><span class="p">(</span><span class="mi">2</span> <span class="o">=&gt;</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">multi_set1</span><span class="p">.</span><span class="nf">union!</span><span class="p">(</span><span class="n">multi_set2</span><span class="p">)</span>

<span class="n">multi_set1</span> <span class="o">==</span> <span class="no">MultiSet</span><span class="p">.</span><span class="nf">from_hash</span><span class="p">(</span><span class="mi">2</span> <span class="o">=&gt;</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="o">=&gt;</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># true</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p><code class="highlighter-rouge">union!</code> implements a notion of “combining what is contained in two given sets”. There is a similar, yet slightly different notion which is interesting from the perspective of our polymorphic approach: the <em>sum</em> of two sets. So let’s briefly digress:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">sum!</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
  <span class="n">do_with</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="p">{</span> <span class="o">|</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="o">|</span> <span class="n">insert</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="p">}</span>
  <span class="nb">self</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>Rather than maximizing scores, as <code class="highlighter-rouge">union!</code> did, <code class="highlighter-rouge">sum!</code> adds the scores given by the other set to the scores of the receiver. For classical sets, <code class="highlighter-rouge">sum!</code> and <code class="highlighter-rouge">union!</code> amount to the very same thing:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10</pre></td><td class="code"><pre><span class="c1"># SetMap::[](*list) creates a new set instance and turns the</span>
<span class="c1"># members of `list` into keys of the new instance.</span>

<span class="n">set1</span> <span class="o">=</span> <span class="no">ClassicalSet</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="n">set2</span> <span class="o">=</span> <span class="no">ClassicalSet</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>

<span class="n">set3</span> <span class="o">=</span> <span class="no">ClassicalSet</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="n">set4</span> <span class="o">=</span> <span class="no">ClassicalSet</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>

<span class="n">set1</span><span class="p">.</span><span class="nf">union!</span><span class="p">(</span><span class="n">set2</span><span class="p">)</span> <span class="o">==</span> <span class="n">set3</span><span class="p">.</span><span class="nf">sum!</span><span class="p">(</span><span class="n">set4</span><span class="p">)</span> <span class="c1"># true</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>This is why Ruby’s own <code class="highlighter-rouge">Set</code> class simply defines <code class="highlighter-rouge">+</code> (the sum operator) to be an alias of <code class="highlighter-rouge">|</code> (the union operator). However, for other types of sets, sum and union are not always the same. This is because taking the maximum of two scores is not generally the same as summing up those two scores! For example:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11</pre></td><td class="code"><pre><span class="n">set1</span> <span class="o">=</span> <span class="no">FuzzySet</span><span class="p">.</span><span class="nf">from_hash</span><span class="p">(</span><span class="mi">2</span> <span class="o">=&gt;</span> <span class="mi">0</span><span class="o">.</span><span class="mi">4</span><span class="p">)</span>
<span class="n">set2</span> <span class="o">=</span> <span class="no">FuzzySet</span><span class="p">.</span><span class="nf">from_hash</span><span class="p">(</span><span class="mi">2</span> <span class="o">=&gt;</span> <span class="mi">0</span><span class="o">.</span><span class="mi">3</span><span class="p">)</span>

<span class="n">set3</span> <span class="o">=</span> <span class="no">FuzzySet</span><span class="p">.</span><span class="nf">from_hash</span><span class="p">(</span><span class="mi">2</span> <span class="o">=&gt;</span> <span class="mi">0</span><span class="o">.</span><span class="mi">4</span><span class="p">)</span>
<span class="n">set4</span> <span class="o">=</span> <span class="no">FuzzySet</span><span class="p">.</span><span class="nf">from_hash</span><span class="p">(</span><span class="mi">2</span> <span class="o">=&gt;</span> <span class="mi">0</span><span class="o">.</span><span class="mi">3</span><span class="p">)</span>

<span class="n">set1</span><span class="p">.</span><span class="nf">sum!</span><span class="p">(</span><span class="n">set2</span><span class="p">)</span>
<span class="n">set3</span><span class="p">.</span><span class="nf">union!</span><span class="p">(</span><span class="n">set4</span><span class="p">)</span>

<span class="n">set1</span> <span class="o">==</span> <span class="no">FuzzySet</span><span class="p">.</span><span class="nf">from_hash</span><span class="p">(</span><span class="mi">2</span> <span class="o">=&gt;</span> <span class="mi">0</span><span class="o">.</span><span class="mi">7</span><span class="p">)</span> <span class="c1"># true</span>
<span class="n">set3</span> <span class="o">==</span> <span class="no">FuzzySet</span><span class="p">.</span><span class="nf">from_hash</span><span class="p">(</span><span class="mi">2</span> <span class="o">=&gt;</span> <span class="mi">0</span><span class="o">.</span><span class="mi">4</span><span class="p">)</span> <span class="c1"># true</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>Our model captures all of this correctly.</p>

<h3 id="set-predicates">Set predicates</h3>

<p>A classical set <code class="highlighter-rouge">A</code> is a subset of a classical set of <code class="highlighter-rouge">B</code> if any element of <code class="highlighter-rouge">A</code> is also an element of <code class="highlighter-rouge">B</code>. This can be expressed in terms of keys and their associated scores by saying that the score for any key in <code class="highlighter-rouge">A</code> is less than or equal to the score for that same key in <code class="highlighter-rouge">B</code>. This definition also applies to multisets, and fuzzy sets, so that, again, a common implementation is possible. Here is a first stab at the <code class="highlighter-rouge">SetLike#subset?</code> method:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">subset?</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
  <span class="k">return</span> <span class="kp">false</span> <span class="k">unless</span> <span class="n">other</span><span class="p">.</span><span class="nf">instance_of?</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="nf">class</span><span class="p">)</span>

  <span class="n">all?</span> <span class="k">do</span> <span class="o">|</span><span class="n">key</span><span class="p">,</span> <span class="n">_</span><span class="o">|</span>
    <span class="nb">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">other</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
  <span class="k">end</span>
<span class="k">end</span>
<span class="k">alias</span> <span class="o">&lt;=</span> <span class="n">subset?</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>Following the pattern established by the <code class="highlighter-rouge">do_with</code> method discussed above, however, it makes sense to extract the “key comparison” functionality to a separate <code class="highlighter-rouge">compare_with?</code> method that takes a block (you may want to check out the <a href="https://github.com/maraigue/multiset/blob/master/lib/multiset.rb">code of the multiset gem</a>—the gem author does exactly this).</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">keys</span>
  <span class="n">each</span><span class="p">.</span><span class="nf">map</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:first</span><span class="p">)</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">compare_with?</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
  <span class="k">return</span> <span class="kp">false</span> <span class="k">unless</span> <span class="n">other</span><span class="p">.</span><span class="nf">instance_of?</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="nf">class</span><span class="p">)</span>

  <span class="p">(</span><span class="n">keys</span> <span class="o">|</span> <span class="n">other</span><span class="p">.</span><span class="nf">keys</span><span class="p">).</span><span class="nf">all?</span> <span class="k">do</span> <span class="o">|</span><span class="n">key</span><span class="o">|</span>
    <span class="k">yield</span><span class="p">(</span><span class="nb">self</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">other</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>According to line 2 above, the keys of a set object are given by the first component of each key-value pair. <code class="highlighter-rouge">SetLike#compare_with?</code> then iterates over the keys of both <code class="highlighter-rouge">self</code> and <code class="highlighter-rouge">other</code>, and yields the corresponding values to the block. This allows us to implement <code class="highlighter-rouge">subset?</code> as follows:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">subset?</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
  <span class="n">compare_with?</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">s</span><span class="p">,</span> <span class="n">o</span><span class="o">|</span>
    <span class="n">s</span> <span class="o">&lt;=</span> <span class="n">o</span>
  <span class="k">end</span>
<span class="k">end</span>
<span class="k">alias</span> <span class="o">&lt;=</span> <span class="n">subset?</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>Definitions for the other common set predicates (<code class="highlighter-rouge">proper_subset?</code>, <code class="highlighter-rouge">superset?</code> and <code class="highlighter-rouge">proper_superset?</code>) are similar, so we omit them here.</p>

<h3 id="equivalence">Equivalence</h3>

<p>When are two sets <code class="highlighter-rouge">A</code> and <code class="highlighter-rouge">B</code> the same? Again, there is an answer that works for all three target classes: the two sets should be in a mutual inclusion relation, i.e., <code class="highlighter-rouge">A</code> should be a subset of <code class="highlighter-rouge">B</code>, and <code class="highlighter-rouge">B</code> a subset of <code class="highlighter-rouge">A</code>. However, invoking <code class="highlighter-rouge">subset?</code> twice seems slightly redundant, since in the worst case, this amounts to performing every comparison twice. Using the <code class="highlighter-rouge">compare_with?</code> method defined above, we can more simply write the following code:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">equivalent?</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
  <span class="n">compare_with?</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">s</span><span class="p">,</span> <span class="n">o</span><span class="o">|</span>
    <span class="n">s</span> <span class="o">==</span> <span class="n">o</span>
  <span class="k">end</span>
<span class="k">end</span>
<span class="k">alias</span> <span class="o">==</span> <span class="n">equivalent?</span>
<span class="k">alias</span> <span class="nb">eql?</span> <span class="n">equivalent?</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>Notice that we have aliassed the <code class="highlighter-rouge">equivalent?</code> method both as <code class="highlighter-rouge">==</code> and <code class="highlighter-rouge">eql?</code>. We have already taken the <code class="highlighter-rouge">==</code> method for granted in some earlier snippets. Now what about <code class="highlighter-rouge">eql?</code>? This brings us to our final topic for today:</p>

<h3 id="nested-sets">Nested sets</h3>

<p>Unless overridden, the <code class="highlighter-rouge">Object#eql?</code> method considers two objects to be the same if they are identical (i.e., are stored at the same location in memory). In the current context, overriding <code class="highlighter-rouge">Object#eql?</code> is critical, because <code class="highlighter-rouge">eql?</code> is the method that Ruby uses when accessing hash keys. Let’s leave the context of our <code class="highlighter-rouge">SetLike</code> module for a moment, and consider this line of Ruby code:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre><span class="n">some_hash</span><span class="p">[</span><span class="n">some_obj</span><span class="p">]</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>When executing this line, Ruby will check if there is a key <code class="highlighter-rouge">key</code> to be found in <code class="highlighter-rouge">some_hash</code> with the property that <code class="highlighter-rouge">some_obj.eql?(key)</code>. If so, the value for <code class="highlighter-rouge">key</code> will be returned.</p>

<p>For our purposes, this process of looking up keys in a hash is crucial because (1) we are using hashes for storing set membership information, and (2) we would like to be able to model <em>nested</em> sets, which are sets that have sets among their keys. Consider:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9</pre></td><td class="code"><pre><span class="c1"># SetMap::[](*list) creates a new set instance and turns the</span>
<span class="c1"># members of `list` into keys of the new instance.</span>

<span class="n">set1</span> <span class="o">=</span> <span class="no">ClassicalSet</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="n">set2</span> <span class="o">=</span> <span class="no">ClassicalSet</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="n">set3</span> <span class="o">=</span> <span class="no">ClassicalSet</span><span class="p">[</span><span class="n">set1</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="n">set4</span> <span class="o">=</span> <span class="no">ClassicalSet</span><span class="p">[</span><span class="n">set2</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>

<span class="n">set3</span> <span class="o">==</span> <span class="n">set4</span> <span class="c1">#=&gt; ?</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>Now the question is whether <code class="highlighter-rouge">set3</code> and <code class="highlighter-rouge">set4</code> are the same set. It seems that the answer should be yes, because, after all, they <em>contain the same elements</em>. Assume, however, for a moment that we had not overridden <code class="highlighter-rouge">eql?</code>. Then <code class="highlighter-rouge">set3</code> and <code class="highlighter-rouge">set4</code> do <em>not</em> come out the same in the sense of <code class="highlighter-rouge">==</code> because <code class="highlighter-rouge">set1</code> and <code class="highlighter-rouge">set2</code> do not reference the same object, which implies that <code class="highlighter-rouge">set3[set1] == set4[set1]</code> will return false, for the simple reason that <code class="highlighter-rouge">set1</code> is not considered a key in the set <code class="highlighter-rouge">other</code>, since it is not the case that <code class="highlighter-rouge">set2.eql?(set1)</code>. So overriding <code class="highlighter-rouge">eql?</code>, like we did above, is indeed critical.</p>

<h3 id="the-hash-method">The <code class="highlighter-rouge">hash</code> method</h3>

<p>As a final aside: For our set comparisons to work, we also need to override the <code class="highlighter-rouge">Object#hash</code> method so as to ensure that two set objects that are <code class="highlighter-rouge">eql?</code> have the same return value when <code class="highlighter-rouge">hash</code> is called on them. This can be achieved, e.g., like this:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">hash</span>
  <span class="n">each</span><span class="p">.</span><span class="nf">map</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:hash</span><span class="p">).</span><span class="nf">sum</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>Here, we simply map each key-value pair (a two-element array) yielded by <code class="highlighter-rouge">each</code> to its <code class="highlighter-rouge">hash</code> value and sum up the result, trusting that <code class="highlighter-rouge">Array#hash</code> is implemented in a meaningful way. And this indeed ensures that <code class="highlighter-rouge">eql?</code> sets have the same <code class="highlighter-rouge">hash</code> return value.</p>

<h3 id="coda">Coda</h3>

<p>What has been achieved? As mentioned at the beginning of part 01, the set functionality that we have discussed is either readily available as part of Ruby’s Standard Library (for classical sets), or via an easily accesible Ruby gem (for multisets). However, the code presented here presents a <em>uniform</em> perspective on classical sets and multisets. While I have written <code class="highlighter-rouge">SetMap</code> and its child classes as an exercise for myself, I consider this uniformity an advantage over the pre-existing implementation. We have also seen how easily the approach generalizes to further use cases by considering fuzzy sets.</p>

<p>While coming up with a first working implementation of the types of sets discussed here was pretty straightforward, arriving at a way to structure and modularize my code that I found convincing myself required me to go back to the drawing board several times. If you have a chance to <a href="https://github.com/benrodenhaeuser/sets">check out my code</a>, your feedback would be greatly appreciated.</p>

    </div>
  </div>

  <p class='terminal'>
    <small>&nbsp;</small>
  </p>
  <hr class="line" />
</section>

      <header>
  <p>
    <small>&nbsp;</small>
  </p>
  <a href="http://notes.benrodenhaeuser.io">
    <h1 class="title">
      Ben Rodenhäuser
    </h1>
  </a>

  <div class="description site-description">
    Notes on programming
  </div>

  <div class="content">
    <hr class="line" />

    <div class="sidebar-content">
      
      <h5>
        <a class="post-link" href="/2018/06/04/frankie-likes-cookies/">Frankie Likes Cookies</a><span class="sidebar-pad"></span><small>06/04/18</small>
      </h5>
      <p class="sidebar">
          Working with Rack middleware: part 04 of the "Understanding Sinatra" series.
      </p>
      
      <h5>
        <a class="post-link" href="/2018/06/03/frankie-recognizes-patterns/">Frankie Recognizes Patterns</a><span class="sidebar-pad"></span><small>06/03/18</small>
      </h5>
      <p class="sidebar">
          Defining parametrized routes: part 03 of the "Understanding Sinatra" series.
      </p>
      
      <h5>
        <a class="post-link" href="/2018/06/02/frankie-goes-top-level/">Frankie Goes Top Level</a><span class="sidebar-pad"></span><small>06/02/18</small>
      </h5>
      <p class="sidebar">
          The top-level DSL: part 02 of the "Understanding Sinatra" series.
      </p>
      
      <h5>
        <a class="post-link" href="/2018/06/01/understanding-sinatra/">Understanding Sinatra</a><span class="sidebar-pad"></span><small>06/01/18</small>
      </h5>
      <p class="sidebar">
          Hello Frankie: building a toy version of a Ruby web framework from the ground up.
      </p>
      
      <h5>
        <a class="post-link" href="/2017/12/19/operations-on-sets/">Operations on Sets</a><span class="sidebar-pad"></span><small>12/19/17</small>
      </h5>
      <p class="sidebar">
          Part 03 of the "Bunch of Sets" series.
      </p>
      
      <h5>
        <a class="post-link" href="/2017/12/18/modeling-sets/">Modeling Sets</a><span class="sidebar-pad"></span><small>12/18/17</small>
      </h5>
      <p class="sidebar">
          Part 02 of the "Bunch of Sets" series.
      </p>
      
      <h5>
        <a class="post-link" href="/2017/12/17/a-bunch-of-sets/">A Bunch of Sets</a><span class="sidebar-pad"></span><small>12/17/17</small>
      </h5>
      <p class="sidebar">
          A generic implementation of classical sets, multisets and fuzzy sets in Ruby.
      </p>
      
      <h5>
        <a class="post-link" href="/2017/07/06/object-passing/">Passing Objects</a><span class="sidebar-pad"></span><small>07/06/17</small>
      </h5>
      <p class="sidebar">
          Pass by reference or pass by value? The object passing strategy followed by Ruby.
      </p>
      
      <h5>
        <a class="post-link" href="/2017/05/15/sorting-in-ruby/">Sorting in Ruby</a><span class="sidebar-pad"></span><small>05/15/17</small>
      </h5>
      <p class="sidebar">
          Why does Ruby have two sorting methods, rather than one?
      </p>
      
    </div>

    <hr class="line" />

    <div class="external">
      <a href="http://github.com/benrodenhaeuser">
        <img class="mark" src="/assets/images/GitHub-Mark-64px.png" />
      </a>
    </div>
  </div>
</header>

      <!-- <footer>
  <p><small>Ben Rodenhäuser 2017 | <a href="http://github.com/benrodenhaeuser">GitHub Profile</a></small></p>
</footer> -->

    </div>
    <script src="/assets/js/scale.fix.js"></script>
  </body>
</html>
  

