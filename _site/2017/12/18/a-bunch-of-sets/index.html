<!doctype html>
<html lang="en-US">
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <title>Ben Rodenhäuser</title>

  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Roboto+Mono" rel="stylesheet">
  <link rel="stylesheet" href="/assets/css/style.css?v=">
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    CommonHTML: { linebreaks: { automatic: true } },
    "HTML-CSS": { linebreaks: { automatic: true } },
           SVG: { linebreaks: { automatic: true } }
  });
  </script>
  <script type="text/javascript"
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML&delayStartupUntilConfig">
  </script>
  <script src="/assets/jax/config.js"></script>

  <meta name="viewport" content="width=device-width">
  <!--[if lt IE 9]>
  <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  
    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-99334571-1', 'auto');
        ga('send', 'pageview');
    </script>
  
</head>

  <body>
    <div class="wrapper">
      <section>
      <small>18 December 2017</small>
      <h1 id="a-bunch-of-sets">A Bunch of Sets</h1>

<p>Ruby comes with a <a href="https://github.com/ruby/ruby/blob/trunk/lib/set.rb"><code class="highlighter-rouge">Set</code> class</a> as part of its standard library, and there is also a <a href="https://github.com/maraigue/multiset/blob/master/lib/multiset.rb"><code class="highlighter-rouge">Multiset</code> class</a> available as a gem. Both classes uses hashes internally. However, the two libraries are completely separate, so, of course, they do not share any code. This is somewhat regrettable, since—as we will see during the course of this post—sets and multisets have quite a bit in common. For this reason, I thought that it would be a nice exercise to write a more generic set class from scratch that would allow us to derive the functionality provided by the above-mentioned classes by inheritance. For good measure, I decided to throw fuzzy sets into the mix, another type of set with useful applications. The result could be called a polymorphic approach to modeling various types of sets in Ruby. This post is a tutorial-style presentation of what I came up with. If you don’t care much for lengthy explanations, head <a href="https://github.com/benrodenhaeuser/sets">straight to Github</a> to have a look at the code.</p>

<h2 id="classical-sets-multisets-and-fuzzy-sets">Classical sets, multisets, and fuzzy sets</h2>

<p>Let’s first get an overview of the types of collections we are interested in by means of some quick examples.</p>

<p><strong>Classical Sets.</strong> Supppose we wanted to concisely represent the letters occuring in a word, while disregarding their sequential order as well as the number of times they occur in the word. A classical set would be a good choice of data structure for this task. For instance, the word “$\text{learner}$” could be represented by the set</p>

<script type="math/tex; mode=display">\lbrace a, e, l, r, n \rbrace.</script>

<p>Incidentally, the word “$\text{learn}$” corresponds to the same classical set, as it contains the same letters. The word “$\text{land}$”, on the other hand, corresponds to the set</p>

<script type="math/tex; mode=display">\lbrace a, l, n, d \rbrace.</script>

<p>Taking the intersection of the two sets, which collects the elements occuring in both of them, we obtain the set $\lbrace a, l, n\rbrace$, which captures the overlap of the two words in terms of letters contained—a crude measure of what they have in common. So sets allow us to zoom in on questions of membership, while disregarding other aspects of particular entities we wish to study.</p>

<p><strong>Multisets.</strong> Suppose now we would like to count <em>how often</em> letters occur in a given word or text, while (still) disregarding their order. A multiset would be an appropriate data structure to accomplish this. For example, the above word “$\text{learner}$” corresponds to the multiset</p>

<script type="math/tex; mode=display">\lbrace a, e, e, l, r, r, n \rbrace</script>

<p>Notice that the word “$\text{learn}$” would be represented by a different multiset, namely $\lbrace a, e, l, r, n \rbrace$. So multisets make finer distinctions than classical sets.</p>

<p>A more concise way to represent a multiset is by means of key-value notation. In this notation, our multiset representation of the word “$\text{learner}$” would be written as</p>

<script type="math/tex; mode=display">\lbrace a: 1, e: 2, l: 1, r: 2, n: 1\rbrace</script>

<p>In a programming context, the elements of a set (be it a classical set or a multiset) are often called <em>keys</em>. The above multiset has five distinct keys: $a$, $e$, $l$, $r$ and $n$. In a multiset, each key comes with a count, the value associated with the key, which we will refer to as the <em>score</em> for that key. The score for the key $e$ in the above multiset, for example, is $2$.</p>

<p><strong>Fuzzy sets.</strong> Fuzzy sets also make finer distinctions compared to classical sets. However, they generalize classical sets in a different direction. As we just saw, in a multiset, the score for a particular key represents <em>multiplicity</em> of membership (how many times does the key occur in the set?). In a fuzzy set, the score indicates <em>degree of membership</em>. So besides an element being “fully contained” in the set or “not contained”, it may also be “partially contained” in the set, so to speak.</p>

<p>To see how this can be useful, take this example: consider the words “$\text{learner}$”, “$\text{learn}$”, “$\text{learned}$”, and “$\text{lean}$”. We might wish to capture how similar each of these words is to some other word, let’s say the word “$\text{learner}$” again. The similarity of “$\text{learner}$” to itself is perfect, since no edit (letter change) is required to transform one into the other. They are the same, after all. On to the more interesting cases: the word “$\text{learned}$” is very similar to “$\text{learner}$” – substituting the last letter will transform the former into the latter. “$\text{learn}$” is also very similar to “$\text{learner}$”, but a little less so – deleting the last two letters from “$\text{learner}$” results in “$\text{learner}$”, requiring two steps rather than one. The word “$\text{lean}$” is again a bit less similar to “$\text{learner}$”, requiring one additional deletion. So to transform each of the words given into “$\text{learner}$” requires:</p>

<ul>
  <li>”$\text{learner}$”: $0$ edits</li>
  <li>”$\text{learned}$”: $1$ edit</li>
  <li>”$\text{learn}$”: $2$ edits</li>
  <li>”$\text{lean}$”: $3$ edits</li>
</ul>

<p>For the sake of exposition, let us settle on $3$ as the—pretty arbitrarily chosen—treshold from which onwards two words to be considered completely dissimilar, or “not similar at all”. Then we can map our edit counts to a scale from $0$ to $1$, and represent our findings as a fuzzy set which scores the key “$\text{learner}$” with $1.0$, “$\text{learned}$” with $0.66$, “$\text{learn}$” with $0.33$ and “$\text{lean}$” with $0.0$, or, using key-value notation:</p>

<script type="math/tex; mode=display">\lbrace\text{learner}: 1.0, \text{learned}: 0.66, \text{learn}: 0.33, \text{lean}: 0.0\rbrace</script>

<p>In this fuzzy set, the degree of each element is to be interpreted as the degree of similarity to our target word “learner”.</p>

<h2 id="the-setmap-class-and-its-children">The <code class="highlighter-rouge">SetMap</code> class and its children</h2>

<p>Equipped with some basic understanding of our problem domain, let us begin to develop the main ingredients for a Ruby model of sets that encompasses the types of sets we have discussed (as well as potentially other ones). We start by discussing a <code class="highlighter-rouge">SetMap</code> class that captures the commonalities of classical sets, fuzzy sets, and multisets, while allowing us to easily define each of these specific types via inheritance.</p>

<p><strong>Hash tables.</strong> What do the three types of sets have in common? At first glance, it seems that their internal structure is pretty different: multisets and fuzzy sets have been presented above as consisting of key-value pairs, while classical sets simply consist of a bunch of keys. However, this is merely a matter of representation. In fact, it is rather common to represent a classical set by means of a <em>characteristic function</em>, which maps the members of the set to $1$, while all other objects from a given domain are mapped to $0$. Taking a cue from this, we extend our key-value notation to classical sets, writing the set $\lbrace 0, 1, 2\rbrace$, for example, as $\lbrace 0: 1, 1: 1, 2: 1\rbrace$.</p>

<p>From this perspective, it becomes obvious that the membership information for a set—be it a fuzzy set, a classical set, or a multiset—may be stored in a hash table, such as</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre><span class="p">{</span> <span class="s1">'a'</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">'b'</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">'c'</span> <span class="o">=&gt;</span> <span class="mi">1</span> <span class="p">}</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>or</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre><span class="p">{</span> <span class="s1">'a'</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">'b'</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">'c'</span> <span class="o">=&gt;</span> <span class="mi">2</span> <span class="p">}</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>or</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre><span class="p">{</span> <span class="s1">'a'</span> <span class="o">=&gt;</span> <span class="mi">0</span><span class="o">.</span><span class="mi">3</span><span class="p">,</span> <span class="s1">'b'</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">'c'</span> <span class="o">=&gt;</span> <span class="mi">0</span><span class="o">.</span><span class="mi">6</span> <span class="p">}</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>Hash tables will form the basis of our representation of sets. Of course, we would not want to directly expose such a table to the user of our set class. The user need not even be aware that we are using a hash table to store her set. Rather, the hash instance that stores the set keys and their associated scores will be a collaborator object to our set object. The <code class="highlighter-rouge">initialize</code> method of our <code class="highlighter-rouge">SetMap</code> class sets the stage for this:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">SetMap</span>
  <span class="kp">attr_reader</span> <span class="ss">:size</span>

  <span class="k">def</span> <span class="nf">initialize</span>
    <span class="vi">@hash</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="vi">@size</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>We decide to maintain an instance variable <code class="highlighter-rouge">@size</code> (with accompanying getter method <code class="highlighter-rouge">size</code>), in the interest of being able to look up the size of our set in constant time. The size of a set is commonly defined as the sum of the scores of its keys, and the idea is that <code class="highlighter-rouge">@size</code> will always store this value in an up-to-date fashion.</p>

<p><strong>Valid scores.</strong> What distinguishes the types of sets we have seen above from each other? It is primarily what counts as a valid score according to each type:</p>

<ul>
  <li>A classical set either contains or does not contain a particular key, so the only valid scores are $0$ and $1$.</li>
  <li>A multiset may contain a given key $n$ times, where $n$ is a non-negative integer.</li>
  <li>A fuzzy set scores a given key to a degree in the unit interval from $0$ to $1$.</li>
</ul>

<p>So in each case, we have to be able to express a range of possible values. We set up a bunch of class methods and class instance variables for this purpose:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">SetMap</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">score_type</span>
    <span class="vi">@score_type</span> <span class="o">||</span> <span class="k">raise</span><span class="p">(</span><span class="no">SetError</span><span class="p">,</span> <span class="s1">'@score_type not initialized'</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">min_score</span>
    <span class="vi">@min_score</span> <span class="o">||</span> <span class="k">raise</span><span class="p">(</span><span class="no">SetError</span><span class="p">,</span> <span class="s1">'@min_score not initialized'</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">max_score</span>
    <span class="vi">@max_score</span> <span class="o">||</span> <span class="k">raise</span><span class="p">(</span><span class="no">SetError</span><span class="p">,</span> <span class="s1">'@max_score not initialized'</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">valid_score?</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
    <span class="n">val</span><span class="p">.</span><span class="nf">is_a?</span><span class="p">(</span><span class="n">score_type</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">min_score</span><span class="p">.</span><span class="nf">.</span><span class="n">max_score</span><span class="p">).</span><span class="nf">cover?</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>The first three class methods defined above are getters (on the level of the class object) for the class instance variables <code class="highlighter-rouge">@score_type</code> (the kind of object we may use as a score for a key), <code class="highlighter-rouge">@min_score</code> (the smallest value that may be used as a score), and <code class="highlighter-rouge">@max_score</code> (the largest value that maye be used as a score). The fourth method uses these getters and describes what constitutes a valid score as a predicate.</p>

<p>As the second disjunct of each of the above getter methods tells us loud and clear, we are missing something so far: our class instance variables have not been set to any value! Initializing those class instance variables is precisely the job description of our target classes.</p>

<p><strong>Target classes.</strong> <code class="highlighter-rouge">SetMap</code> is meant to be subclassed, with each subclass defining a particular set type by specifying a range of legal scores via the class instance variables <code class="highlighter-rouge">@score_type</code>, <code class="highlighter-rouge">@min_score</code> and <code class="highlighter-rouge">@max_score</code>. Here is the code for classical sets:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">ClassicalSet</span> <span class="o">&lt;</span> <span class="no">SetMap</span>
  <span class="vi">@score_type</span> <span class="o">=</span> <span class="no">Integer</span>
  <span class="vi">@min_score</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="vi">@max_score</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>In other words, the only valid scores for the keys of classical sets are the integers <code class="highlighter-rouge">0</code> and <code class="highlighter-rouge">1</code>. For fuzzy sets, we write:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">FuzzySet</span> <span class="o">&lt;</span> <span class="no">SetMap</span>
  <span class="vi">@score_type</span> <span class="o">=</span> <span class="no">Numeric</span>
  <span class="vi">@min_score</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="vi">@max_score</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>So any <code class="highlighter-rouge">Numeric</code> instance in the closed interval $[0, 1]$ is a valid score for a fuzzy set key (we choose <code class="highlighter-rouge">Numeric</code> so as to allow both floats and integers). Finally, for multisets:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">MultiSet</span> <span class="o">&lt;</span> <span class="no">SetMap</span>
  <span class="vi">@score_type</span> <span class="o">=</span> <span class="no">Integer</span>
  <span class="vi">@min_score</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="vi">@max_score</span> <span class="o">=</span> <span class="no">Float</span><span class="o">::</span><span class="no">INFINITY</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>The <code class="highlighter-rouge">Float::INFINITY</code> constant has the property that <code class="highlighter-rouge">x &lt; Float::INFINITY</code> for any numeric <code class="highlighter-rouge">x</code>. Setting <code class="highlighter-rouge">@max_score</code> to <code class="highlighter-rouge">Float::INFINITY</code> is thus a way of saying that, for multisets, there is no maximal score: any non-negative integer is allowed.</p>

<p>And this is really all there is to it! Specializing the capabilities of <code class="highlighter-rouge">SetMap</code> to a particular target class boils down to providing appropriate values for a bunch of class instance variables.</p>

<p>Of course, we have not yet demonstrated what the interface for <code class="highlighter-rouge">SetMap</code> actually looks like. But from now on, we will write methods that work equally well for all three set types under consideration: classical sets, fuzzy sets, and multisets.</p>

<p><strong>Key insertion.</strong> The most basic part of the interface of any set class is arguably the capability of inserting scores for particular keys. Here is the <code class="highlighter-rouge">SetMap#insert</code> method:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
  <span class="k">raise</span><span class="p">(</span><span class="no">SetError</span><span class="p">,</span> <span class="s1">'Illegal value'</span><span class="p">)</span> <span class="k">unless</span> <span class="nb">self</span><span class="p">.</span><span class="nf">class</span><span class="p">.</span><span class="nf">valid_score?</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
  <span class="n">old_score</span> <span class="o">=</span> <span class="nb">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
  <span class="vi">@hash</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">+</span> <span class="n">val</span><span class="p">,</span> <span class="nb">self</span><span class="p">.</span><span class="nf">class</span><span class="p">.</span><span class="nf">max_score</span><span class="p">].</span><span class="nf">min</span>
  <span class="vi">@size</span> <span class="o">=</span> <span class="p">(</span><span class="vi">@size</span> <span class="o">+</span> <span class="p">(</span><span class="nb">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">-</span> <span class="n">old_score</span><span class="p">)).</span><span class="nf">round</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
  <span class="nb">self</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>The general idea of this method is to increment the score of <code class="highlighter-rouge">key</code> by <code class="highlighter-rouge">val</code>. As per line 2 of the snippet, this will work only if <code class="highlighter-rouge">val</code> is a valid score according to the implementation of <code class="highlighter-rouge">valid_score?</code> (which in turn depends on the values of the class instance variables <code class="highlighter-rouge">@score_type</code>, <code class="highlighter-rouge">@min_score</code> and <code class="highlighter-rouge">@max_score</code>). If that is the case, we use what is called a <em>bounded sum</em> to add <code class="highlighter-rouge">val</code> to <code class="highlighter-rouge">self[key]</code>, capping off the sum at <code class="highlighter-rouge">@max_score</code> (line 4).</p>

<p>Let’s try this out using our target classes:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14</pre></td><td class="code"><pre><span class="n">fuzzy_set</span> <span class="o">=</span> <span class="no">FuzzySet</span><span class="p">.</span><span class="nf">new</span>
<span class="n">fuzzy_set</span><span class="p">.</span><span class="nf">insert</span><span class="p">(</span><span class="s1">'a'</span><span class="p">,</span> <span class="mi">0</span><span class="o">.</span><span class="mi">5</span><span class="p">)</span>
<span class="n">fuzzy_set</span><span class="p">.</span><span class="nf">insert</span><span class="p">(</span><span class="s1">'a'</span><span class="p">,</span> <span class="mi">0</span><span class="o">.</span><span class="mi">3</span><span class="p">)</span>
<span class="n">fuzzy_set</span> <span class="c1">#=&gt; #&lt;FuzzySet: {"a": 0.8}&gt;</span>

<span class="n">multi_set</span> <span class="o">=</span> <span class="no">MultiSet</span><span class="p">.</span><span class="nf">new</span>
<span class="n">multi_set</span><span class="p">.</span><span class="nf">insert</span><span class="p">(</span><span class="s1">'a'</span><span class="p">)</span>
<span class="n">multi_set</span><span class="p">.</span><span class="nf">insert</span><span class="p">(</span><span class="s1">'a'</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">multi_set</span> <span class="c1">#=&gt; #&lt;MultiSet: {"a": 3}&gt;</span>

<span class="n">classical_set</span> <span class="o">=</span> <span class="no">ClassicalSet</span><span class="p">.</span><span class="nf">new</span>
<span class="n">classical_set</span><span class="p">.</span><span class="nf">insert</span><span class="p">(</span><span class="s1">'a'</span><span class="p">)</span>
<span class="n">classical_set</span><span class="p">.</span><span class="nf">insert</span><span class="p">(</span><span class="s1">'a'</span><span class="p">)</span>
<span class="n">classical_set</span> <span class="c1">#=&gt; #&lt;ClassicalSet: {"a": 1}&gt;</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>These are the desired results (assuming a—standard—<code class="highlighter-rouge">inspect</code> method which we have not shown). Notice that the score range we have specified for classical sets in tandem with the bounded sum ensures that inserting the same key twice has the same effect as inserting it once: the sum of <code class="highlighter-rouge">1</code> and <code class="highlighter-rouge">1</code> bounded by <code class="highlighter-rouge">1</code> is again <code class="highlighter-rouge">1</code>.</p>

<p>Returning to the earlier snippet, we also need to keep track of the size of our set (line 5). Here, we also neutralize rounding errors that might occur for types of sets that allow <a href="http://floating-point-gui.de">floating point numbers</a> as scores.</p>

<p><strong>Key retrieval.</strong>  Next, consider <code class="highlighter-rouge">SetMap#retrieve</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">retrieve</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
  <span class="vi">@hash</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="p">?</span> <span class="vi">@hash</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="p">:</span> <span class="mi">0</span>
<span class="k">end</span>
<span class="k">alias</span> <span class="p">[]</span> <span class="n">retrieve</span>
</pre></td></tr></tbody></table>
</div>
</div>
<p>The <code class="highlighter-rouge">retrieve</code> method (which we alias as <code class="highlighter-rouge">[]</code>) wraps the element reference method of our internal hash. If the hash does not contain a certain key, <code class="highlighter-rouge">@hash[key]</code> will return <code class="highlighter-rouge">nil</code>. In that case, <code class="highlighter-rouge">retrieve(key)</code> (or, equivalently as per our alias, <code class="highlighter-rouge">self[key]</code>) will return <code class="highlighter-rouge">0</code>. Alternatively, we could haver set a default value for <code class="highlighter-rouge">@hash</code>, but the current way seems slightly more explicit.</p>

<p>Observe that key retrieval is fast: accessing a hash key takes constant time on average (<a href="https://lemire.me/blog/2009/08/18/do-hash-tables-work-in-constant-time/">disregarding some fine-print</a>), i.e., as the number of keys in a hash increases, the average time necessary to recover the value for a key does not increase. This is one of the main reasons why using hash tables to model sets is an attractive choice.</p>

<p><strong>Key removal.</strong> While it would be possible to tweak our approach and express removal of a key as insertion with a negative score, we prefer to keep things simple here:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
  <span class="k">raise</span><span class="p">(</span><span class="no">SetError</span><span class="p">,</span> <span class="s1">'Illegal value'</span><span class="p">)</span> <span class="k">unless</span> <span class="nb">self</span><span class="p">.</span><span class="nf">class</span><span class="p">.</span><span class="nf">valid_score?</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
  <span class="n">old_score</span> <span class="o">=</span> <span class="nb">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
  <span class="vi">@hash</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">-</span> <span class="n">val</span><span class="p">,</span> <span class="nb">self</span><span class="p">.</span><span class="nf">class</span><span class="p">.</span><span class="nf">min_score</span><span class="p">].</span><span class="nf">max</span>
  <span class="vi">@size</span> <span class="o">=</span> <span class="p">(</span><span class="vi">@size</span> <span class="o">-</span> <span class="p">(</span><span class="n">old_score</span> <span class="o">-</span> <span class="nb">self</span><span class="p">[</span><span class="n">key</span><span class="p">])).</span><span class="nf">round</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
  <span class="nb">self</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p><code class="highlighter-rouge">SetMap#remove</code> is perfectly symmetric to the earlier <code class="highlighter-rouge">insert</code> method, using a bounded difference instead of a bounded sum. For our three target classes, this ensures that negative scores cannot occur.</p>

<p><strong>Enumeration.</strong> The below <code class="highlighter-rouge">SetMap#each_pair</code> method enumerates set keys and their associated scores in a straightforward manner, piggybacking on <code class="highlighter-rouge">Hash#each_pair</code>. Notice that we only yield key-value pairs for which the value is non-zero, since a key scored with value <code class="highlighter-rouge">0</code> is not considered part of our set.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">each_pair</span>
  <span class="k">return</span> <span class="n">to_enum</span><span class="p">(</span><span class="ss">:each_pair</span><span class="p">)</span> <span class="k">unless</span> <span class="nb">block_given?</span>

  <span class="vi">@hash</span><span class="p">.</span><span class="nf">each_pair</span> <span class="k">do</span> <span class="o">|</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="o">|</span>
    <span class="k">yield</span><span class="p">([</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">])</span> <span class="k">if</span> <span class="n">val</span> <span class="o">!=</span> <span class="mi">0</span>
  <span class="k">end</span>

  <span class="nb">self</span>
<span class="k">end</span>
<span class="k">alias</span> <span class="n">each</span> <span class="n">each_pair</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>As we will see below, <code class="highlighter-rouge">each_pair</code> forms the basis for all our methods that iterate over sets. This includes pretty much all the interesting operations on sets—<code class="highlighter-rouge">union</code>, <code class="highlighter-rouge">intersection</code>, and the like. Since <code class="highlighter-rouge">each_pair</code> is aliassed as <code class="highlighter-rouge">each</code>, it also allows us to include the <code class="highlighter-rouge">Enumerable</code> module, which any respectable Ruby collection class should have access to.</p>

<h2 id="the-setlike-module">The <code class="highlighter-rouge">SetLike</code> module</h2>

<p>The preceding methods, and the <code class="highlighter-rouge">SetMap</code> class that defines these methods, serve as a wrapper around our hash table. We have also implemented a mechanism for specifying what constitutes a valid score for a given type of set. And we have provided our three target classes that inherit from <code class="highlighter-rouge">SetMap</code>. The basics of our model are thus in place.</p>

<p>What remains to be implemented is all the interesting operations on sets! The remaining part of the interface will, however, not interact with the internally used hash table directly, but only through the interface developed so far.</p>

<p>For the purpose of implementing those additional operations, we open a new module <code class="highlighter-rouge">SetLike</code>, which we include in <code class="highlighter-rouge">SetMap</code>.</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{matrix}
 && \text{SetLike} & \\
&& \large\uparrow  \\
&& \text{SetMap} \\
&\large\nearrow & \large\uparrow & \large\nwarrow \\
\text{ClassicalSet} & & \text{MultiSet}&  & \text{FuzzySet}\\
\end{matrix} %]]></script>

<p>Since our target classes <code class="highlighter-rouge">ClassicalSet</code>, <code class="highlighter-rouge">FuzzySet</code> and <code class="highlighter-rouge">MultiSet</code> inherit from <code class="highlighter-rouge">SetMap</code>, as shown in the above diagram, they will also be able to access the functionality provided by <code class="highlighter-rouge">SetLike</code>.</p>

<p><strong>Division of Labor.</strong> The division of labor we adopt here takes a cue from the place the <code class="highlighter-rouge">Enumerable</code> module occupies in Ruby’s design. <code class="highlighter-rouge">Enumerable</code> provides a number of useful methods for working with collections to any class that chooses to include it. In doing so, <code class="highlighter-rouge">Enumerable</code> assumes that the class implements an <code class="highlighter-rouge">each</code> method, which forms the basis for all the methods <code class="highlighter-rouge">Enumerable</code> defines. Beyond this, however, <code class="highlighter-rouge">Enumerable</code> does not (need to) know anything about the class using it. Here, we do something very similar:</p>

<ul>
  <li><code class="highlighter-rouge">SetLike</code> provides most of the functionality commonly associated with sets.</li>
  <li><code class="highlighter-rouge">SetLike</code> assumes that any class that uses it implements the instance methods <code class="highlighter-rouge">retrieve</code>, <code class="highlighter-rouge">insert</code>, <code class="highlighter-rouge">delete</code>, <code class="highlighter-rouge">each</code> and <code class="highlighter-rouge">size</code>.</li>
  <li><code class="highlighter-rouge">SetLike</code> does not make any further assumptions about the internals of the class using it.</li>
</ul>

<p>In particular, none of the methods in <code class="highlighter-rouge">SetLike</code> need to know that we are using a hash for internal storage. This draws a distinction between methods that do need to know that we have chosen to represent sets with hash tables (they go in the <code class="highlighter-rouge">SetMap</code> class), and methods that don’t need to know this (they go in the <code class="highlighter-rouge">SetLike</code> module), and thus encapsulates the internal state of a set in <code class="highlighter-rouge">SetMap</code>. As long as we keep the public interface of <code class="highlighter-rouge">SetMap</code> stable, we could just as well reimplement all its methods using a binary search tree instead of a hash for storing a set, say: <code class="highlighter-rouge">SetLike</code> will not care.</p>

<p><strong>Operations on sets.</strong> We would like to implement the usual operations on sets, like <code class="highlighter-rouge">union</code>, <code class="highlighter-rouge">intersection</code>, and <code class="highlighter-rouge">difference</code>. Since they all follow essentially the same pattern, we focus on just one of them, <code class="highlighter-rouge">union!</code> (the  destructive version of <code class="highlighter-rouge">union</code>).</p>

<p>Following the example established by Ruby’s <a href="https://github.com/ruby/ruby/blob/trunk/lib/set.rb"><code class="highlighter-rouge">Set</code> class</a>, we first implement a helper method <code class="highlighter-rouge">SetLike#do_with</code> that yields to a block:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">do_with</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
  <span class="k">unless</span> <span class="n">other</span><span class="p">.</span><span class="nf">instance_of?</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="nf">class</span><span class="p">)</span>
    <span class="k">raise</span> <span class="no">SetError</span><span class="p">,</span> <span class="s2">"</span><span class="si">#{</span><span class="nb">self</span><span class="p">.</span><span class="nf">class</span><span class="si">}</span><span class="s2"> instance needed"</span>
  <span class="k">end</span>

  <span class="k">return</span> <span class="n">other</span><span class="p">.</span><span class="nf">each</span> <span class="k">unless</span> <span class="nb">block_given?</span>
  <span class="n">other</span><span class="p">.</span><span class="nf">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="o">|</span> <span class="k">yield</span><span class="p">([</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">])</span> <span class="p">}</span>
<span class="k">end</span>
<span class="kp">private</span> <span class="ss">:do_with</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>This methods takes care of the type-checking for us. We would not, e.g., want to subtract a fuzzy set from a classical set, as the result will not in general be a classical set. The above guard clause ensures that the operations we will define are only carried out for two objects that belong to the same target class. Beyond this, <code class="highlighter-rouge">do_with</code> simply yields the key-value pairs of the set passed to it as an argument. Using <code class="highlighter-rouge">do_with</code>, we implement <code class="highlighter-rouge">union!</code> as follows:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">union!</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
  <span class="n">do_with</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">key</span><span class="p">,</span> <span class="n">_</span><span class="o">|</span>
    <span class="nb">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">self</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">other</span><span class="p">[</span><span class="n">key</span><span class="p">]].</span><span class="nf">max</span>
  <span class="k">end</span>
  <span class="nb">self</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>The union of a given set with another one is defined by maximizing scores for given keys across the two sets. This is how the union is usually defined, and it yields the expected results.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8</pre></td><td class="code"><pre><span class="c1"># SetMap::from_hash(hsh) creates a new set instance and populates it</span>
<span class="c1"># with the key-value pairs from the given hash `hsh`</span>

<span class="n">multi_set1</span> <span class="o">=</span> <span class="no">MultiSet</span><span class="p">.</span><span class="nf">from_hash</span><span class="p">(</span><span class="mi">2</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span> <span class="o">=&gt;</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">multi_set2</span> <span class="o">=</span> <span class="no">MultiSet</span><span class="p">.</span><span class="nf">from_hash</span><span class="p">(</span><span class="mi">2</span> <span class="o">=&gt;</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">multi_set1</span><span class="p">.</span><span class="nf">union!</span><span class="p">(</span><span class="n">multi_set2</span><span class="p">)</span>

<span class="n">multi_set1</span> <span class="o">==</span> <span class="no">MultiSet</span><span class="p">.</span><span class="nf">from_hash</span><span class="p">(</span><span class="mi">2</span> <span class="o">=&gt;</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="o">=&gt;</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># true</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p><code class="highlighter-rouge">union!</code> implements a notion of “combining what is contained in two given sets”. There is a similar, yet slightly different notion which is interesting from the perspective of our polymorphic approach: the <em>sum</em> of two sets. So let’s briefly digress:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">sum!</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
  <span class="n">do_with</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="p">{</span> <span class="o">|</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="o">|</span> <span class="n">insert</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="p">}</span>
  <span class="nb">self</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>Rather than maximizing scores, as <code class="highlighter-rouge">union!</code> did, <code class="highlighter-rouge">sum!</code> adds the scores given by the other set to the scores of the receiver. For classical sets, <code class="highlighter-rouge">sum!</code> and <code class="highlighter-rouge">union!</code> amount to the very same thing:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10</pre></td><td class="code"><pre><span class="c1"># SetMap::[](*list) creates a new set instance and turns the</span>
<span class="c1"># members of `list` into keys of the new instance.</span>

<span class="n">set1</span> <span class="o">=</span> <span class="no">ClassicalSet</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="n">set2</span> <span class="o">=</span> <span class="no">ClassicalSet</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>

<span class="n">set3</span> <span class="o">=</span> <span class="no">ClassicalSet</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="n">set4</span> <span class="o">=</span> <span class="no">ClassicalSet</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>

<span class="n">set1</span><span class="p">.</span><span class="nf">union!</span><span class="p">(</span><span class="n">set2</span><span class="p">)</span> <span class="o">==</span> <span class="n">set3</span><span class="p">.</span><span class="nf">sum!</span><span class="p">(</span><span class="n">set4</span><span class="p">)</span> <span class="c1"># true</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>This is why Ruby’s own <code class="highlighter-rouge">Set</code> class simply defines <code class="highlighter-rouge">+</code> (the sum operator) to be an alias of <code class="highlighter-rouge">|</code> (the union operator). However, for other types of sets, sum and union are not always the same. This is because taking the maximum of two scores is not generally the same as summing up those two scores! For example:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11</pre></td><td class="code"><pre><span class="n">set1</span> <span class="o">=</span> <span class="no">FuzzySet</span><span class="p">.</span><span class="nf">from_hash</span><span class="p">(</span><span class="mi">2</span> <span class="o">=&gt;</span> <span class="mi">0</span><span class="o">.</span><span class="mi">4</span><span class="p">)</span>
<span class="n">set2</span> <span class="o">=</span> <span class="no">FuzzySet</span><span class="p">.</span><span class="nf">from_hash</span><span class="p">(</span><span class="mi">2</span> <span class="o">=&gt;</span> <span class="mi">0</span><span class="o">.</span><span class="mi">3</span><span class="p">)</span>

<span class="n">set3</span> <span class="o">=</span> <span class="no">FuzzySet</span><span class="p">.</span><span class="nf">from_hash</span><span class="p">(</span><span class="mi">2</span> <span class="o">=&gt;</span> <span class="mi">0</span><span class="o">.</span><span class="mi">4</span><span class="p">)</span>
<span class="n">set4</span> <span class="o">=</span> <span class="no">FuzzySet</span><span class="p">.</span><span class="nf">from_hash</span><span class="p">(</span><span class="mi">2</span> <span class="o">=&gt;</span> <span class="mi">0</span><span class="o">.</span><span class="mi">3</span><span class="p">)</span>

<span class="n">set1</span><span class="p">.</span><span class="nf">sum!</span><span class="p">(</span><span class="n">set2</span><span class="p">)</span>
<span class="n">set3</span><span class="p">.</span><span class="nf">union!</span><span class="p">(</span><span class="n">set4</span><span class="p">)</span>

<span class="n">set1</span> <span class="o">==</span> <span class="no">FuzzySet</span><span class="p">.</span><span class="nf">from_hash</span><span class="p">(</span><span class="mi">2</span> <span class="o">=&gt;</span> <span class="mi">0</span><span class="o">.</span><span class="mi">7</span><span class="p">)</span> <span class="c1"># true</span>
<span class="n">set3</span> <span class="o">==</span> <span class="no">FuzzySet</span><span class="p">.</span><span class="nf">from_hash</span><span class="p">(</span><span class="mi">2</span> <span class="o">=&gt;</span> <span class="mi">0</span><span class="o">.</span><span class="mi">4</span><span class="p">)</span> <span class="c1"># true</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>Our model captures all of this correctly.</p>

<p><strong>Set predicates.</strong> A classical set $A$ is a subset of a classical set of $B$ if any element of $A$ is also an element of $B$. This can be expressed in terms of keys and their associated scores by saying that the score for any key in $A$ is less than or equal to the score for that same key in $B$. This definition also applies to multisets, and fuzzy sets, so that, again, a common implementation is possible. Here is a first stab at the <code class="highlighter-rouge">SetLike#subset?</code> method:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">subset?</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
  <span class="k">return</span> <span class="kp">false</span> <span class="k">unless</span> <span class="n">other</span><span class="p">.</span><span class="nf">instance_of?</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="nf">class</span><span class="p">)</span>

  <span class="n">all?</span> <span class="k">do</span> <span class="o">|</span><span class="n">key</span><span class="p">,</span> <span class="n">_</span><span class="o">|</span>
    <span class="nb">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">other</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
  <span class="k">end</span>
<span class="k">end</span>
<span class="k">alias</span> <span class="o">&lt;=</span> <span class="n">subset?</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>Following the pattern established by the <code class="highlighter-rouge">do_with</code> method discussed above, however, it makes sense to extract the “key comparison” functionality to a separate <code class="highlighter-rouge">compare_with?</code> method that takes a block (you may want to check out the <a href="https://github.com/maraigue/multiset/blob/master/lib/multiset.rb">code of the multiset gem</a>—the gem author does exactly this).</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">keys</span>
  <span class="n">each</span><span class="p">.</span><span class="nf">map</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:first</span><span class="p">)</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">compare_with?</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
  <span class="k">return</span> <span class="kp">false</span> <span class="k">unless</span> <span class="n">other</span><span class="p">.</span><span class="nf">instance_of?</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="nf">class</span><span class="p">)</span>

  <span class="p">(</span><span class="n">keys</span> <span class="o">|</span> <span class="n">other</span><span class="p">.</span><span class="nf">keys</span><span class="p">).</span><span class="nf">all?</span> <span class="k">do</span> <span class="o">|</span><span class="n">key</span><span class="o">|</span>
    <span class="k">yield</span><span class="p">(</span><span class="nb">self</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">other</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>According to line 2 above, the keys of a set object are given by the first component of each key-value pair. <code class="highlighter-rouge">SetLike#compare_with?</code> then iterates over the keys of both <code class="highlighter-rouge">self</code> and <code class="highlighter-rouge">other</code>, and yields the corresponding values to the block. This allows us to implement <code class="highlighter-rouge">subset?</code> as follows:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">subset?</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
  <span class="n">compare_with?</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">s</span><span class="p">,</span> <span class="n">o</span><span class="o">|</span>
    <span class="n">s</span> <span class="o">&lt;=</span> <span class="n">o</span>
  <span class="k">end</span>
<span class="k">end</span>
<span class="k">alias</span> <span class="o">&lt;=</span> <span class="n">subset?</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>Definitions for the other common set predicates (<code class="highlighter-rouge">proper_subset?</code>, <code class="highlighter-rouge">superset?</code> and <code class="highlighter-rouge">proper_superset?</code>) are similar, so we omit them here.</p>

<p><strong>Equivalence.</strong> When are two sets $A$ and $B$ the same? Again, there is an answer that works for all three target classes: the two sets should be in a mutual inclusion relation, i.e., $A$ should be a subset of $B$, and $B$ a subset of $A$. However, invoking <code class="highlighter-rouge">subset?</code> twice seems slightly redundant, since in the worst case, this amounts to performing every comparison twice. Using the <code class="highlighter-rouge">compare_with?</code> method defined above, we can more simply write the following code:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">equivalent?</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
  <span class="n">compare_with?</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">s</span><span class="p">,</span> <span class="n">o</span><span class="o">|</span>
    <span class="n">s</span> <span class="o">==</span> <span class="n">o</span>
  <span class="k">end</span>
<span class="k">end</span>
<span class="k">alias</span> <span class="o">==</span> <span class="n">equivalent?</span>
<span class="k">alias</span> <span class="nb">eql?</span> <span class="n">equivalent?</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>Notice that we have aliassed the <code class="highlighter-rouge">equivalent?</code> method both as <code class="highlighter-rouge">==</code> and <code class="highlighter-rouge">eql?</code>. We have already taken the <code class="highlighter-rouge">==</code> method for granted in some earlier snippets. Now what about <code class="highlighter-rouge">eql?</code>? This brings us to our final topic for today:</p>

<p><strong>Nested sets.</strong> Unless overridden, the <code class="highlighter-rouge">Object#eql?</code> method considers two objects to be the same if they are identical (i.e., are stored at the same location in memory). In the current context, overriding <code class="highlighter-rouge">Object#eql?</code> is critical, because <code class="highlighter-rouge">eql?</code> is the method that Ruby uses when accessing hash keys. Let’s leave the context of our <code class="highlighter-rouge">SetLike</code> module for a moment, and consider this line of Ruby code:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre><span class="n">some_hash</span><span class="p">[</span><span class="n">some_obj</span><span class="p">]</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>When executing this line, Ruby will check if there is a key <code class="highlighter-rouge">key</code> to be found in <code class="highlighter-rouge">some_hash</code> with the property that <code class="highlighter-rouge">some_obj.eql?(key)</code>. If so, the value for <code class="highlighter-rouge">key</code> will be returned.</p>

<p>For our purposes, this process of looking up keys in a hash is crucial because (1) we are using hashes for storing set membership information, and (2) we would like to be able to model <em>nested</em> sets, which are sets that have sets among their keys. Consider:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9</pre></td><td class="code"><pre><span class="c1"># SetMap::[](*list) creates a new set instance and turns the</span>
<span class="c1"># members of `list` into keys of the new instance.</span>

<span class="n">set1</span> <span class="o">=</span> <span class="no">ClassicalSet</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="n">set2</span> <span class="o">=</span> <span class="no">ClassicalSet</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="n">set3</span> <span class="o">=</span> <span class="no">ClassicalSet</span><span class="p">[</span><span class="n">set1</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="n">set4</span> <span class="o">=</span> <span class="no">ClassicalSet</span><span class="p">[</span><span class="n">set2</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>

<span class="n">set3</span> <span class="o">==</span> <span class="n">set4</span> <span class="c1">#=&gt; ?</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>Now the question is whether <code class="highlighter-rouge">set3</code> and <code class="highlighter-rouge">set4</code> are the same set. It seems that the answer should be yes, because, after all, they <em>contain the same elements</em>. Assume, however, for a moment that we had not overridden <code class="highlighter-rouge">eql?</code>. Then <code class="highlighter-rouge">set3</code> and <code class="highlighter-rouge">set4</code> do <em>not</em> come out the same in the sense of <code class="highlighter-rouge">==</code> because <code class="highlighter-rouge">set1</code> and <code class="highlighter-rouge">set2</code> do not reference the same object, which implies that <code class="highlighter-rouge">set3[set1] == set4[set1]</code> will return false, for the simple reason that <code class="highlighter-rouge">set1</code> is not considered a key in the set <code class="highlighter-rouge">other</code>, since it is not the case that <code class="highlighter-rouge">set2.eql?(set1)</code>. So overriding <code class="highlighter-rouge">eql?</code>, like we did above, is indeed critical.</p>

<p><strong>The <code class="highlighter-rouge">hash</code> method</strong> As a final aside: For our set comparisons to work, we also need to override the <code class="highlighter-rouge">Object#hash</code> method so as to ensure that two set objects that are <code class="highlighter-rouge">eql?</code> have the same return value when <code class="highlighter-rouge">hash</code> is called on them. This can be achieved, e.g., like this:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">hash</span>
  <span class="n">each</span><span class="p">.</span><span class="nf">map</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:hash</span><span class="p">).</span><span class="nf">sum</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>Here, we simply map each key-value pair (a two-element array) yielded by <code class="highlighter-rouge">each</code> to its <code class="highlighter-rouge">hash</code> value and sum up the result, trusting that <code class="highlighter-rouge">Array#hash</code> is implemented in a meaningful way. And this indeed ensures that <code class="highlighter-rouge">eql?</code> sets have the same <code class="highlighter-rouge">hash</code> return value.</p>

<p><strong>Coda.</strong> What has been achieved? As mentioned at the beginning of the post, the set functionality that we have discussed is either readily available as part of Ruby’s Standard Library (for classical sets), or via an easily accesible Ruby gem (for multisets). However, the code presented here presents a <em>uniform</em> perspective on classical sets and multisets. While I have written <code class="highlighter-rouge">SetMap</code> and its child classes as an exercise for myself, I consider this uniformity an advantage over the pre-existing implementation. We have also seen how easily the approach generalizes to further use cases by considering fuzzy sets.</p>

<p>This has been a long post. I hope I have not overstretched the limits of your patience. While coming up with a first working implementation of the types of sets discussed here was pretty straightforward, arriving at a way to structure and modularize my code that I found convincing myself required me to go back to the drawing board several times. If you have a chance to <a href="https://github.com/benrodenhaeuser/sets">check out my code</a>, your feedback would be greatly appreciated.</p>

      <div class="pad"></div><hr class="line" /><div class="triplepad"></div>
      </section>
      <header>
  <small>&nbsp;</small>
  <a href="http://notes.benrodenhaeuser.io">
    <h1>Ben Rodenhäuser</h1>
  </a>
  <p>Learning to program</p>
  <hr class="line" />
  <p>
      

          <h3>
            <a class="post-link" href="/2017/12/18/a-bunch-of-sets/">A Bunch Of Sets</a><span class="pad"></span><small>18 Dec 2017</small>
          </h3>
      

          <h3>
            <a class="post-link" href="/2017/07/06/object-passing/">Object Passing</a><span class="pad"></span><small>06 Jul 2017</small>
          </h3>
      

          <h3>
            <a class="post-link" href="/2017/05/15/sorting-in-ruby/">Sorting In Ruby</a><span class="pad"></span><small>15 May 2017</small>
          </h3>
      
  </p>
  <hr class="line" />
  <p><small><a href="http://github.com/benrodenhaeuser">GitHub Profile</a></small></p>
</header>

      <!-- <footer>
  <p><small>Ben Rodenhäuser 2017 | <a href="http://github.com/benrodenhaeuser">GitHub Profile</a></small></p>
</footer> -->

    </div>
    <script src="/assets/js/scale.fix.js"></script>
  </body>
</html>
