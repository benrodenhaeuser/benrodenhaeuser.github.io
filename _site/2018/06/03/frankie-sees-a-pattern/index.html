<!doctype html>
<html lang="en-US">
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <title>Ben Rodenhäuser | Notes on programming</title>

  <link href="https://fonts.googleapis.com/css?family=Lato|Anton|Roboto Mono" rel="stylesheet">
  <link rel="stylesheet" href="/assets/css/main.css?v=">
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    CommonHTML: { linebreaks: { automatic: true } },
    "HTML-CSS": { linebreaks: { automatic: true } },
           SVG: { linebreaks: { automatic: true } }
  });
  </script>
  <script type="text/javascript"
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML&delayStartupUntilConfig">
  </script>
  <script src="/assets/jax/config.js"></script>

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!--[if lt IE 9]>
  <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  
    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-99334571-1', 'auto');
        ga('send', 'pageview');
    </script>
  
</head>

  <body>
    <div class="wrapper">
      <section>
  <p>
    <small>
      03 June 2018
    </small>
  </p>

  <h1 class="title">
    Frankie Sees a Pattern
  </h1>

  <div class="description">
    Defining parametrized routes: part 03 of the "Sinatra From Scratch" series.
  </div>

  <div class="content">
    <hr class="line" />
    <div class="content-inner">
      <blockquote class="aside">
  <p>This is part 03 in a four part series of blog posts that starts <a href="/2018/06/01/sinatra-from-scratch/">here</a>.</p>
</blockquote>

<p>In the <a href="/2018/06/02/frankie-reaches-for-the-top/">previous installation</a> of this blog post series, Frankie picked up a bit of Sinatra’s signature DSL magic. Next, let’s make Frankie a bit more capable. What is sorely missing from our toy version of Sinatra so far is the ability to <em>parametrize routes</em>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3</pre></td><td class="code"><pre><span class="n">get</span> <span class="s1">'/albums/:album/songs/:song'</span> <span class="k">do</span>
  <span class="s2">"Next up: '</span><span class="si">#{</span><span class="n">params</span><span class="p">[</span><span class="s1">'song'</span><span class="p">]</span><span class="si">}</span><span class="s2">' from '</span><span class="si">#{</span><span class="n">params</span><span class="p">[</span><span class="s1">'album'</span><span class="p">]</span><span class="si">}</span><span class="s2">'."</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>Given this route, suppose a user sends a request with the path</p>

<blockquote>
  <p><code class="highlighter-rouge">/albums/greatest-hits/songs/my-way</code></p>
</blockquote>

<p>In this example, <code class="highlighter-rouge">'greatest-hits'</code> and <code class="highlighter-rouge">'my-way</code> are essentially arguments that fill in the slots provided by the parameters <code class="highlighter-rouge">:album</code> and <code class="highlighter-rouge">:song</code>. As the route block shows, the mappings from parameters to arguments supplied by the user making the request should be available as key-value pairs within a <code class="highlighter-rouge">params</code> hash, for „Frankie developers“ to freely make use of.</p>

<p>Here is an idea how to make this work: Let’s match the request path against a regular expression stored along with the route in <code class="highlighter-rouge">Frankie::Application</code>. In our example, we expect the matching to produce regex captures <code class="highlighter-rouge">greatest-hits</code> and <code class="highlighter-rouge">my-way</code>. These should be linked with the route parameters to form a hash</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre><span class="p">{</span> <span class="s1">'album'</span> <span class="o">=&gt;</span> <span class="s1">'greatest-hits'</span><span class="p">,</span> <span class="s1">'song'</span> <span class="o">=&gt;</span> <span class="s1">'my-way'</span> <span class="p">}</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>which should then be merged into a <code class="highlighter-rouge">params</code> hash. The <code class="highlighter-rouge">params</code> hash, in turn, needs to be available to the instance handling the request, so it should be the return value of an instance method <code class="highlighter-rouge">params</code>.  As we saw above, route blocks are evaluated in the context of the current instance, so if the current instance has access to an instance method, then we can call it from a route block.</p>

<p>Starting at the end, we implement the <code class="highlighter-rouge">params</code> method first:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7</pre></td><td class="code"><pre><span class="k">module</span> <span class="nn">Frankie</span>
  <span class="k">class</span> <span class="nc">Application</span>
    <span class="k">def</span> <span class="nf">params</span>
      <span class="vi">@request</span><span class="p">.</span><span class="nf">params</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>Remember that <code class="highlighter-rouge">@request</code> is an instance of <code class="highlighter-rouge">Rack::Request</code>. Conveniently, <code class="highlighter-rouge">@request.params</code> is a hash we can use for our purposes.</p>

<p>Next, let’s adapt our mechanism for <em>storing</em> routes with parameters. Keeping in mind what was said in <a href="/2018/06/01/sinatra-from-scratch/">part 01 of this series</a>, this needs to happen at the <em>class level</em>. The method we need to change is the class method <code class="highlighter-rouge">route</code>.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33</pre></td><td class="code"><pre><span class="k">module</span> <span class="nn">Frankie</span>  
  <span class="k">class</span> <span class="nc">Application</span>
    <span class="k">class</span> <span class="o">&lt;&lt;</span> <span class="nb">self</span>
      <span class="k">def</span> <span class="nf">route</span><span class="p">(</span><span class="n">verb</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">block</span><span class="p">)</span>
        <span class="n">pattern</span><span class="p">,</span> <span class="n">keys</span> <span class="o">=</span> <span class="n">compile</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>

        <span class="n">routes</span> <span class="o">&lt;&lt;</span> <span class="p">{</span>
          <span class="ss">verb:     </span><span class="n">verb</span><span class="p">,</span>
          <span class="ss">pattern:  </span><span class="n">pattern</span><span class="p">,</span>
          <span class="ss">keys:     </span><span class="n">keys</span><span class="p">,</span>
          <span class="ss">block:    </span><span class="n">block</span>
        <span class="p">}</span>
      <span class="k">end</span>

      <span class="k">def</span> <span class="nf">compile</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="n">segments</span> <span class="o">=</span> <span class="n">path</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="s1">'/'</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">segments</span><span class="p">.</span><span class="nf">map!</span> <span class="k">do</span> <span class="o">|</span><span class="n">segment</span><span class="o">|</span>
          <span class="k">if</span> <span class="n">segment</span><span class="p">.</span><span class="nf">start_with?</span><span class="p">(</span><span class="s1">':'</span><span class="p">)</span>
            <span class="n">keys</span> <span class="o">&lt;&lt;</span> <span class="n">segment</span><span class="p">[</span><span class="mi">1</span><span class="p">.</span><span class="nf">.</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="s2">"([^</span><span class="se">\/</span><span class="s2">]+)"</span>
          <span class="k">else</span>
            <span class="n">segment</span>
          <span class="k">end</span>
        <span class="k">end</span>

        <span class="n">pattern</span> <span class="o">=</span> <span class="no">Regexp</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="s2">"</span><span class="se">\\</span><span class="s2">A</span><span class="si">#{</span><span class="n">segments</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="s1">'/'</span><span class="p">)</span><span class="si">}</span><span class="se">\\</span><span class="s2">z"</span><span class="p">)</span>
        <span class="p">[</span><span class="n">pattern</span><span class="p">,</span> <span class="n">keys</span><span class="p">]</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>This new version of the <code class="highlighter-rouge">route</code> method compiles a given path (possible containing parameters) into a <code class="highlighter-rouge">pattern</code> (a regular expression) and an array of strings called <code class="highlighter-rouge">keys</code>. During request handling, those strings will eventually become keys in the <code class="highlighter-rouge">params</code> hash.</p>

<p>For the above example route, the <code class="highlighter-rouge">[pattern, keys]</code> array returned by the <code class="highlighter-rouge">compile</code> method looks as follows:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre><span class="p">[</span><span class="sr">/\A\/albums\/([^\/]+)\/songs\/([^\/]+)\z/</span><span class="p">,</span> <span class="p">[</span><span class="s2">"album"</span><span class="p">,</span> <span class="s2">"song"</span><span class="p">]]</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>Within the regex, <code class="highlighter-rouge">([^\/]+)</code> captures sequences of characters that do not contain forward slashes – these will be the arguments that fill in the slots provided by our route parameters.</p>

<p>Now on the <em>instance level</em>, we exploit the information stored in <code class="highlighter-rouge">pattern</code> and <code class="highlighter-rouge">keys</code> as follows:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14</pre></td><td class="code"><pre><span class="k">module</span> <span class="nn">Frankie</span>
  <span class="k">class</span> <span class="nc">Application</span>
    <span class="k">def</span> <span class="nf">route!</span>
      <span class="n">match</span> <span class="o">=</span> <span class="no">Application</span><span class="p">.</span><span class="nf">routes</span>
                         <span class="p">.</span><span class="nf">select</span> <span class="p">{</span> <span class="o">|</span><span class="n">r</span><span class="o">|</span> <span class="n">r</span><span class="p">[</span><span class="ss">:verb</span><span class="p">]</span> <span class="o">==</span> <span class="vi">@verb</span> <span class="p">}</span>
                         <span class="p">.</span><span class="nf">find</span>   <span class="p">{</span> <span class="o">|</span><span class="n">r</span><span class="o">|</span> <span class="n">r</span><span class="p">[</span><span class="ss">:pattern</span><span class="p">].</span><span class="nf">match</span><span class="p">(</span><span class="vi">@path</span><span class="p">)</span> <span class="p">}</span>
      <span class="k">return</span> <span class="n">status</span><span class="p">(</span><span class="mi">404</span><span class="p">)</span> <span class="k">unless</span> <span class="n">match</span>

      <span class="n">values</span> <span class="o">=</span> <span class="n">match</span><span class="p">[</span><span class="ss">:pattern</span><span class="p">].</span><span class="nf">match</span><span class="p">(</span><span class="vi">@path</span><span class="p">).</span><span class="nf">captures</span>
      <span class="n">params</span><span class="p">.</span><span class="nf">merge!</span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="ss">:keys</span><span class="p">].</span><span class="nf">zip</span><span class="p">(</span><span class="n">values</span><span class="p">).</span><span class="nf">to_h</span><span class="p">)</span>
      <span class="n">body</span> <span class="nb">instance_eval</span><span class="p">(</span><span class="o">&amp;</span><span class="n">match</span><span class="p">[</span><span class="ss">:block</span><span class="p">])</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>We find a stored pattern that matches (in the regex sense of „match“) the requested path, extract the captured groups (Ruby makes this really easy), and populate our <code class="highlighter-rouge">params</code> hash with the retrieved key-value pairs. For our example route,  the <code class="highlighter-rouge">values</code> array will be <code class="highlighter-rouge">['greatest-hits', 'my-way']</code>, and zipping our stored keys with these values produces the hash</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre><span class="p">{</span> <span class="s1">'album'</span> <span class="o">=&gt;</span> <span class="s1">'greatest-hits'</span><span class="p">,</span> <span class="s1">'song'</span> <span class="o">=&gt;</span> <span class="s1">'my-way'</span> <span class="p">}</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>which we merge into <code class="highlighter-rouge">params</code>. Done!</p>

<blockquote class="aside">
  <p>Sinatra goes out of its way to allow users flexibility in making use of route parameters. In addition to strings, regular expressions are allowed as route paths, and route paths may contain wildcards („splats“) and/or optional parameters. So we have merely scratched the surface here. Also, the way Sinatra stores and processes parametrized routes has changed somewhat with the advent of the <a href="https://github.com/sinatra/mustermann">Mustermann string processing library</a> in Sinatra 2.0. Our approach here is closer to how things used to work up to Sinatra 1.4.x.</p>
</blockquote>

<p>Try it out using <a href="https://github.com/benrodenhaeuser/frankie/blob/master/blog/03_frankie_sees_a_pattern/frankie.rb">this file</a> (which contains the Frankie code as of the end of this part of our series), requesting your favorite song from your favorite album.</p>

<p>Next up in the series: <a href="/2018/06/04/frankie-likes-cookies/">working with Rack middleware</a>.</p>


    </div>
  </div>

  <p class='terminal'>
    <small>&nbsp;</small>
  </p>
  <hr class="line" />
</section>

      <header>
  <p>
    <small>&nbsp;</small>
  </p>
  <a href="http://notes.benrodenhaeuser.io">
    <h1 class="title">
      Ben Rodenhäuser
    </h1>
  </a>

  <div class="description site-description">
    Notes on programming
  </div>

  <div class="content">
    <hr class="line" />

    <div class="sidebar-content">
      
      <h5>
        <a class="post-link" href="/2018/06/04/frankie-likes-cookies/">Frankie Likes Cookies</a><span class="sidebar-pad"></span><small>06/04/18</small>
      </h5>
      <p class="sidebar">
          Working with Rack middleware: part 04 of the "Sinatra From Scratch" series.
      </p>
      
      <h5>
        <a class="post-link" href="/2018/06/03/frankie-sees-a-pattern/">Frankie Sees a Pattern</a><span class="sidebar-pad"></span><small>06/03/18</small>
      </h5>
      <p class="sidebar">
          Defining parametrized routes: part 03 of the "Sinatra From Scratch" series.
      </p>
      
      <h5>
        <a class="post-link" href="/2018/06/02/frankie-reaches-for-the-top/">Frankie Reaches for the Top (Level)</a><span class="sidebar-pad"></span><small>06/02/18</small>
      </h5>
      <p class="sidebar">
          The top-level DSL: part 02 of the "Sinatra From Scratch" series.
      </p>
      
      <h5>
        <a class="post-link" href="/2018/06/01/sinatra-from-scratch/">Sinatra From Scratch</a><span class="sidebar-pad"></span><small>06/01/18</small>
      </h5>
      <p class="sidebar">
          Building a toy version of a Ruby web framework from the ground up.
      </p>
      
      <h5>
        <a class="post-link" href="/2017/12/20/operations-on-sets/">Operations on Sets</a><span class="sidebar-pad"></span><small>12/20/17</small>
      </h5>
      <p class="sidebar">
          Part 03 of the "Bunch of Sets" series.
      </p>
      
      <h5>
        <a class="post-link" href="/2017/12/19/modeling-sets/">Modeling Sets</a><span class="sidebar-pad"></span><small>12/19/17</small>
      </h5>
      <p class="sidebar">
          Part 02 of the "Bunch of Sets" series.
      </p>
      
      <h5>
        <a class="post-link" href="/2017/12/18/a-bunch-of-sets/">A Bunch of Sets</a><span class="sidebar-pad"></span><small>12/18/17</small>
      </h5>
      <p class="sidebar">
          A generic implementation of classical sets, multisets and fuzzy sets in Ruby.
      </p>
      
      <h5>
        <a class="post-link" href="/2017/07/06/object-passing/">Passing Objects</a><span class="sidebar-pad"></span><small>07/06/17</small>
      </h5>
      <p class="sidebar">
          Pass by reference or pass by value? The object passing strategy followed by Ruby.
      </p>
      
      <h5>
        <a class="post-link" href="/2017/05/15/sorting-in-ruby/">Sorting in Ruby</a><span class="sidebar-pad"></span><small>05/15/17</small>
      </h5>
      <p class="sidebar">
          Why does Ruby have two sorting methods, rather than one?
      </p>
      
    </div>

    <hr class="line" />

    <div class="external">
      <a href="http://github.com/benrodenhaeuser">
        <img class="mark" src="/assets/images/GitHub-Mark-64px.png" />
      </a>
    </div>
  </div>
</header>

      <!-- <footer>
  <p><small>Ben Rodenhäuser 2017 | <a href="http://github.com/benrodenhaeuser">GitHub Profile</a></small></p>
</footer> -->

    </div>
    <script src="/assets/js/scale.fix.js"></script>
  </body>
</html>
  

