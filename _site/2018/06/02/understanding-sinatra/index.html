<!doctype html>
<html lang="en-US">
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <title>Ben Rodenhäuser | Notes on programming</title>

  <link href="https://fonts.googleapis.com/css?family=Lato|Anton|Roboto Mono" rel="stylesheet">
  <link rel="stylesheet" href="/assets/css/main.css?v=">
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    CommonHTML: { linebreaks: { automatic: true } },
    "HTML-CSS": { linebreaks: { automatic: true } },
           SVG: { linebreaks: { automatic: true } }
  });
  </script>
  <script type="text/javascript"
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML&delayStartupUntilConfig">
  </script>
  <script src="/assets/jax/config.js"></script>

  <!-- <meta name="viewport" content="width=device-width"> -->
  <!--[if lt IE 9]>
  <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  
    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-99334571-1', 'auto');
        ga('send', 'pageview');
    </script>
  
</head>

  <body>
    <div class="wrapper">
      <section>
  <p>
    <small>
      02 June 2018
    </small>
  </p>

  <h1 class="title">
    Understanding Sinatra
  </h1>

  <div class="description">
    Building a toy version of a Ruby web framework from the ground up.
  </div>

  <div class="content">
    <hr class="line" />
    <div class="content-inner">
      <h2 id="introduction">Introduction</h2>

<blockquote>
  <p>We are going to develop our toy version of Sinatra in a number of iterations, starting “tiny”, and building towards “small”. This corresponds to how I built Frankie, too, even though this blog post makes the process perhaps appear a little more orderly than it really was. 
While the Frankie code shown here is not lifted <em>verbatim</em> from the Sinatra code base, I do follow the Sinatra model very very closely. The aim is not to be original. To the contrary, it’s to understand Sinatra by building it from scratch.</p>
</blockquote>

<p>Here is what we will be covering:</p>

<ul>
  <li>Storing routes</li>
  <li>Handling requests</li>
  <li>The top-level DSL</li>
  <li>Parametrized routes</li>
  <li>Rack middleware</li>
</ul>

<p>On every topic listed above, we will implement a more or less simplified version of core Sinatra functionality. As a result, following along with this post should be a good preparation for digging into the Sinatra code base yourself. My hope is that Frankie could be helpful to some as a launchpad into understanding Sinatra internals.</p>

<p>The version of Frankie linked to at the end of the post has some additional features that I will not discuss in detail in this post:</p>

<ul>
  <li>Code organization with view templates</li>
  <li>Flexible return values for route blocks</li>
  <li>Flexible control flow with <code class="highlighter-rouge">catch</code>/<code class="highlighter-rouge">throw</code></li>
</ul>

<p>Making sense of these topics should not be too difficult after reading this post.</p>

<h2 id="hello-frankie">Hello Frankie</h2>

<ul>
  <li>At its core, Sinatra is (1) a mechanism for storing routes, and (2) a mechanism for handling requests based on the routes stored. So this is where we start.</li>
  <li>Sinatra makes use of the following basic division of labor: storing routes is a class-level concern, but requests are handled by a fresh instance.</li>
  <li>If you investigate the Sinatra source code, you will see that part (1), route storage, is a class task, while part (2), request handling, happens at the instance level. Let’s first see how to store routes.</li>
</ul>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25</pre></td><td class="code"><pre><span class="k">module</span> <span class="nn">Frankie</span>
  <span class="k">class</span> <span class="nc">Application</span>
    <span class="k">class</span> <span class="o">&lt;&lt;</span> <span class="nb">self</span>
      <span class="k">def</span> <span class="nf">routes</span>
        <span class="vi">@routes</span> <span class="o">||=</span> <span class="p">[]</span>
      <span class="k">end</span>

      <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
        <span class="n">route</span><span class="p">(</span><span class="s1">'GET'</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">block</span><span class="p">)</span>
      <span class="k">end</span>

      <span class="k">def</span> <span class="nf">post</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
        <span class="n">route</span><span class="p">(</span><span class="s1">'POST'</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">block</span><span class="p">)</span>
      <span class="k">end</span>

      <span class="k">def</span> <span class="nf">route</span><span class="p">(</span><span class="n">verb</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">block</span><span class="p">)</span>
        <span class="n">routes</span> <span class="o">&lt;&lt;</span> <span class="p">{</span>
          <span class="ss">verb:  </span><span class="n">verb</span><span class="p">,</span>
          <span class="ss">path:  </span><span class="n">path</span><span class="p">,</span>
          <span class="ss">block: </span><span class="n">block</span>
        <span class="p">}</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>Routes are stored in an array which we can access via the <code class="highlighter-rouge">routes</code> class method. Invoking the <code class="highlighter-rouge">get</code> and <code class="highlighter-rouge">post</code> method defined above leads to a route being stored. As you can see by inspecting the <code class="highlighter-rouge">route</code> method, a route has three components: an HTTP <code class="highlighter-rouge">verb</code>, a URL <code class="highlighter-rouge">path</code>, and a block (a Proc object, to be precise). If the <code class="highlighter-rouge">verb</code> for a given request is <code class="highlighter-rouge">GET</code>, and its <code class="highlighter-rouge">path</code> is <code class="highlighter-rouge">'/'</code>, then you can imagine that the block will determine how to handle that request.</p>

<p>Running the following sample code against the above class definition:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2</pre></td><td class="code"><pre><span class="no">Application</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="s1">'/'</span><span class="p">)</span> <span class="p">{</span> <span class="s2">"Frankie says hello."</span> <span class="p">}</span>
<span class="nb">puts</span> <span class="no">Application</span><span class="p">.</span><span class="nf">routes</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>… you should see something similar to this:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5</pre></td><td class="code"><pre><span class="p">{</span>
  <span class="ss">:verb</span> <span class="o">=&gt;</span> <span class="s2">"GET"</span><span class="p">,</span>
  <span class="ss">:path</span> <span class="o">=&gt;</span> <span class="s2">"/"</span><span class="p">,</span>
  <span class="ss">:block</span> <span class="o">=&gt;</span> <span class="c1">#&lt;Proc:0x007faa7b03f458@frankie.rb:36&gt;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>The route is ready to be requested! But how do we handle requests? Here you go:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48</pre></td><td class="code"><pre><span class="k">module</span> <span class="nn">Frankie</span>
  <span class="k">class</span> <span class="nc">Application</span>
    <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">call</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
      <span class="kp">new</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
      <span class="vi">@request</span>  <span class="o">=</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Request</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
      <span class="vi">@verb</span>     <span class="o">=</span> <span class="vi">@request</span><span class="p">.</span><span class="nf">request_method</span>
      <span class="vi">@path</span>     <span class="o">=</span> <span class="vi">@request</span><span class="p">.</span><span class="nf">path_info</span>

      <span class="vi">@response</span> <span class="o">=</span> <span class="p">{</span>
        <span class="ss">status:  </span><span class="mi">200</span><span class="p">,</span>
        <span class="ss">headers: </span><span class="n">headers</span><span class="p">,</span>
        <span class="ss">body:    </span><span class="p">[]</span>
      <span class="p">}</span>

      <span class="n">route!</span>

      <span class="vi">@response</span><span class="p">.</span><span class="nf">values</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nf">params</span>
      <span class="vi">@request</span><span class="p">.</span><span class="nf">params</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nf">status</span><span class="p">(</span><span class="n">code</span><span class="p">)</span>
      <span class="vi">@response</span><span class="p">[</span><span class="ss">:status</span><span class="p">]</span> <span class="o">=</span> <span class="n">code</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nf">headers</span>
      <span class="vi">@headers</span> <span class="o">||=</span> <span class="p">{</span> <span class="s1">'Content-Type'</span> <span class="o">=&gt;</span> <span class="s1">'text/html'</span> <span class="p">}</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nf">body</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
      <span class="vi">@response</span><span class="p">[</span><span class="ss">:body</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">string</span><span class="p">]</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nf">route!</span>
      <span class="n">match</span> <span class="o">=</span> <span class="no">Application</span><span class="p">.</span><span class="nf">routes</span>
                         <span class="p">.</span><span class="nf">select</span> <span class="p">{</span> <span class="o">|</span><span class="n">route</span><span class="o">|</span> <span class="n">route</span><span class="p">[</span><span class="ss">:verb</span><span class="p">]</span> <span class="o">==</span> <span class="vi">@verb</span> <span class="p">}</span>
                         <span class="p">.</span><span class="nf">find</span>   <span class="p">{</span> <span class="o">|</span><span class="n">route</span><span class="o">|</span> <span class="n">route</span><span class="p">[</span><span class="ss">:path</span><span class="p">]</span> <span class="o">==</span> <span class="vi">@path</span> <span class="p">}</span>
      <span class="k">return</span> <span class="n">status</span><span class="p">(</span><span class="mi">404</span><span class="p">)</span> <span class="k">unless</span> <span class="n">match</span>

      <span class="n">body</span> <span class="n">match</span><span class="p">[</span><span class="ss">:block</span><span class="p">].</span><span class="nf">call</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>Some points of note:</p>

<ul>
  <li>Sinatra implements the <a href="https://rack.github.io">Rack interface</a>, and, of course, Frankie follows suit: our <code class="highlighter-rouge">Application</code> class responds to a <code class="highlighter-rouge">call</code> method which returns a three-element array <code class="highlighter-rouge">[status, headers, body]</code>. Rack does the heavy lifting of parsing the HTTP request into the <code class="highlighter-rouge">env</code> hash that is passed to <code class="highlighter-rouge">call</code>, and assembling a valid HTTP response from <code class="highlighter-rouge">call</code>’s return value.</li>
  <li>The <em>class</em> method <code class="highlighter-rouge">call</code> creates a new instance of <code class="highlighter-rouge">Application</code>, and invokes the <em>instance</em> method <code class="highlighter-rouge">call</code> on that instance, passing along <code class="highlighter-rouge">env</code>. This reflects the stateless nature of the HTTP protocol: if the class itself were to handle the request, information could easily leak across requests.</li>
  <li>Our setup provides some useful defaults: unless specified otherwise, we return a <code class="highlighter-rouge">200 OK</code> message with content type <code class="highlighter-rouge">text/html</code>.</li>
  <li>The <code class="highlighter-rouge">route!</code> method is really the heart of the matter. Given an incoming request, <code class="highlighter-rouge">route!</code> attempts to fetch a matching route from the <code class="highlighter-rouge">routes</code> array discussed earlier, and, if succesful, calls the Proc object stored for that route. The return value of that call determines the body of our HTTP response (line XX). If, on the other hand, no matching route is to be found, we send a 404 response to the client.</li>
</ul>

<p>To see this in action, let’s add our test route again, and spin up a web server. Let’s add <code class="highlighter-rouge">require 'rack'</code> to the top of the file, and the following code to the bottom:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2</pre></td><td class="code"><pre><span class="no">Frankie</span><span class="o">::</span><span class="no">Application</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="s1">'/'</span><span class="p">)</span> <span class="p">{</span> <span class="s2">"Frankie says hello."</span> <span class="p">}</span>
<span class="no">Rack</span><span class="o">::</span><span class="no">Handler</span><span class="o">::</span><span class="no">WEBrick</span><span class="p">.</span><span class="nf">run</span> <span class="no">Frankie</span><span class="o">::</span><span class="no">Application</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>Run the code (the file is <a href="https://github.com/benrodenhaeuser/frankie/blob/master/iterations/01_hello_frankie/frankie.rb">here</a>), point your browser to <code class="highlighter-rouge">localhost:8080</code> (8080 is the port <a href="https://github.com/rack/rack/blob/42e48013dd1b6dbda990dfa3851856c199b0b1f9/lib/rack/handler/webrick.rb#L32">set by the <code class="highlighter-rouge">Rack::Handler::WEBrick.run</code> method</a>), and you will be greeted by Frankie.</p>

<p>Well, hello there! We got ourselves a web framework! Of course, the people behind Sinatra like to insist that Sinatra is not a framework. It stands to reason, then, that Frankie is not a framework either. Oh well.</p>

<h2 id="frankie-goes-top-level">Frankie goes top level</h2>

<p>Sinatra is often praised for its elegant top-level DSL. To get a Sinatra application going, all you really need to do is <code class="highlighter-rouge">require 'sinatra'</code> at the top of your file, and go forth writing routes like the following:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4</pre></td><td class="code"><pre><span class="n">get</span> <span class="s1">'/ditty'</span> <span class="k">do</span>
  <span class="n">status</span> <span class="mi">301</span>
  <span class="s1">'Go look elsewhere'</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>This code is quite mysterious: first, the <code class="highlighter-rouge">get</code> method is available at the top level of our program. How so? Second, the <code class="highlighter-rouge">status</code> method – which sets the status code of our HTTP response – is available within the route block. Why is that?</p>

<p>The answer is that (1) Sinatra delegates certain method calls – like <code class="highlighter-rouge">get</code> invocations, for instance – from the top level to the <code class="highlighter-rouge">Application</code> class, and (2) the block that is passed with the <code class="highlighter-rouge">get</code> invocation will eventually be evaluated in the context of the instance handling the request (rather than in the context provided by top-level <code class="highlighter-rouge">main</code>).</p>

<p>Now Frankie should certainly be able to do that, too! Let’s deal with the two aspects in turn. First, to be able to delegate top level method calls, we add another module to <code class="highlighter-rouge">Frankie</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14</pre></td><td class="code"><pre><span class="k">module</span> <span class="nn">Frankie</span>
  <span class="k">module</span> <span class="nn">Delegator</span>
    <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">delegate</span><span class="p">(</span><span class="n">method_name</span><span class="p">)</span>
      <span class="n">define_method</span><span class="p">(</span><span class="n">method_name</span><span class="p">)</span> <span class="k">do</span> <span class="o">|*</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="o">|</span>
        <span class="no">Application</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="n">method_name</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
      <span class="k">end</span>
    <span class="k">end</span>

    <span class="n">delegate</span><span class="p">(</span><span class="ss">:get</span><span class="p">)</span>
    <span class="n">delegate</span><span class="p">(</span><span class="ss">:post</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="kp">extend</span> <span class="no">Frankie</span><span class="o">::</span><span class="no">Delegator</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>This code passes on any <code class="highlighter-rouge">get</code> and <code class="highlighter-rouge">post</code> invocations received by <code class="highlighter-rouge">main</code> to the application object, which is of course exactly what we want. Take note that the last line of the snippet reads <code class="highlighter-rouge">extend</code> rather than <code class="highlighter-rouge">include</code>. If we had used <code class="highlighter-rouge">include</code>, the newly defined methods would be added to <code class="highlighter-rouge">Object</code>. <code class="highlighter-rouge">extend</code> merely attaches them to <code class="highlighter-rouge">main</code>.</p>

<p>This takes care of our first issue: we can now freely invoke <code class="highlighter-rouge">get</code> from the top level, without having to prefix our routes with <code class="highlighter-rouge">Frankie::Application</code>. Nice!</p>

<p>Now what about method invocations <em>within</em> the route block (remember the call to <code class="highlighter-rouge">status</code> from the sample route above)? The answer is, again, meta-programming, and more in particular: <code class="highlighter-rouge">instance_eval</code>. The documentation for this method (which belongs to <code class="highlighter-rouge">BasicObject</code> and is thus available to any Ruby obect) says that <code class="highlighter-rouge">instance_eval</code> “evaluates a string containing Ruby source code, or the given block, within the context of the receiver.” Now this is of course precisely what we need, since we want our route block to be evaluated in the context of the instance handling the current request.</p>

<p>To put <code class="highlighter-rouge">instance_eval</code> to use, all we really need to change is one line of code – the last line of our <code class="highlighter-rouge">route!</code> method:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12</pre></td><td class="code"><pre><span class="k">module</span> <span class="nn">Frankie</span>
  <span class="k">class</span> <span class="nc">Application</span>
	<span class="k">def</span> <span class="nf">route!</span>
	  <span class="n">match</span> <span class="o">=</span> <span class="no">Application</span><span class="p">.</span><span class="nf">routes</span>
	                     <span class="p">.</span><span class="nf">select</span> <span class="p">{</span> <span class="o">|</span><span class="n">route</span><span class="o">|</span> <span class="n">route</span><span class="p">[</span><span class="ss">:verb</span><span class="p">]</span> <span class="o">==</span> <span class="vi">@verb</span> <span class="p">}</span>
	                     <span class="p">.</span><span class="nf">find</span>   <span class="p">{</span> <span class="o">|</span><span class="n">route</span><span class="o">|</span> <span class="n">route</span><span class="p">[</span><span class="ss">:path</span><span class="p">]</span> <span class="o">==</span> <span class="vi">@path</span> <span class="p">}</span>
	  <span class="k">return</span> <span class="n">status</span><span class="p">(</span><span class="mi">404</span><span class="p">)</span> <span class="k">unless</span> <span class="n">match</span>
	
	  <span class="n">body</span> <span class="nb">instance_eval</span><span class="p">(</span><span class="o">&amp;</span><span class="n">match</span><span class="p">[</span><span class="ss">:block</span><span class="p">])</span>
	<span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>Recall that <code class="highlighter-rouge">match[:block]</code> is a Proc object. We convert it to a block <code class="highlighter-rouge">&amp;match[:block]</code>, and pass it into <code class="highlighter-rouge">instance_eval</code>. Since this method call is issued by the <code class="highlighter-rouge">Frankie::Application</code> instance, <code class="highlighter-rouge">Frankie::Application</code> provides the context in which the block is evaluated. In particular, all the instance methods of <code class="highlighter-rouge">Frankie::Application</code> are available within the block.</p>

<p>Run <a href="https://github.com/benrodenhaeuser/frankie/blob/master/iterations/02_frankie_goes_top_level/frankie.rb">this file</a> (our code so far), head to <code class="highlighter-rouge">localhost:8080/ditty</code>, and you will see that our sample request from above is handled correctly: we get back a 301, and are told to “go look elsewhere”. Fair enough.</p>

<p><em>Aside:</em> While early versions of Sinatra used to make use of <code class="highlighter-rouge">instance_eval</code>, later versions (including the current one) employ a different mechanism that is more sophisticated as well as slightly more involved. It involves generating unbound method objects that are dynamically bound to the current instance, and has several advantages that are beyond the scope of this post.</p>

<h2 id="frankie-recognizes-patterns">Frankie recognizes patterns</h2>

<p>What is sorely missing from Frankie so far is the ability to <em>parametrize routes</em>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3</pre></td><td class="code"><pre><span class="n">get</span> <span class="s1">'/albums/:album/song/:song'</span> <span class="k">do</span>
  <span class="s2">"My favourite song is '</span><span class="si">#{</span><span class="n">params</span><span class="p">[</span><span class="s1">'song'</span><span class="p">]</span><span class="si">}</span><span class="s2">' from '</span><span class="si">#{</span><span class="n">params</span><span class="p">[</span><span class="s1">'album'</span><span class="p">]</span><span class="si">}</span><span class="s2">'."</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>Here is what we want to be able to do. Suppose a user sends a request with the path</p>

<blockquote>
  <p><code class="highlighter-rouge">/albums/greatest-hits/songs/my-way</code></p>
</blockquote>

<p>We would like to match this path against a regular expression (generated by Frankie as our route is processed) that produces the captures <code class="highlighter-rouge">greatest-hits</code> and <code class="highlighter-rouge">my-way</code>. These should be linked with the route parameters to form a hash</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre><span class="p">{</span> <span class="s1">'album'</span> <span class="o">=&gt;</span> <span class="s1">'greatest-hits'</span><span class="p">,</span> <span class="s1">'song'</span> <span class="o">=&gt;</span> <span class="s1">'my-way'</span> <span class="p">}</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>which should be merged into the <code class="highlighter-rouge">params</code> hash (which is stored as part of the Rack <code class="highlighter-rouge">@request</code> object). The <code class="highlighter-rouge">params</code> hash, in turn, needs to be available to the instance handling the request, so it should be the return value of an instance method <code class="highlighter-rouge">params</code>.  As we saw above, route blocks are evaluated in the context of the current instance, so if the current instance has access to an instance method, then we can call it from a route block.</p>

<p>Starting at the end, we implement the <code class="highlighter-rouge">params</code> method first:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7</pre></td><td class="code"><pre><span class="k">module</span> <span class="nn">Frankie</span>
  <span class="k">class</span> <span class="nc">Application</span>
    <span class="k">def</span> <span class="nf">params</span>
      <span class="vi">@request</span><span class="p">.</span><span class="nf">params</span>
    <span class="k">end</span>
  <span class="k">end</span> 
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>Remember that <code class="highlighter-rouge">@request</code> is an instance of <code class="highlighter-rouge">Rack::Request</code>.</p>

<p>Next, let’s adapt our mechanism for storing routes to enable the handling of parametrized routes. This needs to happen at the <em>class level</em>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33</pre></td><td class="code"><pre><span class="k">module</span> <span class="nn">Frankie</span>  
  <span class="k">class</span> <span class="nc">Application</span>
    <span class="k">class</span> <span class="o">&lt;&lt;</span> <span class="nb">self</span>
      <span class="k">def</span> <span class="nf">route</span><span class="p">(</span><span class="n">verb</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">block</span><span class="p">)</span>
        <span class="n">pattern</span><span class="p">,</span> <span class="n">keys</span> <span class="o">=</span> <span class="n">compile</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>

        <span class="n">routes</span> <span class="o">&lt;&lt;</span> <span class="p">{</span>
          <span class="ss">verb:     </span><span class="n">verb</span><span class="p">,</span>
          <span class="ss">pattern:  </span><span class="n">pattern</span><span class="p">,</span>
          <span class="ss">keys:     </span><span class="n">keys</span><span class="p">,</span>
          <span class="ss">block:    </span><span class="n">block</span>
        <span class="p">}</span>
      <span class="k">end</span>

      <span class="k">def</span> <span class="nf">compile</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="n">segments</span> <span class="o">=</span> <span class="n">path</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="s1">'/'</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">segments</span><span class="p">.</span><span class="nf">map!</span> <span class="k">do</span> <span class="o">|</span><span class="n">segment</span><span class="o">|</span>
          <span class="k">if</span> <span class="n">segment</span><span class="p">.</span><span class="nf">start_with?</span><span class="p">(</span><span class="s1">':'</span><span class="p">)</span>
            <span class="n">keys</span> <span class="o">&lt;&lt;</span> <span class="n">segment</span><span class="p">[</span><span class="mi">1</span><span class="p">.</span><span class="nf">.</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="s2">"([^</span><span class="se">\/</span><span class="s2">]+)"</span>
          <span class="k">else</span>
            <span class="n">segment</span>
          <span class="k">end</span>
        <span class="k">end</span>

        <span class="n">pattern</span> <span class="o">=</span> <span class="no">Regexp</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="s2">"</span><span class="se">\\</span><span class="s2">A</span><span class="si">#{</span><span class="n">segments</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="s1">'/'</span><span class="p">)</span><span class="si">}</span><span class="se">\\</span><span class="s2">z"</span><span class="p">)</span>
        <span class="p">[</span><span class="n">pattern</span><span class="p">,</span> <span class="n">keys</span><span class="p">]</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>Instead of simply storing a request path, we compile a given path (possible containing parameters) into a <code class="highlighter-rouge">pattern</code> (a regular expression) and a set of <code class="highlighter-rouge">keys</code> (i.e., strings). The keys will eventually become hash keys in our <code class="highlighter-rouge">params</code> hash.</p>

<p>For the above example route, the <code class="highlighter-rouge">[pattern, keys]</code> array returned by the <code class="highlighter-rouge">compile</code> class method looks as follows:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre><span class="p">[</span><span class="sr">/\A\/albums\/([^\/]+)\/songs\/([^\/]+)\z/</span><span class="p">,</span> <span class="p">[</span><span class="s2">"album"</span><span class="p">,</span> <span class="s2">"song"</span><span class="p">]]</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>Within the regex, <code class="highlighter-rouge">([^\/]+)</code> matches sequences of characters that do not contain forward slashes.</p>

<p>Now on the <em>instance level</em>, we exploit the information stored in <code class="highlighter-rouge">pattern</code> and <code class="highlighter-rouge">keys</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14</pre></td><td class="code"><pre><span class="k">module</span> <span class="nn">Frankie</span>
  <span class="k">class</span> <span class="nc">Application</span>
    <span class="k">def</span> <span class="nf">route!</span>
      <span class="n">match</span> <span class="o">=</span> <span class="no">Application</span><span class="p">.</span><span class="nf">routes</span>
                         <span class="p">.</span><span class="nf">select</span> <span class="p">{</span> <span class="o">|</span><span class="n">route</span><span class="o">|</span> <span class="n">route</span><span class="p">[</span><span class="ss">:verb</span><span class="p">]</span> <span class="o">==</span> <span class="vi">@verb</span> <span class="p">}</span>
                         <span class="p">.</span><span class="nf">find</span> <span class="p">{</span> <span class="o">|</span><span class="n">route</span><span class="o">|</span> <span class="n">route</span><span class="p">[</span><span class="ss">:pattern</span><span class="p">].</span><span class="nf">match</span><span class="p">(</span><span class="vi">@path</span><span class="p">)</span> <span class="p">}</span>
      <span class="k">return</span> <span class="n">status</span><span class="p">(</span><span class="mi">404</span><span class="p">)</span> <span class="k">unless</span> <span class="n">match</span>

      <span class="n">values</span> <span class="o">=</span> <span class="n">match</span><span class="p">[</span><span class="ss">:pattern</span><span class="p">].</span><span class="nf">match</span><span class="p">(</span><span class="vi">@path</span><span class="p">).</span><span class="nf">captures</span>
      <span class="n">params</span><span class="p">.</span><span class="nf">merge!</span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="ss">:keys</span><span class="p">].</span><span class="nf">zip</span><span class="p">(</span><span class="n">values</span><span class="p">).</span><span class="nf">to_h</span><span class="p">)</span>
      <span class="n">body</span> <span class="nb">instance_eval</span><span class="p">(</span><span class="o">&amp;</span><span class="n">match</span><span class="p">[</span><span class="ss">:block</span><span class="p">])</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>We find a stored pattern that matches (in the regex sense of „match“) the requested path, extract the captured groups (Ruby makes this really easy), and populate our <code class="highlighter-rouge">params</code> hash with the retrieved key-value pairs. For our example route,  the <code class="highlighter-rouge">values</code> array will be <code class="highlighter-rouge">['greatest-hits', 'my-way']</code>, and zipping our stored keys with these values produces the hash</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre><span class="p">{</span> <span class="s1">'album'</span> <span class="o">=&gt;</span> <span class="s1">'greatest-hits'</span><span class="p">,</span> <span class="s1">'song'</span> <span class="o">=&gt;</span> <span class="s1">'my-way'</span> <span class="p">}</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>which we merge into <code class="highlighter-rouge">params</code>. Done! Try it out using <a href="https://github.com/benrodenhaeuser/frankie/blob/master/iterations/03_frankie_recognizes_patterns/frankie.rb">this file</a>, if you like, requesting your favourite song from your favourite album.</p>

<p><em>Aside:</em> Sinatra itself goes to considerable length to allow users flexibility in making use of route parameters – we have only scratched the surface here. Also, as of Sinatra 2.0, a dedicated gem is used for pattern matching, the <a href="https://github.com/sinatra/mustermann">Mustermann library</a>. Again, this additional level of sophistication is beyond the scope of this post.</p>

<h2 id="frankie-likes-cookies">Frankie likes cookies</h2>

<p>Sinatra applications are Rack applications, so they place nice with Rack middleware. If you have a piece of middleware, all you need to do is place a <code class="highlighter-rouge">use</code> statement close to the top of your Sinatra application file, such as:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre><span class="n">use</span> <span class="no">MyMiddleware</span> 
</pre></td></tr></tbody></table>
</div>
</div>

<p>In this section, we will implement this functionality in Frankie, using cookie-based session management as provided by <code class="highlighter-rouge">Rack::Session::Cookie</code> as an example (which is also what Sinatra uses by default).</p>

<p>First, let’s look at how to set up the middleware chain. The overall app encompassing all middleware nodes (and our application instance) is stored in an instance variable <code class="highlighter-rouge">@prototype</code> (the choice of name will become clear in a minute). Setting up the <code class="highlighter-rouge">@protoype</code> object makes heavy use of the functionality already provided by Rack:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Application</span>
  <span class="k">class</span> <span class="o">&lt;&lt;</span> <span class="nb">self</span>
	<span class="k">def</span> <span class="nf">prototype</span>
	  <span class="vi">@prototype</span> <span class="o">||=</span> <span class="kp">new</span>
    <span class="k">end</span>

    <span class="k">alias</span> <span class="kp">new</span><span class="o">!</span> <span class="kp">new</span>

    <span class="k">def</span> <span class="nf">new</span>
      <span class="n">instance</span> <span class="o">=</span> <span class="kp">new</span><span class="o">!</span>
      <span class="n">build</span><span class="p">(</span><span class="n">instance</span><span class="p">).</span><span class="nf">to_app</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nf">build</span><span class="p">(</span><span class="n">app</span><span class="p">)</span>
      <span class="n">builder</span> <span class="o">=</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Builder</span><span class="p">.</span><span class="nf">new</span>

      <span class="k">if</span> <span class="vi">@middleware</span>
        <span class="vi">@middleware</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">middleware</span><span class="p">,</span> <span class="n">args</span><span class="o">|</span>
          <span class="n">builder</span><span class="p">.</span><span class="nf">use</span><span class="p">(</span><span class="n">middleware</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">end</span>
      <span class="k">end</span>

      <span class="n">builder</span><span class="p">.</span><span class="nf">run</span> <span class="n">app</span>
      <span class="n">builder</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nf">use</span><span class="p">(</span><span class="n">middleware</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
      <span class="p">(</span><span class="vi">@middleware</span> <span class="o">||=</span> <span class="p">[])</span> <span class="o">&lt;&lt;</span> <span class="p">[</span><span class="n">middleware</span><span class="p">,</span> <span class="n">args</span><span class="p">]</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>The gist is this: every <code class="highlighter-rouge">use</code> statement in our code adds a middleware node to the <code class="highlighter-rouge">@middleware</code> array. As a <code class="highlighter-rouge">@prototype</code> object is created, all nodes are „wired up“, with our <code class="highlighter-rouge">Frankie::Application</code> instance being the last node in the chain (the node „fronting“ the chain).  As a result, we got ourselves a Rack app accessible via the <code class="highlighter-rouge">prototype</code> method.</p>

<p>Now how to handle an incoming request given this setting? There <em>is</em> a conceptual conundrum to solve. Our earlier code used to create a fresh application instance for every request that needs to be handled. However, once the middleware chain is set up as above, a single application instance will survive across requests. The solution is to use this instance as a blueprint which is duplicated with every request. Handling a request then involves roughly the following steps:</p>

<ul>
  <li>The class method <code class="highlighter-rouge">call</code> is invoked on <code class="highlighter-rouge">Frankie::Application</code>.</li>
  <li>The body of that method invokes <code class="highlighter-rouge">call</code> on the <code class="highlighter-rouge">@prototype</code> object, which is a Rack app that contains all middleware nodes and is fronted by a <code class="highlighter-rouge">Frankie::Application</code> instance.</li>
  <li>If that <code class="highlighter-rouge">@prototype</code> object does not exist already, create it on the fly.</li>
  <li>Walk through the middleware chain invoking <code class="highlighter-rouge">call</code> on each node. Our <code class="highlighter-rouge">Frankie::Application</code> instance is the last node in the chain.</li>
  <li>As this last node is <code class="highlighter-rouge">call</code>ed, the instance <em>duplicates itself</em>, and lets the duplicated instance handle the request.</li>
  <li>In this way, the instance fronting the middleware chain persists across requests, but never actually handles a request itself.</li>
</ul>

<p>In code, this looks like as follows:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Application</span>
  <span class="k">class</span> <span class="o">&lt;&lt;</span> <span class="nb">self</span>
    <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
      <span class="n">prototype</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
    <span class="nb">dup</span><span class="p">.</span><span class="nf">call!</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">call!</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
    <span class="c1"># routing code that used to live in `call` goes here</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>Now return to our use case of cookie-based session management. We add a <code class="highlighter-rouge">session</code> method for accessing the session object. This simply wraps the session object provided by Rack:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7</pre></td><td class="code"><pre><span class="k">module</span> 
  <span class="nn">class</span> <span class="no">Application</span>
    <span class="k">def</span> <span class="nf">session</span>
      <span class="vi">@request</span><span class="p">.</span><span class="nf">session</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>All that we need to do as a Frankie user is to add the earlier-mentioned use statement to our app:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre><span class="n">use</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Session</span><span class="o">::</span><span class="no">Cookie</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>(TODO: The Test)</p>

<h2 id="theres-more">There’s More</h2>

<ul>
  <li>The code on github includes:
    <ul>
      <li><em>View templates</em> (The same mechanism is also responsible for the fact that instance variables – but not local variables – declared in route blocks are available to template files. They end up becoming part of the state of the <code class="highlighter-rouge">Application</code> instance, which is also the context in which templates are parsed. I won’t discuss templates further in this post, but it is not difficult to add them to Frankie, and the version.)</li>
      <li><em>Throw/catch</em></li>
      <li><em>Flexible return values</em></li>
    </ul>
  </li>
  <li>There is also a simple sample Frankie application.</li>
</ul>


    </div>
  </div>

  <p class='terminal'>
    <small>&nbsp;</small>
  </p>
  <hr class="line" />
</section>

      <header>
  <p>
    <small>&nbsp;</small>
  </p>
  <a href="http://notes.benrodenhaeuser.io">
    <h1 class="title">
      Ben Rodenhäuser
    </h1>
  </a>

  <div class="description site-description">
    Notes on programming
  </div>

  <div class="content">
    <hr class="line" />

    <div class="sidebar-content">
      
      <h5>
        <a class="post-link" href="/2018/06/02/understanding-sinatra/">Understanding Sinatra</a><span class="sidebar-pad"></span><small>02 Jun 2018</small>
      </h5>
      <p class="sidebar">
          Building a toy version of a Ruby web framework from the ground up.
      </p>
      
      <h5>
        <a class="post-link" href="/2017/12/18/a-bunch-of-sets/">A Bunch of Sets</a><span class="sidebar-pad"></span><small>18 Dec 2017</small>
      </h5>
      <p class="sidebar">
          A generic implementation of classical sets, multisets and fuzzy sets.
      </p>
      
      <h5>
        <a class="post-link" href="/2017/07/06/object-passing/">Passing Objects</a><span class="sidebar-pad"></span><small>06 Jul 2017</small>
      </h5>
      <p class="sidebar">
          Pass by reference or pass by value? The object passing strategy followed by Ruby.
      </p>
      
      <h5>
        <a class="post-link" href="/2017/05/15/sorting-in-ruby/">Sorting in Ruby</a><span class="sidebar-pad"></span><small>15 May 2017</small>
      </h5>
      <p class="sidebar">
          Why does Ruby have two sorting methods, rather than one?
      </p>
      
    </div>

    <hr class="line" />

    <div class="external">
      <a href="http://github.com/benrodenhaeuser">
        <img class="mark" src="/assets/images/GitHub-Mark-64px.png" />
      </a>
    </div>
  </div>
</header>

      <!-- <footer>
  <p><small>Ben Rodenhäuser 2017 | <a href="http://github.com/benrodenhaeuser">GitHub Profile</a></small></p>
</footer> -->

    </div>
    <script src="/assets/js/scale.fix.js"></script>
  </body>
</html>
  

